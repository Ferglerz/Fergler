// Graph Management Module
// Handles interactive compression curve editing, point manipulation, and curve interpolation
// Functions for managing graph points, sorting, adding/deleting points, and curve mathematics

@init


//==============================================================================
// GRAPH DATA MANAGEMENT
//==============================================================================

function init_graph_points() (
  // Initialize points on diagonal line (1:1 compression)
  graph_points[0] = GRAPH_MIN_DB; graph_points[1] = GRAPH_MIN_DB;
  graph_points[2] = -18; graph_points[3] = -18;
  graph_points[4] = -6;  graph_points[5] = -6;
  graph_points[6] = 6;   graph_points[7] = 6;
  graph_points[8] = 18; graph_points[9] = 18;
  graph_points[10] = GRAPH_MAX_DB; graph_points[11] = GRAPH_MAX_DB;
);

function sort_points() local(i, j, temp_in, temp_out) (
  i = 1;
  while (i < num_points - 2) (
    j = i + 1;
    while (j < num_points - 1) (
      graph_points[i*2] > graph_points[j*2] ? (
        temp_in = graph_points[i*2];
        temp_out = graph_points[i*2 + 1];

        graph_points[i*2] = graph_points[j*2];
        graph_points[i*2 + 1] = graph_points[j*2 + 1];

        graph_points[j*2] = temp_in;
        graph_points[j*2 + 1] = temp_out;
      );
      j += 1;
    );
    i += 1;
  );
);

function add_point(input_db, output_db) local(insert_pos, i, new_point_index) (
  num_points >= MAX_POINTS ? -1 : (
    insert_pos = num_points - 1;

    i = num_points;
    while (i > insert_pos) (
      graph_points[i*2] = graph_points[(i-1)*2];
      graph_points[i*2 + 1] = graph_points[(i-1)*2 + 1];
      i -= 1;
    );

    graph_points[insert_pos*2] = input_db;
    graph_points[insert_pos*2 + 1] = output_db;

    num_points += 1;
    sort_points();

    // Find the new index of the added point after sorting
    new_point_index = 0;
    i = 0;
    while (i < num_points) (
      abs(graph_points[i*2] - input_db) < 0.01 && abs(graph_points[i*2 + 1] - output_db) < 0.01 ? (
        new_point_index = i;
        i = num_points; // break
      ) : (
        i += 1;
      );
    );
    new_point_index;
  );
);

function delete_point(point_index) local(i) (
  point_index <= 0 || point_index >= num_points - 1 || num_points <= MIN_POINTS ? 0 : (
    i = point_index;
    while (i < num_points - 1) (
      graph_points[i*2] = graph_points[(i+1)*2];
      graph_points[i*2 + 1] = graph_points[(i+1)*2 + 1];
      i += 1;
    );
    num_points -= 1;
    1;
  );
);

function remove_displaced_points(moved_input_db, moved_output_db) local(i, same_position_count, points_to_remove, removal_count) (
  // Count how many points are at approximately the same position as the moved point
  same_position_count = 0;
  i = 1;
  while (i < num_points - 1) (
    abs(graph_points[i*2] - moved_input_db) < 2.0 && abs(graph_points[i*2 + 1] - moved_output_db) < 2.0 ? (
      same_position_count += 1;
    );
    i += 1;
  );

  // If more than 2 points are at the same position, remove the extras
  same_position_count > 2 ? (
    points_to_remove = same_position_count - 2;
    removal_count = 0;

    // Remove points from the end backwards to avoid index shifting issues
    i = num_points - 2; // Start from last non-corner point
    while (i > 0 && removal_count < points_to_remove && num_points > MIN_POINTS) (
      abs(graph_points[i*2] - moved_input_db) < 2.0 && abs(graph_points[i*2 + 1] - moved_output_db) < 2.0 ? (
        delete_point(i);
        removal_count += 1;
        i -= 1; // Adjust index after deletion
      ) : (
        i -= 1;
      );
    );
  );
);

function find_point_at_mouse(x, y) local(i, point_x, point_y, dist_sq, found_point) (
  // Skip corner points (indices 0 and num_points-1) - they are invisible and non-interactive
  found_point = -1;
  i = 1;
  while (i < num_points - 1) (
    point_x = db_to_graph_x(graph_points[i*2]);
    point_y = db_to_graph_y(graph_points[i*2 + 1]);
    dist_sq = (x - point_x) * (x - point_x) + (y - point_y) * (y - point_y);

    dist_sq < MOUSE_CLICK_RADIUS * MOUSE_CLICK_RADIUS ? (
      found_point = i;
      i = num_points; // Break out of loop
    ) : (
      i += 1;
    );
  );
  found_point;
);


//==============================================================================
// MOUSE INTERACTION HANDLERS
//==============================================================================

function handle_point_movement() local(new_input_db, new_output_db, old_input_db) (
  // Only allow movement of non-corner points
  selected_point > 0 && selected_point < num_points - 1 ? (
    new_input_db = graph_x_to_db(mouse_x);
    new_output_db = graph_y_to_db(mouse_y);

    // Constrain to graph bounds
    new_input_db = clamp(new_input_db, GRAPH_MIN_DB, GRAPH_MAX_DB);
    new_output_db = clamp(new_output_db, GRAPH_MIN_DB, GRAPH_MAX_DB);

    // Store old position to check if significant movement occurred
    old_input_db = graph_points[selected_point*2];

    // Update point position
    graph_points[selected_point*2] = new_input_db;
    graph_points[selected_point*2 + 1] = new_output_db;

    // Re-sort points to maintain order
    sort_points();

    // Check if significant movement occurred and clean up displaced points
    abs(new_input_db - old_input_db) > 1.0 ? (
      remove_displaced_points(new_input_db, new_output_db);
    );
  );
);


function handle_point_addition() local(new_input_db, new_output_db, i, point_x, point_y, dist_sq, too_close) (
  new_input_db = clamp(graph_x_to_db(mouse_x), GRAPH_MIN_DB, GRAPH_MAX_DB);
  new_output_db = clamp(graph_y_to_db(mouse_y), GRAPH_MIN_DB, GRAPH_MAX_DB);

  // Check if too close to existing points (buffer area)
  too_close = 0;
  i = 1;
  while (i < num_points - 1 && !too_close) (
    point_x = db_to_graph_x(graph_points[i*2]);
    point_y = db_to_graph_y(graph_points[i*2 + 1]);
    dist_sq = (mouse_x - point_x) * (mouse_x - point_x) + (mouse_y - point_y) * (mouse_y - point_y);
    dist_sq < (MOUSE_CLICK_RADIUS * 2) * (MOUSE_CLICK_RADIUS * 2) ? (
      too_close = 1;
    );
    i += 1;
  );

  !too_close ? (
    add_point(new_input_db, new_output_db);
  ) : (
    -1; // Return -1 if too close to add
  );
);

function handle_point_deletion() local(point_to_delete) (
  point_to_delete = find_point_at_mouse(mouse_x, mouse_y);
  point_to_delete > 0 && point_to_delete < num_points - 1 ? (
    delete_point(point_to_delete);
  );
);

function process_mouse_input() (
  // Always update hover state first
  hovered_point = find_point_at_mouse(mouse_x, mouse_y);

  mouse_cap & 1 ? ( // Left mouse button pressed
    !mouse_down ? ( // Start of click/drag
      mouse_down = 1;

      mouse_cap & 16 ? ( // Alt+click = delete point
        handle_point_deletion();
        selected_point = -1;
      ) : (
        // Find point under mouse for selection
        selected_point = find_point_at_mouse(mouse_x, mouse_y);
        selected_point == -1 && is_point_in_graph(mouse_x, mouse_y) ? (
          // Click in empty space - add point
          selected_point = handle_point_addition();
        );
      );

      mouse_x_prev = mouse_x;
      mouse_y_prev = mouse_y;
    ) : ( // Continue drag
      selected_point >= 0 ? (
        // Normal drag = move point
        handle_point_movement();
      );

      mouse_x_prev = mouse_x;
      mouse_y_prev = mouse_y;
    );
  ) : mouse_cap & 2 ? ( // Right mouse button
    !mouse_down ? (
      mouse_down = 1;
      handle_point_deletion();
    );
  ) : (
    // Mouse button released - reset state
    mouse_down = 0;
    selected_point = -1;
  );
);