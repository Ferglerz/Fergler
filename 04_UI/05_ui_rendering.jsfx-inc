// UI Rendering Module
// Control rendering and drawing functions
// Handles the visual representation of all UI controls
// Depends on: 00a_constants.jsfx-inc, 01g_file_reading.jsfx-inc, 02d_ui_utils.jsfx-inc

@init

//==============================================================================
// MENU BUTTON RENDERING
//==============================================================================

function draw_menu_button() (
  // Check if mouse is hovering over menu button
  is_hovered = (mouse_x >= MENU_BUTTON_X && mouse_x <= MENU_BUTTON_X + MENU_BUTTON_SIZE &&
                mouse_y >= MENU_BUTTON_Y && mouse_y <= MENU_BUTTON_Y + MENU_BUTTON_SIZE);
  
  // Draw button background
  is_hovered ? (
    gfx_set(MENU_BUTTON_HOVER_R, MENU_BUTTON_HOVER_G, MENU_BUTTON_HOVER_B, 1);
  ) : (
    gfx_set(MENU_BUTTON_BG_R, MENU_BUTTON_BG_G, MENU_BUTTON_BG_B, 1);
  );
  gfx_rect(MENU_BUTTON_X, MENU_BUTTON_Y, MENU_BUTTON_SIZE, MENU_BUTTON_SIZE);
  
  // Draw button border
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_rect(MENU_BUTTON_X, MENU_BUTTON_Y, MENU_BUTTON_SIZE, MENU_BUTTON_SIZE, 0);
  
  // Draw three horizontal lines
  is_hovered ? (
    gfx_set(MENU_BUTTON_HOVER_LINE_R, MENU_BUTTON_HOVER_LINE_G, MENU_BUTTON_HOVER_LINE_B, 1);
  ) : (
    gfx_set(MENU_BUTTON_LINE_R, MENU_BUTTON_LINE_G, MENU_BUTTON_LINE_B, 1);
  );
  
  // Calculate line positions (centered in button, 75% scaled)
  line_start_x = MENU_BUTTON_X + 3;  // 4 * 0.75 = 3
  line_end_x = MENU_BUTTON_X + MENU_BUTTON_SIZE - 3;  // 4 * 0.75 = 3
  line_y1 = MENU_BUTTON_Y + 5;  // 6 * 0.75 = 4.5 rounded up
  line_y2 = line_y1 + MENU_BUTTON_LINE_SPACING;
  line_y3 = line_y2 + MENU_BUTTON_LINE_SPACING;
  
  // Draw three lines
  gfx_line(line_start_x, line_y1, line_end_x, line_y1, MENU_BUTTON_LINE_WIDTH);
  gfx_line(line_start_x, line_y2, line_end_x, line_y2, MENU_BUTTON_LINE_WIDTH);
  gfx_line(line_start_x, line_y3, line_end_x, line_y3, MENU_BUTTON_LINE_WIDTH);
);

function draw_custom_menu() (
  is_menu_visible() ? (
    menu_x = get_menu_x();
    menu_y = get_menu_y();
    menu_height = 6 * MENU_ITEM_HEIGHT;
    
    // Draw menu background
    gfx_set(MENU_BG_R, MENU_BG_G, MENU_BG_B, 1);
    gfx_rect(menu_x, menu_y, MENU_WIDTH, menu_height);
    
    // Draw menu border
    gfx_set(MENU_BORDER_R, MENU_BORDER_G, MENU_BORDER_B, 1);
    gfx_rect(menu_x, menu_y, MENU_WIDTH, menu_height, 0);
    
    // Draw menu items
    i = 0;
    while (i < 6) (
      item_y = menu_y + i * MENU_ITEM_HEIGHT;
      is_hovered = (menu_hovered_item == i);
      
      // Draw item background if hovered
      is_hovered ? (
        gfx_set(MENU_HOVER_R, MENU_HOVER_G, MENU_HOVER_B, 1);
        gfx_rect(menu_x + 1, item_y + 1, MENU_WIDTH - 2, MENU_ITEM_HEIGHT - 2);
      );
      
      // Draw item text (75% scaled)
      gfx_set(MENU_TEXT_R, MENU_TEXT_G, MENU_TEXT_B, 1);
      gfx_x = menu_x + 6;  // 8 * 0.75 = 6
      gfx_y = item_y + 6;  // 8 * 0.75 = 6
      
      i == 0 ? gfx_drawstr("Debug") :
      i == 1 ? gfx_drawstr("Histogram") :
      i == 2 ? gfx_drawstr("GR Meter") :
      i == 3 ? gfx_drawstr("Brickwall Limiter") :
      i == 4 ? gfx_drawstr("True RMS") :
      i == 5 ? gfx_drawstr("Show Compression LUT") : 0;
      
      // Draw checkmark if option is enabled
      is_enabled = (i == 0 && menu_debug_enabled > 0.5) ||
                   (i == 1 && menu_histogram_enabled > 0.5) ||
                   (i == 2 && menu_gr_meter_enabled > 0.5) ||
                   (i == 3 && menu_brickwall_limiter_enabled > 0.5) ||
                   (i == 4 && menu_true_rms_enabled > 0.5) ||
                   (i == 5 && show_compression_lut_curve > 0.5);
      
      is_enabled ? (
        gfx_set(MENU_CHECKMARK_R, MENU_CHECKMARK_G, MENU_CHECKMARK_B, 1);
        check_x = menu_x + MENU_WIDTH - 15;  // 20 * 0.75 = 15
        check_y = item_y + 6;  // 8 * 0.75 = 6
        gfx_drawstr("âœ“");
      );
      
      i += 1;
    );
  );
);

//==============================================================================
// UI PANEL RENDERING
//==============================================================================

function draw_header() (
  // Draw drop shadow first (behind header)
  gfx_set(HEADER_SHADOW_R, HEADER_SHADOW_G, HEADER_SHADOW_B, 0.5);
  gfx_rect(0, HEADER_HEIGHT, gfx_w, HEADER_SHADOW_HEIGHT);
  
  // Draw header background
  gfx_set(HEADER_BG_R, HEADER_BG_G, HEADER_BG_B, 1);
  gfx_rect(0, 0, gfx_w, HEADER_HEIGHT);
  
  // Draw cream border line below header
  gfx_set(HEADER_BORDER_R, HEADER_BORDER_G, HEADER_BORDER_B, 1);
  gfx_rect(0, HEADER_HEIGHT, gfx_w, HEADER_BORDER_HEIGHT);
  
  // Draw menu button
  draw_menu_button();
);


function draw_ui_panel_background() (
  gfx_set(UI_BG_R, UI_BG_G, UI_BG_B, 1);
  gfx_rect(UI_PANEL_X, UI_PANEL_Y, UI_PANEL_W, UI_PANEL_H);

  // Draw panel border
  gfx_set(0.5, 0.5, 0.5, 1);
  gfx_rect(UI_PANEL_X, UI_PANEL_Y, UI_PANEL_W, UI_PANEL_H, 0);
);

//==============================================================================
// GENERIC KNOB DRAWING FUNCTIONS
//==============================================================================

function draw_knob_at_position(x, y, value, min_val, max_val, knob_type) (
  // Helper function to draw a knob at a specific position with given parameters
  center_x = x + KNOB_RADIUS;
  center_y = y + KNOB_RADIUS;
  
  // Draw drop shadow first (offset down and right)
  gfx_set(KNOB_SHADOW_R, KNOB_SHADOW_G, KNOB_SHADOW_B, 0.3);
  gfx_circle(center_x + KNOB_SHADOW_OFFSET, center_y + KNOB_SHADOW_OFFSET, KNOB_RADIUS, 1);
  
  // Draw knob background
  gfx_set(KNOB_BG_R, KNOB_BG_G, KNOB_BG_B, 1);
  gfx_circle(center_x, center_y, KNOB_RADIUS, 1);
  
  // Calculate normalized value
  normalized_value = (value - min_val) / (max_val - min_val);
  normalized_value = max(0, min(1, normalized_value));
  
  knob_type == KNOB_TYPE_ANGULAR ? (
    // Angular knob - draw indicator based on angle
    current_angle = KNOB_ANGLE_START + normalized_value * KNOB_ANGLE_RANGE;
    
    // Calculate indicator position (8 pixels from center)
    indicator_distance = 8;
    indicator_x = center_x + cos(current_angle) * indicator_distance;
    indicator_y = center_y + sin(current_angle) * indicator_distance;
    
    // Draw indicator circle
    gfx_set(KNOB_INDICATOR_R, KNOB_INDICATOR_G, KNOB_INDICATOR_B, 1);
    gfx_circle(indicator_x, indicator_y, KNOB_INDICATOR_SIZE, 1);
  ) : (
    // Rotary knob - draw arc based on value
    arc_angle = normalized_value * 2 * $pi;
    gfx_set(KNOB_INDICATOR_R, KNOB_INDICATOR_G, KNOB_INDICATOR_B, 1);
    gfx_arc(center_x, center_y, KNOB_RADIUS - 2, 0, arc_angle, 1);
  );
);

function draw_knob(knob_index) (
  knob_x = get_knob_x(knob_index);
  knob_y = get_knob_y(knob_index);
  min_val = get_knob_min(knob_index);
  max_val = get_knob_max(knob_index);
  knob_type = get_knob_type(knob_index);
  param_index = get_knob_param(knob_index);
  
  // Get current value from slider, not from stored knob value
  current_value = slider(param_index);
  
  // Use the helper function to eliminate code duplication
  draw_knob_at_position(knob_x, knob_y, current_value, min_val, max_val, knob_type);
);

//==============================================================================
// LARGE KNOB DRAWING FUNCTIONS
//==============================================================================

function draw_large_knob_at_position(x, y, value, min_val, max_val, knob_type) (
  // Helper function to draw a large knob at a specific position with given parameters
  center_x = x + LARGE_KNOB_RADIUS;
  center_y = y + LARGE_KNOB_RADIUS;
  
  // Draw drop shadow first (offset down and right)
  gfx_set(LARGE_KNOB_SHADOW_R, LARGE_KNOB_SHADOW_G, LARGE_KNOB_SHADOW_B, 0.3);
  gfx_circle(center_x + 1, center_y + 1, LARGE_KNOB_RADIUS, 1);
  
  // Draw knob background (inner gray circle)
  gfx_set(LARGE_KNOB_BG_R, LARGE_KNOB_BG_G, LARGE_KNOB_BG_B, 1);
  gfx_circle(center_x, center_y, LARGE_KNOB_RADIUS, 1);
  
  // Calculate normalized value
  normalized_value = (value - min_val) / (max_val - min_val);
  normalized_value = max(0, min(1, normalized_value));
  
  // Calculate arc angles based on knob type
  knob_type == LARGE_KNOB_TYPE_LTR ? (
    start_angle = LARGE_KNOB_ANGLE_LTR_START;
    end_angle = LARGE_KNOB_ANGLE_LTR_START + normalized_value * (LARGE_KNOB_ANGLE_LTR_END - LARGE_KNOB_ANGLE_LTR_START);
    indicator_angle = end_angle;
  ) : knob_type == LARGE_KNOB_TYPE_RTL ? (
    start_angle = LARGE_KNOB_ANGLE_RTL_START;
    end_angle = LARGE_KNOB_ANGLE_RTL_START + normalized_value * (LARGE_KNOB_ANGLE_RTL_END - LARGE_KNOB_ANGLE_RTL_START);
    indicator_angle = end_angle;
  ) : ( // LARGE_KNOB_TYPE_BIDIRECTIONAL
    start_angle = LARGE_KNOB_ANGLE_BIDIR_START;
    end_angle = LARGE_KNOB_ANGLE_BIDIR_START + normalized_value * (LARGE_KNOB_ANGLE_BIDIR_END - LARGE_KNOB_ANGLE_BIDIR_START);
    indicator_angle = end_angle;
  );
  
  // Draw yellow arc from start to current value using gfx_arc()
  gfx_set(LARGE_KNOB_ARC_R, LARGE_KNOB_ARC_G, LARGE_KNOB_ARC_B, 1);
  inner_radius = LARGE_KNOB_RADIUS - LARGE_KNOB_ARC_DEPTH;
  outer_radius = LARGE_KNOB_RADIUS;
  // Draw arc as a thick ring by drawing multiple arcs at different radii
  i = 0;
  while (i <= LARGE_KNOB_ARC_DEPTH) (
    current_radius = inner_radius + i;
    gfx_arc(center_x, center_y, current_radius, start_angle, end_angle, 1);
    i += 1;
  );
  
  // Draw white indicator bar
  gfx_set(LARGE_KNOB_BAR_R, LARGE_KNOB_BAR_G, LARGE_KNOB_BAR_B, 1);
  
  // Calculate bar endpoints
  bar_inner_x = center_x + cos(indicator_angle) * inner_radius;
  bar_inner_y = center_y + sin(indicator_angle) * inner_radius;
  bar_outer_x = center_x + cos(indicator_angle) * (outer_radius + LARGE_KNOB_BAR_OVERHANG);
  bar_outer_y = center_y + sin(indicator_angle) * (outer_radius + LARGE_KNOB_BAR_OVERHANG);
  
  // Draw bar as a thick line (3 pixels wide for smaller knob)
  bar_width = 3;
  angle_perp = indicator_angle + $pi/2; // Perpendicular angle
  
  // Calculate perpendicular offset for bar width
  offset_x = cos(angle_perp) * bar_width/2;
  offset_y = sin(angle_perp) * bar_width/2;
  
  // Draw bar as a rectangle (simplified approach)
  bar_mid_x = (bar_inner_x + bar_outer_x) / 2;
  bar_mid_y = (bar_inner_y + bar_outer_y) / 2;
  bar_length = sqrt((bar_outer_x - bar_inner_x)^2 + (bar_outer_y - bar_inner_y)^2);
  
  // Draw thick line by drawing multiple parallel lines
  i = -bar_width/2;
  while (i <= bar_width/2) (
    line_x1 = bar_inner_x + offset_x * i / (bar_width/2);
    line_y1 = bar_inner_y + offset_y * i / (bar_width/2);
    line_x2 = bar_outer_x + offset_x * i / (bar_width/2);
    line_y2 = bar_outer_y + offset_y * i / (bar_width/2);
    
    gfx_line(line_x1, line_y1, line_x2, line_y2, 1);
    i += 1;
  );
);

function draw_large_knob(knob_index) (
  knob_x = get_large_knob_x(knob_index);
  knob_y = get_large_knob_y(knob_index);
  min_val = get_large_knob_min(knob_index);
  max_val = get_large_knob_max(knob_index);
  knob_type = get_large_knob_type(knob_index);
  param_index = get_large_knob_param(knob_index);
  
  // Get current value from slider, not from stored knob value
  current_value = slider(param_index);
  
  // Draw label above knob
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = knob_x;
  gfx_y = knob_y - LABEL_HEIGHT;
  gfx_drawstr(get_slider_name(param_index));
  
  // Draw the knob
  draw_large_knob_at_position(knob_x, knob_y, current_value, min_val, max_val, knob_type);
  
  // Draw value text below knob
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = knob_x + LARGE_KNOB_SIZE / 2 - 15;
  gfx_y = knob_y + LARGE_KNOB_SIZE + 5;
  gfx_printf("%.1f", current_value);
);

//==============================================================================
// INTERACTIVE COLOR HELPERS
//==============================================================================

function set_interactive_color(is_hovered, is_active, normal_r, normal_g, normal_b, highlight_r, highlight_g, highlight_b, alpha) (
  is_hovered || is_active ? (
    gfx_set(highlight_r, highlight_g, highlight_b, alpha);
  ) : (
    gfx_set(normal_r, normal_g, normal_b, alpha);
  );
);

function set_point_color(is_hovered, is_curved) (
  is_hovered ? (
    // Hovered point - larger and brighter
    is_curved ? (
      gfx_set(1, 0.8, 0.2, 1); // Orange for curved points
    ) : (
      gfx_set(1, 1, 0.5, 1); // Yellowish highlight for normal points
    );
  ) : (
    // Normal point - smaller
    is_curved ? (
      gfx_set(1, 0.6, 0.1, 0.9); // Slightly transparent orange for curved points
    ) : (
      gfx_set(1, 1, 1, 0.8); // Slightly transparent white for normal points
    );
  );
);

function set_threshold_line_color(threshold_type, is_hovered, is_dragging) (
  threshold_type == THRESHOLD_INPUT_LEVEL ? (
    is_hovered || is_dragging ? (
      gfx_set(0.3, 1, 1, 1);
    ) : (
      gfx_set(0.2, 0.8, 1, 0.8);
    );
  ) : threshold_type == THRESHOLD_INPUT_LEVEL_2 ? (
    is_hovered || is_dragging ? (
      gfx_set(1, 0.3, 1, 1);
    ) : (
      gfx_set(0.8, 0.2, 1, 0.8);
    );
  ) : threshold_type == THRESHOLD_TRANSIENT ? (
    is_hovered || is_dragging ? (
      gfx_set(1, 0.3, 0.3, 1);
    ) : (
      gfx_set(1, 0.5, 0, 0.8);
    );
  ) : threshold_type == THRESHOLD_GR_BLEND ? (
    is_hovered || is_dragging ? (
      gfx_set(1, 1, 0.3, 1);
    ) : (
      gfx_set(0.9, 0.9, 0, 0.8);
    );
  );
);

//==============================================================================
// THRESHOLD LINE DRAWING HELPERS
//==============================================================================

function draw_threshold_line_with_label(line_y, start_x, end_x, threshold_type, threshold_value, label_text, label_x, label_y) (
  // Set color based on threshold type and state
  set_threshold_line_color(threshold_type, 
    hovered_threshold_line == threshold_type, 
    dragging_threshold_line == threshold_type);
  
  // Draw line
  gfx_line(start_x, line_y, end_x, line_y, 1);
  
  // Draw label
  gfx_x = label_x;
  gfx_y = label_y;
  gfx_drawstr(label_text);
);


//==============================================================================
// GENERIC CONTROL DRAWING FUNCTIONS
//==============================================================================

function draw_generic_slider(x, y, w, h, value, min_val, max_val, label, slider_type, display_mode) (
  // Draw label
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  slider_type == 1 ? ( // Vertical slider (75% scaled)
    gfx_x = x + w + 8; gfx_y = y;  // 10 * 0.75 = 7.5 rounded up
  ) : ( // Horizontal slider
    gfx_x = x; gfx_y = y - LABEL_HEIGHT;
  );
  gfx_drawstr(label);

  // Calculate normalized position
  normalized_pos = (value - min_val) / (max_val - min_val);

  slider_type == 1 ? ( // Vertical slider
    // Draw slider background
    gfx_set(SLIDER_BG_R, SLIDER_BG_G, SLIDER_BG_B, 1);
    gfx_rect(x, y, w, h);

    // Draw slider fill from bottom
    fill_h = normalized_pos * h;
    gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
    gfx_rect(x, y + h - fill_h, w, fill_h);

    // Draw handle
    handle_y = y + h - fill_h - 3;
    gfx_set(1, 1, 1, 1);
    gfx_rect(x - 2, handle_y, w + 4, 6);

    // Draw value text (if not hidden)
    display_mode != 2 ? (
      gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
      gfx_x = x + w + 8; gfx_y = y + h/2;  // 10 * 0.75 = 7.5 rounded up
      gfx_printf("%.2f", value);
    );
  ) : slider_type == 2 ? ( // Reverse slider
    // Draw slider background
    gfx_set(SLIDER_BG_REVERSE_R, SLIDER_BG_REVERSE_G, SLIDER_BG_REVERSE_B, 1);
    gfx_rect(x, y, w, h);

    // Draw slider fill (yellow for higher values)
    fill_w = normalized_pos * w;
    gfx_set(SLIDER_FILL_REVERSE_R, SLIDER_FILL_REVERSE_G, SLIDER_FILL_REVERSE_B, 1);
    gfx_rect(x, y, fill_w, h);

    // Draw handle
    handle_x = x + fill_w - 3;
    gfx_set(1, 1, 1, 1);
    gfx_rect(handle_x, y - 2, 6, h + 4);

    // Draw value text (if not hidden)
    display_mode != 2 ? (
      gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
      display_mode == 1 ? (
        // Display to left
        gfx_x = x - 50; gfx_y = y + 3;
      ) : (
        // Display to right (default)
        gfx_x = x + w + 10; gfx_y = y + 3;
      );
      gfx_printf("%.2f", value);
    );
  ) : ( // Horizontal slider (default)
    // Draw slider background
    gfx_set(SLIDER_BG_R, SLIDER_BG_G, SLIDER_BG_B, 1);
    gfx_rect(x, y, w, h);

    // Draw slider fill
    fill_w = normalized_pos * w;
    gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
    gfx_rect(x, y, fill_w, h);

    // Draw handle
    handle_x = x + fill_w - 3;
    gfx_set(1, 1, 1, 1);
    gfx_rect(handle_x, y - 2, 6, h + 4);

    // Draw value text (if not hidden) (75% scaled)
    display_mode != 2 ? (
      gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
      display_mode == 1 ? (
        // Display to left
        gfx_x = x - 50; gfx_y = y + 2;
      ) : (
        // Display to right (default)
        gfx_x = x + w + 8; gfx_y = y + 2;
      );
      gfx_printf("%.2f", value);
    );
  );
);

function draw_generic_button(x, y, w, h, is_on, label) (
  // Draw button background
  is_on ? (
    gfx_set(BUTTON_ON_R, BUTTON_ON_G, BUTTON_ON_B, 1);
  ) : (
    gfx_set(BUTTON_OFF_R, BUTTON_OFF_G, BUTTON_OFF_B, 1);
  );
  gfx_rect(x, y, w, h);

  // Draw button border
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_rect(x, y, w, h, 0);

  // Draw button text
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x + 5; gfx_y = y + 5;
  gfx_drawstr(label);
);

function draw_generic_dropdown(x, y, w, h, current_value, label, param_index) (
  current_index = floor(current_value);
  
  // Draw label
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x; gfx_y = y - LABEL_HEIGHT;
  gfx_drawstr(label);

  // Draw dropdown background
  gfx_set(SLIDER_BG_R, SLIDER_BG_G, SLIDER_BG_B, 1);
  gfx_rect(x, y, w, h);

  // Draw dropdown border
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_rect(x, y, w, h, 0);

  // Draw current selection text
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x + 5; gfx_y = y + 5;

  // Display text using dynamic dropdown options
  get_dropdown_option_count(param_index) > 0 ? (
    // Use dynamically extracted dropdown options
    current_index < get_dropdown_option_count(param_index) ? (
      gfx_drawstr(get_dropdown_option(param_index, current_index));
    ) : (
      gfx_drawstr("Unknown");
    );
  ) : (
    // Fallback for non-dropdown parameters
    gfx_printf("%.0f", current_value);
  );

  // Draw dropdown arrow
  gfx_x = x + w - 15; gfx_y = y + 8;
  gfx_drawstr("v");
);


function draw_generic_knob(x, y, value, min_val, max_val, label) (
  // Draw label
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x; gfx_y = y - LABEL_HEIGHT;
  gfx_drawstr(label);

  // Draw the knob using the helper function
  draw_knob_at_position(x, y, value, min_val, max_val, KNOB_TYPE_ANGULAR);

  // Draw value text
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x + KNOB_SIZE + 10; gfx_y = y + 3;
  gfx_printf("%.1f", value);
);

function draw_freq_list_slider(x, y, w, h, value, min_val, max_val, label, param_index, slider_type, display_mode) (
  // Frequency list slider - looks like a slider but snaps to discrete frequency values
  // Supports both left-to-right (normal) and right-to-left (reverse) rendering
  
  // Draw label
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x; gfx_y = y - LABEL_HEIGHT;
  gfx_drawstr(label);

  // Calculate normalized position based on index
  normalized_pos = (value - min_val) / (max_val - min_val);

  // Check if this is a reverse slider (slider_type == 2)
  slider_type == 2 ? (
    // REVERSE SLIDER - grey background with yellow/ochre fill from RIGHT to fader
    gfx_set(SLIDER_BG_R, SLIDER_BG_G, SLIDER_BG_B, 1);
    gfx_rect(x, y, w, h);

    // Draw slider fill from RIGHT to fader position
    fill_w = normalized_pos * w;
    fill_start_x = x + fill_w;
    fill_width = w - fill_w;
    gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
    gfx_rect(fill_start_x, y, fill_width, h);

    // Draw handle
    handle_x = x + fill_w - 3;
    gfx_set(1, 1, 1, 1);
    gfx_rect(handle_x, y - 2, 6, h + 4);
  ) : (
    // NORMAL SLIDER - fills from left, gray background
    gfx_set(SLIDER_BG_R, SLIDER_BG_G, SLIDER_BG_B, 1);
    gfx_rect(x, y, w, h);

    // Draw slider fill
    fill_w = normalized_pos * w;
    gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
    gfx_rect(x, y, fill_w, h);

    // Draw handle
    handle_x = x + fill_w - 3;
    gfx_set(1, 1, 1, 1);
    gfx_rect(handle_x, y - 2, 6, h + 4);
  );

  // Value is the actual frequency in Hz
  freq = floor(value);
  
  // Format frequency for display
  // HP filter: 0 = Off
  // LP filter: >= 20000 = Off
  (param_index == 11 && freq == 0) || (param_index == 12 && freq >= 20000) ? (
    sprintf(#freq_display_str, "Off");
  ) : freq >= 1000 ? (
    // Display as kHz
    freq_khz = freq / 1000;
    freq_khz == floor(freq_khz) ? (
      sprintf(#freq_display_str, "%.0fk", freq_khz);
    ) : (
      sprintf(#freq_display_str, "%.1fk", freq_khz);
    );
  ) : (
    // Display as Hz
    sprintf(#freq_display_str, "%.0f", freq);
  );
  
  // Draw formatted frequency text (if not hidden)
  display_mode != 2 ? (
    gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
    display_mode == 1 ? (
      // Display to left
      gfx_x = x - 50; gfx_y = y + 2;
    ) : (
      // Display to right (default)
      gfx_x = x + w + 8; gfx_y = y + 2;
    );
    gfx_drawstr(#freq_display_str);
  );
);

//==============================================================================
// GENERIC CONTROL RENDERING
//==============================================================================

function draw_control(index) (
  type = get_control_type(index);
  x = get_control_x(index);
  y = get_control_y(index);
  w = get_control_w(index);
  h = get_control_h(index);
  param_index = get_control_param(index);
  min_val = get_control_min(index);
  max_val = get_control_max(index);
  slider_type = get_control_slider_type(index);
  display_mode = get_control_display_mode(index);
  
  // Get current parameter value
  current_value = slider(param_index);
  
  // Check if this is a stage enable button (param indices 27-31)
  is_stage_enable_button = (param_index >= 27 && param_index <= 31);
  
  // Only render stage enable buttons when debug is disabled
  is_stage_enable_button && !DEBUG_ENABLED ? (
    // Skip rendering stage enable buttons when debug is enabled
    0;
  ) : (
    type == 0 ? draw_generic_slider(x, y, w, h, current_value, min_val, max_val, get_slider_name(param_index), slider_type, display_mode) :
    type == 1 ? draw_generic_button(x, y, w, h, current_value > 0.5, get_slider_name(param_index)) :
    type == 2 ? draw_generic_dropdown(x, y, w, h, current_value, get_slider_name(param_index), param_index) :
    type == 3 ? draw_generic_knob(x, y, current_value, min_val, max_val, get_slider_name(param_index)) :
    type == 4 ? draw_freq_list_slider(x, y, w, h, current_value, min_val, max_val, get_slider_name(param_index), param_index, slider_type, display_mode) :
    0;
  );
);

//==============================================================================
// DEBUG PERFORMANCE COUNTERS RENDERING
//==============================================================================

function draw_debug_performance_counters() (
  // Spread horizontally across bottom, moved down 30px to avoid controls
  line_height = 16;
  panel_height = 155;
  gap = 15;
  
  // === PANEL 1: AUDIO PROCESSING ===
  audio_panel_x = 50;  // Hardcoded for testing
  audio_panel_y = 390; // Hardcoded for testing  
  audio_panel_w = 240;
  
  // Draw background
  gfx_set(0.1, 0.1, 0.1, 0.85);
  gfx_rect(audio_panel_x, audio_panel_y, audio_panel_w, panel_height, 1);
  
  // Draw border
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_rect(audio_panel_x, audio_panel_y, audio_panel_w, panel_height, 0);
  
  // Draw title
  gfx_set(0.5, 0.8, 1.0, 1); // Light blue
  gfx_x = audio_panel_x + 10;
  gfx_y = audio_panel_y + 8;
  gfx_drawstr("Audio Processing");
  
  // Draw audio processing functions
  gfx_set(0.9, 0.9, 0.9, 1);
  text_x = audio_panel_x + 8;
  text_y = audio_panel_y + 28;
  
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("audio_chain()");
  gfx_x = audio_panel_x + audio_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_audio_chain);
  
  text_y += line_height;
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("gain_reduction()");
  gfx_x = audio_panel_x + audio_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_gain_reduction);
  
  text_y += line_height;
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("envelope()");
  gfx_x = audio_panel_x + audio_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_envelope);
  
  text_y += line_height;
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("filters()");
  gfx_x = audio_panel_x + audio_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_filters);
  
  text_y += line_height;
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("lookahead()");
  gfx_x = audio_panel_x + audio_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_lookahead);
  
  text_y += line_height;
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("harmonics()");
  gfx_x = audio_panel_x + audio_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_harmonics);
  
  text_y += line_height;
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("limiter()");
  gfx_x = audio_panel_x + audio_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_limiter);
  
  // === PANEL 2: UI FUNCTIONS ===
  ui_panel_x = 305;  // Hardcoded for testing (50 + 240 + 15)
  ui_panel_y = 390;  // Hardcoded for testing
  ui_panel_w = 210;
  ui_panel_h = 72; // Smaller - only 2 functions
  
  // Draw background
  gfx_set(0.1, 0.1, 0.1, 0.85);
  gfx_rect(ui_panel_x, ui_panel_y, ui_panel_w, ui_panel_h, 1);
  
  // Draw border
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_rect(ui_panel_x, ui_panel_y, ui_panel_w, ui_panel_h, 0);
  
  // Draw title
  gfx_set(1.0, 0.8, 0.5, 1); // Light orange
  gfx_x = ui_panel_x + 10;
  gfx_y = ui_panel_y + 8;
  gfx_drawstr("UI Functions");
  
  // Draw UI functions
  gfx_set(0.9, 0.9, 0.9, 1);
  text_x = ui_panel_x + 8;
  text_y = ui_panel_y + 28;
  
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("curves()");
  gfx_x = ui_panel_x + ui_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_ui_curves);
  
  text_y += line_height;
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("histogram()");
  gfx_x = ui_panel_x + ui_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_ui_histogram);
  
  // === PANEL 3: MATH CONVERSIONS ===
  math_panel_x = ui_panel_x + ui_panel_w + gap;
  math_panel_y = 390;  // Same Y as others
  math_panel_w = 200;
  math_panel_h = 56; // Small - only 2 functions
  
  // Draw background
  gfx_set(0.1, 0.1, 0.1, 0.85);
  gfx_rect(math_panel_x, math_panel_y, math_panel_w, math_panel_h, 1);
  
  // Draw border
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_rect(math_panel_x, math_panel_y, math_panel_w, math_panel_h, 0);
  
  // Draw title
  gfx_set(0.5, 1.0, 0.5, 1); // Light green
  gfx_x = math_panel_x + 10;
  gfx_y = math_panel_y + 8;
  gfx_drawstr("Math Conversions");
  
  // Draw math functions
  gfx_set(0.9, 0.9, 0.9, 1);
  text_x = math_panel_x + 8;
  text_y = math_panel_y + 28;
  
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("db_to_linear()");
  gfx_x = math_panel_x + math_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_db_to_linear);
  
  text_y += line_height;
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("linear_to_db()");
  gfx_x = math_panel_x + math_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_linear_to_db);
  
  // === PANEL 4: PROGRAM RELEASE ===
  prog_panel_x = math_panel_x + math_panel_w + gap;
  prog_panel_y = 390;  // Same Y as others
  prog_panel_w = 220;
  prog_panel_h = 56; // Small - only 2 functions
  
  // Draw background
  gfx_set(0.1, 0.1, 0.1, 0.85);
  gfx_rect(prog_panel_x, prog_panel_y, prog_panel_w, prog_panel_h, 1);
  
  // Draw border
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_rect(prog_panel_x, prog_panel_y, prog_panel_w, prog_panel_h, 0);
  
  // Draw title
  gfx_set(1.0, 0.5, 1.0, 1); // Light purple/magenta
  gfx_x = prog_panel_x + 10;
  gfx_y = prog_panel_y + 8;
  gfx_drawstr("Program Release");
  
  // Draw program release functions
  gfx_set(0.9, 0.9, 0.9, 1);
  text_x = prog_panel_x + 8;
  text_y = prog_panel_y + 28;
  
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("prog_release()");
  gfx_x = prog_panel_x + prog_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_prog_release);
  
  text_y += line_height;
  gfx_x = text_x;
  gfx_y = text_y;
  gfx_drawstr("single_envelope()");
  gfx_x = prog_panel_x + prog_panel_w - 70;
  gfx_y = text_y;
  gfx_printf("%d", debug_display_single_envelope);
);

