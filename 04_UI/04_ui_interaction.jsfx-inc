// UI Interaction Module
// All mouse interaction and event handling for UI controls and graph
// Consolidated interaction handling for the entire interface
// Depends on: 00a_constants.jsfx-inc, 02d_ui_utils.jsfx-inc, 03a_graph_data.jsfx-inc, 05a_ui_threshold_lines.jsfx-inc

@init

//==============================================================================
// UI CONTROL STATES
//==============================================================================

// Control States
ui_drag_control = -1;  // -1 = no control, -2 = clicked but not draggable, >= 0 = dragging control index
ui_drag_knob = -1;     // -1 = no knob, >= 0 = dragging knob index (unified system handles both small and large)

// Mouse position tracking for delta calculations
ui_prev_mouse_x = 0;
ui_prev_mouse_y = 0;

// Graph interaction states
dragging_point = -1;
hovered_point = -1;
curve_drag_started = 0;
curve_drag_start_x = 0;
curve_drag_start_y = 0;
curve_drag_start_amount = 0;
waiting_for_mouse_release = 0; // Flag to prevent interaction after CMD release during curve drag

//==============================================================================
// MENU BUTTON INTERACTION
//==============================================================================

function is_menu_button_clicked() (
  mouse_x >= MENU_BUTTON_X && mouse_x <= MENU_BUTTON_X + MENU_BUTTON_SIZE &&
  mouse_y >= MENU_BUTTON_Y && mouse_y <= MENU_BUTTON_Y + MENU_BUTTON_SIZE
);

function handle_menu_button_click() (
  // Toggle menu visibility
  menu_visible = menu_visible > 0.5 ? 0 : 1;
  menu_hovered_item = -1; // Reset hover state
);

function is_menu_visible() (
  menu_visible > 0.5
);

function get_menu_x() (
  MENU_BUTTON_X
);

function get_menu_y() (
  MENU_BUTTON_Y + MENU_BUTTON_SIZE + 5
);

function get_menu_item_y(item_index) (
  get_menu_y() + item_index * MENU_ITEM_HEIGHT
);

function is_mouse_in_menu() (
  menu_x = get_menu_x();
  menu_y = get_menu_y();
  menu_visible > 0.5 && 
  mouse_x >= menu_x && mouse_x <= menu_x + MENU_WIDTH &&
  mouse_y >= menu_y && mouse_y <= menu_y + (6 * MENU_ITEM_HEIGHT)
);

function get_hovered_menu_item() (
  is_mouse_in_menu() ? (
    menu_x = get_menu_x();
    menu_y = get_menu_y();
    item_index = floor((mouse_y - menu_y) / MENU_ITEM_HEIGHT);
    item_index >= 0 && item_index < 6 ? item_index : -1;
  ) : (
    -1
  );
);

function handle_menu_item_click(item_index) (
  item_index == 0 ? (
    // Toggle debug
    menu_debug_enabled = menu_debug_enabled > 0.5 ? 0 : 1;
    DEBUG_ENABLED = menu_debug_enabled;
  ) : item_index == 1 ? (
    // Toggle histogram
    menu_histogram_enabled = menu_histogram_enabled > 0.5 ? 0 : 1;
  ) : item_index == 2 ? (
    // Toggle GR meter
    menu_gr_meter_enabled = menu_gr_meter_enabled > 0.5 ? 0 : 1;
  ) : item_index == 3 ? (
    // Toggle brickwall limiter (slider26)
    menu_brickwall_limiter_enabled = menu_brickwall_limiter_enabled > 0.5 ? 0 : 1;
    brickwall_limiter = menu_brickwall_limiter_enabled;
    sliderchange(1 << (26 - 1)); // Update slider26
  ) : item_index == 4 ? (
    // Toggle True RMS mode
    menu_true_rms_enabled = menu_true_rms_enabled > 0.5 ? 0 : 1;
    // Clear both RMS states when switching modes
    clear_rms_state();
    rms_smoothed_squared = 0;
  ) : item_index == 5 ? (
    // Toggle Compression LUT visualization
    show_compression_lut_curve = show_compression_lut_curve > 0.5 ? 0 : 1;
  );
  
  // Close menu after selection
  menu_visible = 0;
  menu_hovered_item = -1;
);

//==============================================================================
// GENERIC KNOB INTERACTION
//==============================================================================

function find_clicked_knob() (
  // Check all active knobs to see if mouse is over one (unified system handles both small and large)
  found_knob = -1;
  i = 0;
  while (i < NUM_KNOBS && found_knob == -1) (
    get_knob_active(i) && is_point_in_knob(mouse_x, mouse_y, i) ? (
      found_knob = i; // Found it!
    );
    i += 1;
  );
  found_knob; // Return found knob index or -1
);

//==============================================================================
// GENERIC UI CONTROL INTERACTION
//==============================================================================

function handle_ui_mouse_input() (
  MOUSE_LEFT_BUTTON ? (
    ui_drag_control == -1 ? ( // Start of click - no control selected yet
      // Initialize previous mouse position on first click
      ui_prev_mouse_x = mouse_x;
      ui_prev_mouse_y = mouse_y;
      
      // Check knobs first (unified system handles both small and large)
      clicked_knob = find_clicked_knob();
      clicked_knob >= 0 ? (
        ui_drag_knob = clicked_knob; // Store which knob is being dragged
        ui_drag_control = -2; // Mark as dragging (prevents re-checking on next frame)
        // Don't update on first click - just lock the knob
      ) : is_menu_button_clicked() ? (
          handle_menu_button_click();
          ui_drag_control = -2; // Special value to prevent further checks
        ) : is_menu_visible() ? (
          // Check menu items if menu is visible
          hovered_item = get_hovered_menu_item();
          hovered_item >= 0 ? (
            handle_menu_item_click(hovered_item);
            ui_drag_control = -2; // Special value to prevent further checks
          ) : (
            // Clicked outside menu - close it
            menu_visible = 0;
            menu_hovered_item = -1;
          );
        ) : (
        // Check controls until we find one under the mouse
        i = 0;
        while (i < NUM_CONTROLS && ui_drag_control == -1) (
          is_point_in_control(mouse_x, mouse_y, i) ? (
            control_type = get_control_type(i);
            param_index = get_control_param(i);
            current_value = slider(param_index);
            
            control_type == 0 ? (
              // Slider - start drag
              ui_drag_control = i;
              slider(param_index) = update_slider_value(i, mouse_x, mouse_y);
              sliderchange(1 << (param_index - 1));
              
              // Immediate PDC update for lookahead slider (slider5)
              param_index == 5 ? (
                pdc_delay = min(slider(5) * 0.001 * srate, max_lookahead_samples) | 0;
                pdc_delay > 0 ? (
                  pdc_bot_ch = 0;
                  pdc_top_ch = 2;
                );
              );
            ) : control_type == 4 ? (
              // Freq list slider - discrete value slider (snaps to integer steps)
              ui_drag_control = i;
              new_value = update_slider_value(i, mouse_x, mouse_y);
              // Round to nearest integer for discrete steps
              slider(param_index) = floor(new_value + 0.5);
              sliderchange(1 << (param_index - 1));
            ) : control_type == 3 ? (
              // Small knob (control type 3) - start drag
              ui_drag_control = i;
              // Don't update on first click - just lock the control
            ) : control_type == 1 ? (
              // Button - toggle (don't start drag for buttons)
              slider(param_index) = current_value > 0.5 ? 0 : 1;
              sliderchange(1 << (param_index - 1));
              ui_drag_control = -2; // Special value to prevent further checks
            ) : control_type == 2 ? (
              // Dropdown - cycle (don't start drag for dropdowns)
              max_options = get_dropdown_option_count(param_index);
              slider(param_index) = (current_value + 1) % max_options;
              sliderchange(1 << (param_index - 1));
              ui_drag_control = -2; // Special value to prevent further checks
            );
          );
          i += 1;
        );
      );
      );
    ) : ( // Continue drag
      ui_drag_control >= 0 ? (
        // Update dragged control
        param_index = get_control_param(ui_drag_control);
        control_type = get_control_type(ui_drag_control);
        
        control_type == 3 ? (
          // Small knob (control type 3) - use delta tracking
          min_val = get_control_min(ui_drag_control);
          max_val = get_control_max(ui_drag_control);
          current_value = slider(param_index);
          mouse_dy = mouse_y - ui_prev_mouse_y;
          new_value = update_value_from_mouse_delta(current_value, min_val, max_val, mouse_dy, KNOB_SENSITIVITY);
          slider(param_index) = new_value;
          sliderchange(1 << (param_index - 1));
        ) : (
          // Sliders (types 0 and 4) - use position tracking
          new_value = update_slider_value(ui_drag_control, mouse_x, mouse_y);
          
          // Round to integer for freq_list_slider (type 4)
          control_type == 4 ? (
            slider(param_index) = floor(new_value + 0.5);
          ) : (
            slider(param_index) = new_value;
          );
          sliderchange(1 << (param_index - 1));
          
          // Immediate PDC update for lookahead slider (slider5)
          param_index == 5 ? (
            pdc_delay = min(slider(5) * 0.001 * srate, max_lookahead_samples) | 0;
            pdc_delay > 0 ? (
              pdc_bot_ch = 0;
              pdc_top_ch = 2;
            );
          );
        );
      ) : ui_drag_knob >= 0 ? (
        // Update knob (unified system handles both small and large)
        update_knob_value_from_mouse(ui_drag_knob, mouse_x, mouse_y);
      ) : (
        // No drag operation in progress
      );
    );
  ) : (
    // Mouse released - reset drag state
    ui_drag_control = -1;
    ui_drag_knob = -1;
  );
);

//==============================================================================
// GRAPH INTERACTION FUNCTIONS
//==============================================================================

function handle_point_movement() (
  // Only allow movement of non-corner points
  dragging_point > 0 && dragging_point < num_points - 1 ? (
    // Convert mouse position to dB values
    new_input_db = graph_x_to_db(mouse_x);
    new_output_db = graph_y_to_db(mouse_y);

    // Constrain to graph bounds
    new_input_db = clamp(new_input_db, GRAPH_MIN_DB, GRAPH_MAX_DB);
    new_output_db = clamp(new_output_db, GRAPH_MIN_DB, GRAPH_MAX_DB);

    // Store old position to check if significant movement occurred
    old_input_db = graph_points[dragging_point*2];

    // Update point position
    graph_points[dragging_point*2] = new_input_db;
    graph_points[dragging_point*2 + 1] = new_output_db;

    // Re-sort points to maintain order
    sort_points();

    // Check if significant movement occurred and clean up displaced points
    abs(new_input_db - old_input_db) > 1.0 ? (
      remove_displaced_points(new_input_db, new_output_db);
    );
    
    // Invalidate both caches since point movement affects curves and compression
    invalidate_curve_cache();
    invalidate_compression_lut();
    invalidate_compression_threshold();
  );
);

function handle_curve_adjustment() (
  // Only allow curve adjustment of non-corner points
  dragging_point > 0 && dragging_point < num_points - 1 ? (
    // Initialize curve drag on first call
    !curve_drag_started ? (
      curve_drag_started = 1;
      curve_drag_start_x = mouse_x;
      curve_drag_start_y = mouse_y;
      curve_drag_start_amount = get_curve_amount(dragging_point);
    );
    
    // Calculate horizontal drag distance (right = increase, left = decrease)
    dx = mouse_x - curve_drag_start_x;
    max_drag_distance = 100; // Maximum drag distance for 100% curve
    
    // Calculate new curve amount based on horizontal movement
    // Right movement increases curve, left movement decreases curve
    drag_factor = dx / max_drag_distance;
    new_curve_amount = curve_drag_start_amount + (drag_factor * 100);
    new_curve_amount = clamp(new_curve_amount, 0, 100);
    
    // Set the curve amount for this point and invalidate both caches for real-time updates
    set_curve_amount(dragging_point, new_curve_amount);
    invalidate_curve_cache();
    invalidate_compression_lut();
    invalidate_compression_threshold();
  );
);

function handle_point_addition() (
  new_input_db = clamp(graph_x_to_db(mouse_x), GRAPH_MIN_DB, GRAPH_MAX_DB);
  new_output_db = clamp(graph_y_to_db(mouse_y), GRAPH_MIN_DB, GRAPH_MAX_DB);

  // Check if too close to existing points (buffer area)
  too_close = 0;
  i = 1;
  while (i < num_points - 1 && !too_close) (
    point_x = db_to_graph_x(graph_points[i*2]);
    point_y = db_to_graph_y(graph_points[i*2 + 1]);
    dist_sq = (mouse_x - point_x) * (mouse_x - point_x) + (mouse_y - point_y) * (mouse_y - point_y);
    dist_sq < (MOUSE_CLICK_RADIUS * 2) * (MOUSE_CLICK_RADIUS * 2) ? (
      too_close = 1;
    );
    i += 1;
  );

  !too_close ? (
    new_point_index = add_point(new_input_db, new_output_db);
    // Invalidate both caches since point addition affects curves and compression
    invalidate_curve_cache();
    invalidate_compression_lut();
    invalidate_compression_threshold();
    new_point_index; // Return the index of the newly added point
  ) : (
    -1; // Return -1 if too close to add
  );
);

function handle_point_deletion() (
  // Delete point at mouse position (middle-click or ctrl+click)
  target_point = find_point_at_mouse(mouse_x, mouse_y);
  
  target_point >= 0 && num_points > 2 ? ( // Keep at least 2 points
    delete_point(target_point);
    // Invalidate both caches since point deletion affects curves and compression
    invalidate_curve_cache();
    invalidate_compression_lut();
    invalidate_compression_threshold();
  );
);

//==============================================================================
// MAIN MOUSE INPUT PROCESSING
//==============================================================================

function process_mouse_input() (
  // Update menu hover state
  is_menu_visible() ? (
    menu_hovered_item = get_hovered_menu_item();
  );

  // Handle custom UI controls first (they have priority)
  handle_ui_mouse_input();

  // Handle threshold line interactions second (before graph interactions)
  handle_threshold_line_mouse();

  // Only process graph mouse input if not interacting with UI controls, knobs, or threshold lines
  ui_drag_control == -1 && ui_drag_knob == -1 && dragging_threshold_line == -1 ? (
    // Always update hover state first
    hovered_point = find_point_at_mouse(mouse_x, mouse_y);

    MOUSE_LEFT_BUTTON ? ( // Left mouse button pressed
      // Skip all interaction if waiting for mouse release
      !waiting_for_mouse_release ? (
        !mouse_down ? ( // Start of click/drag
          mouse_down = 1;

          MOUSE_ALT_KEY ? ( // Alt+click = delete point
            handle_point_deletion();
            dragging_point = -1;
          ) : (
            // Find point under mouse for selection
            dragging_point = find_point_at_mouse(mouse_x, mouse_y);
            dragging_point == -1 && is_point_in_graph(mouse_x, mouse_y) && hovered_threshold_line == -1 ? (
              // Click in empty space - add point (only if not hovering over threshold line)
              dragging_point = handle_point_addition();
            );
          );

          mouse_x_prev = mouse_x;
          mouse_y_prev = mouse_y;
        ) : ( // Continue drag
          dragging_point >= 0 ? (
            MOUSE_CTRL_KEY ? ( // Cmd+drag = adjust curve
              handle_curve_adjustment();
            ) : (
              // CMD released mid-drag: if we were adjusting curve, revert and cancel drag
              curve_drag_started ? (
                // Revert curve to starting amount
                set_curve_amount(dragging_point, curve_drag_start_amount);
                // Reset all drag states and wait for mouse release
                curve_drag_started = 0;
                mouse_down = 0;
                dragging_point = -1;
                waiting_for_mouse_release = 1; // Block further interaction until mouse up
              ) : (
                // Normal drag = move point
                handle_point_movement();
              );
            );
          );

          mouse_x_prev = mouse_x;
          mouse_y_prev = mouse_y;
        );
      );
    ) : MOUSE_RIGHT_BUTTON ? ( // Right mouse button
      !mouse_down ? (
        mouse_down = 1;
        handle_point_deletion();
      );
    ) : (
      // Mouse button released - reset all states
      mouse_down = 0;
      dragging_point = -1;
      curve_drag_started = 0;
      waiting_for_mouse_release = 0; // Clear the waiting flag
    );
  );
  
  // Update previous mouse position for next frame's delta calculation
  ui_prev_mouse_x = mouse_x;
  ui_prev_mouse_y = mouse_y;
);
