// DSP Utilities Module
// Digital Signal Processing utility functions (lookahead, limiting)
// Filter coefficient calculations moved to 04c_filters.jsfx-inc
// Depends on: 00b_math_utils.jsfx-inc (for tanh)

@init

//==============================================================================
// LOOKAHEAD AND LIMITER STATE INITIALIZATION
//==============================================================================

function init_lookahead_limiter_state() (
  // Audio processing state
  lookahead_pos = 0;

  // Limiter state variables
  limiter_prev_l = 0;
  limiter_prev_r = 0;
);

//==============================================================================
// LOOKAHEAD PARAMETER UPDATES
//==============================================================================

function update_lookahead_samples() (
  // Convert lookahead time from milliseconds to samples
  // Clamp to maximum allocated buffer size to prevent buffer overflow
  lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);
);

//==============================================================================
// LOOKAHEAD PROCESSING  
//==============================================================================

// Delay audio through circular buffer (Cockos approach)
// Returns delayed audio, caller applies CURRENT gain to delayed audio
function process_lookahead_audio(input_l, input_r) (
  lookahead_samples > 0 ? (
    // Store current audio samples
    lookahead_buffer_l[lookahead_pos] = input_l;
    lookahead_buffer_r[lookahead_pos] = input_r;
    
    // OPTIMIZED: Use bit masking instead of modulo (faster for power-of-2 buffer sizes)
    // Read delayed audio: (pos - delay + size) & mask is equivalent to % but much faster
    delayed_pos = (lookahead_pos - lookahead_samples + max_lookahead_samples) & lookahead_mask;
    lookahead_out_l = lookahead_buffer_l[delayed_pos];
    lookahead_out_r = lookahead_buffer_r[delayed_pos];
    
    // Advance position with bit mask
    lookahead_pos = (lookahead_pos + 1) & lookahead_mask;
  ) : (
    // No lookahead - pass through
    lookahead_out_l = input_l;
    lookahead_out_r = input_r;
  );
);

//==============================================================================
// SOFT CLIPPING AND LIMITING
//==============================================================================

function soft_clip_limiter(input, prev_sample) (
  abs_input = abs(input);
  abs_prev = abs(prev_sample);
  
  // Only check for inter-sample peaks when signal is -0.5dB or higher (0.944)
  // This avoids unnecessary oversampling for lower-level signals
  (abs_input > 0.944 || abs_prev > 0.944) ? (
    // 2x oversampling for inter-sample peak detection
    oversample1 = abs((input + prev_sample) * 0.5);
    peak_detected = max(oversample1, abs_input) > 0.95;
    
    peak_detected ? (
      // Soft clipping using tanh with pre-calculated normalization constant
      limited = tanh(input * LIMITER_SCALE) * LIMITER_TANH_NORM;
    ) : (
      limited = input;
    );
  ) : (
    // Below -0.5dB: pass through without processing
    limited = input;
  );

  limited
);
