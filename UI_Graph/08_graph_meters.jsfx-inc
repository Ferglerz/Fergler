// UI Graph Meters Module
// Gain reduction meter and histogram visualization
// Depends on: 
//   - UI_General/00_ui_constants.jsfx-inc
//   - UI_General/01_drawing_primitives.jsfx-inc (for set_threshold_line_color)
//   - UI_General/12_coordinate_conversion.jsfx-inc (for DB_TO_PIXEL_SCALE, GR_PIXELS_PER_DB, HISTOGRAM_Y_OFFSET, get_meter_x, get_meter_y, get_meter_w, get_meter_h)
//   - UI_General/11_threshold_lines.jsfx-inc (for render_gr_blend_threshold_line, THRESHOLD_GR_BLEND, hovered_threshold_line, dragging_threshold_line)

@init

//==============================================================================
// PROCESSING STATE INDICATOR
//==============================================================================

function draw_processing_state_indicator() (
  // Position to the right of the GR meter
  indicator_x = GRAPH_X + GRAPH_SIZE + 15 + 23 + 8;  // meter_x + meter_w + spacing
  indicator_y = GRAPH_Y + GRAPH_SIZE / 2;  // Centered vertically with meter
  indicator_radius = 5;
  
  // Draw background circle (dark gray)
  gfx_set(0.15, 0.15, 0.15, 1);
  gfx_circle(indicator_x, indicator_y, indicator_radius + 1, 1, 1);  // Filled with 1px border
  
  // Draw state indicator
  // Red when processing is skipped (early exit), Green when actively processing
  gr_processing_skipped ? (
    // Red - early exit (no compression happening)
    gfx_set(0.8, 0.2, 0.2, 1);
  ) : (
    // Green - actively compressing
    gfx_set(0.2, 0.8, 0.3, 1);
  );
  gfx_circle(indicator_x, indicator_y, indicator_radius, 1, 1);  // Filled circle
);

//==============================================================================
// GAIN REDUCTION METER
//==============================================================================

function draw_gain_reduction_meter() local(gr_meter_x, gr_meter_y, gr_meter_w, gr_meter_h) (
  menu_gr_meter_enabled ? (
    // Use shared meter position calculation functions
    gr_meter_x = get_meter_x();
    gr_meter_y = get_meter_y();
    gr_meter_w = get_meter_w();
    gr_meter_h = get_meter_h();
    meter_center_y = gr_meter_y + gr_meter_h / 2;

    // Draw meter background
    gfx_set(0.2, 0.2, 0.2, 1);
    gfx_rect(gr_meter_x, gr_meter_y, gr_meter_w, gr_meter_h);

  // Draw center line (0dB)
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_line(gr_meter_x, meter_center_y, gr_meter_x + gr_meter_w, meter_center_y, 1); // Antialiased

  // Check if audio is active (playback state 1 = playing, 5 = recording)
  is_audio_active = (play_state == 1) || (play_state == 5);

  // Only show meter when audio is active
  is_audio_active ? (
    current_gr_db < 0 ? (
      // Gain reduction (negative) - render from top down in orange/red
      // Optimized: use pre-calculated GR_PIXELS_PER_DB constant
      gr_height = abs(current_gr_db) * GR_PIXELS_PER_DB;
      gr_height = min(gr_height, gr_meter_h); // Clamp to full meter
      gfx_set(1, 0.5, 0, 1); // Orange color for reduction
      gfx_rect(gr_meter_x, gr_meter_y, gr_meter_w, gr_height);
    ) : current_gr_db > 0 ? (
      // Gain boost (positive) - render from bottom up in blue
      // Optimized: use pre-calculated GR_PIXELS_PER_DB constant
      gr_height = current_gr_db * GR_PIXELS_PER_DB;
      gr_height = min(gr_height, gr_meter_h); // Clamp to full meter
      gfx_set(0.2, 0.5, 1, 1); // Blue color for boost
      gfx_rect(gr_meter_x, gr_meter_y + gr_meter_h - gr_height, gr_meter_w, gr_height);
    );
  );
  
  // Draw GR blend threshold line if visible (using threshold_lines service)
  render_gr_blend_threshold_line(gr_meter_x, gr_meter_y, gr_meter_w, gr_meter_h);
  );
);

//==============================================================================
// HISTOGRAM HELPERS
//==============================================================================

// Draw input histogram line (specialized version)
// Optimized to use pre-calculated constants for dB-to-pixel conversion
function draw_input_histogram_line(buffer, buffer_pos, max_samples, r, g, b, a) (
  samples_span = max_samples;
  width_pixels = GRAPH_SIZE;
  step_size = max(1, floor(width_pixels / 200));
  
  gfx_set(r, g, b, a);
  first_point = 1;
  i = 0;
  
  while (i < width_pixels) (
    age = floor((width_pixels - 1 - i) * (samples_span - 1) / (width_pixels - 1));
    sample_idx = (buffer_pos - 1 - age + samples_span) % samples_span;
    level_db = buffer[sample_idx];
    
    // Only draw if above minimum
    level_db > GRAPH_MIN_DB ? (
      x_pos = GRAPH_X + i;
      // Convert dB to graph Y coordinate (optimized: eliminates division)
      y_pos = HISTOGRAM_Y_OFFSET - level_db * DB_TO_PIXEL_SCALE;
      
      first_point ? (
        gfx_x = x_pos;
        gfx_y = y_pos;
        first_point = 0;
      ) : (
        gfx_lineto(x_pos, y_pos, 1);
      );
    ) : (
      first_point = 1;
    );
    
    i += step_size;
  );
);

// Draw GR histogram line for negative values (reduction) - per-pixel buffer mode
// Optimized to use pre-calculated GR_PIXELS_PER_DB constant
// Reads from newest (right) to oldest (left), matching input histogram behavior
function draw_gr_histogram_neg_line_pixel(buffer, r, g, b, a) (
  gfx_set(r, g, b, a);
  first_point = 1;
  i = 0;
  
  // Map buffer samples to graph pixels (buffer may be larger than graph width)
  width_pixels = GRAPH_SIZE;
  buffer_size = histogram_pixel_max_samples;
  
  while (i < width_pixels) (
    // Calculate buffer index: newest pixel is at histogram_pixel_idx, oldest is (idx - buffer_size + 1)
    // For pixel i (0=left, width_pixels-1=right), age = floor((width_pixels - 1 - i) * (buffer_size - 1) / (width_pixels - 1))
    // This matches the input histogram calculation for consistent scrolling
    age = floor((width_pixels - 1 - i) * (buffer_size - 1) / max(width_pixels - 1, 1));
    buffer_idx = (histogram_pixel_idx - age + buffer_size) % buffer_size;
    gr_value = buffer[buffer_idx];
    
    // Only draw negative values (reduction)
    gr_value < 0 ? (
      x_pos = GRAPH_X + i;
      // Convert GR to graph Y coordinate (from top)
      gr_height = abs(gr_value) * GR_PIXELS_PER_DB;
      y_pos = GRAPH_Y + gr_height;
      
      first_point ? (
        gfx_x = x_pos;
        gfx_y = y_pos;
        first_point = 0;
      ) : (
        gfx_lineto(x_pos, y_pos, 1);
      );
    ) : (
      first_point = 1;
    );
    
    i += 1;
  );
);

// Draw GR histogram line for negative values (reduction) - original mode
// Optimized to use pre-calculated GR_PIXELS_PER_DB constant
function draw_gr_histogram_neg_line(buffer, buffer_pos, max_samples, r, g, b, a) (
  samples_span = max_samples;
  width_pixels = GRAPH_SIZE;
  step_size = max(1, floor(width_pixels / 200));
  
  gfx_set(r, g, b, a);
  first_point = 1;
  i = 0;
  
  while (i < width_pixels) (
    age = floor((width_pixels - 1 - i) * (samples_span - 1) / (width_pixels - 1));
    sample_idx = (buffer_pos - 1 - age + samples_span) % samples_span;
    gr_value = buffer[sample_idx];
    
    // Only draw negative values (reduction)
    gr_value < 0 ? (
      x_pos = GRAPH_X + i;
      // Convert GR to graph Y coordinate (from top)
      gr_height = abs(gr_value) * GR_PIXELS_PER_DB;
      y_pos = GRAPH_Y + gr_height;
      
      first_point ? (
        gfx_x = x_pos;
        gfx_y = y_pos;
        first_point = 0;
      ) : (
        gfx_lineto(x_pos, y_pos, 1);
      );
    ) : (
      first_point = 1;
    );
    
    i += step_size;
  );
);

// Draw GR histogram line for positive values (boost) - per-pixel buffer mode
// Optimized to use pre-calculated GR_PIXELS_PER_DB constant
// Reads from newest (right) to oldest (left), matching input histogram behavior
function draw_gr_histogram_pos_line_pixel(buffer, r, g, b, a) (
  gfx_set(r, g, b, a);
  first_point = 1;
  i = 0;
  
  // Map buffer samples to graph pixels (buffer may be larger than graph width)
  width_pixels = GRAPH_SIZE;
  buffer_size = histogram_pixel_max_samples;
  
  while (i < width_pixels) (
    // Calculate buffer index: newest pixel is at histogram_pixel_idx, oldest is (idx - buffer_size + 1)
    // For pixel i (0=left, width_pixels-1=right), age = floor((width_pixels - 1 - i) * (buffer_size - 1) / (width_pixels - 1))
    // This matches the input histogram calculation for consistent scrolling
    age = floor((width_pixels - 1 - i) * (buffer_size - 1) / max(width_pixels - 1, 1));
    buffer_idx = (histogram_pixel_idx - age + buffer_size) % buffer_size;
    gr_value = buffer[buffer_idx];
    
    // Only draw positive values (boost)
    gr_value > 0 ? (
      x_pos = GRAPH_X + i;
      // Convert GR to graph Y coordinate (from bottom)
      gr_height = abs(gr_value) * GR_PIXELS_PER_DB;
      y_pos = GRAPH_Y + GRAPH_SIZE - gr_height;
      
      first_point ? (
        gfx_x = x_pos;
        gfx_y = y_pos;
        first_point = 0;
      ) : (
        gfx_lineto(x_pos, y_pos, 1);
      );
    ) : (
      first_point = 1;
    );
    
    i += 1;
  );
);

// Draw GR histogram line for positive values (boost) - original mode
// Optimized to use pre-calculated GR_PIXELS_PER_DB constant
function draw_gr_histogram_pos_line(buffer, buffer_pos, max_samples, r, g, b, a) (
  samples_span = max_samples;
  width_pixels = GRAPH_SIZE;
  step_size = max(1, floor(width_pixels / 200));
  
  gfx_set(r, g, b, a);
  first_point = 1;
  i = 0;
  
  while (i < width_pixels) (
    age = floor((width_pixels - 1 - i) * (samples_span - 1) / (width_pixels - 1));
    sample_idx = (buffer_pos - 1 - age + samples_span) % samples_span;
    gr_value = buffer[sample_idx];
    
    // Only draw positive values (boost)
    gr_value > 0 ? (
      x_pos = GRAPH_X + i;
      // Convert GR to graph Y coordinate (from bottom)
      gr_height = abs(gr_value) * GR_PIXELS_PER_DB;
      y_pos = GRAPH_Y + GRAPH_SIZE - gr_height;
      
      first_point ? (
        gfx_x = x_pos;
        gfx_y = y_pos;
        first_point = 0;
      ) : (
        gfx_lineto(x_pos, y_pos, 1);
      );
    ) : (
      first_point = 1;
    );
    
    i += step_size;
  );
);

//==============================================================================
// INPUT HISTOGRAM
//==============================================================================

function draw_input_histogram() (
  INPUT_HISTOGRAM_ENABLED && input_histogram_initialized && menu_histogram_enabled ? (
    // Draw input level as a continuous line using dB to graph coordinate conversion
    // Color: Green, using same coordinate system as the red dot indicator
    draw_input_histogram_line(
      input_histogram_buffer,
      input_histogram_pos,
      input_histogram_max_samples,
      INPUT_HISTOGRAM_COLOR_R,
      INPUT_HISTOGRAM_COLOR_G,
      INPUT_HISTOGRAM_COLOR_B,
      INPUT_HISTOGRAM_OPACITY
    );
  );
);

//==============================================================================
// HISTOGRAM
//==============================================================================

function draw_histogram() (
  HISTOGRAM_ENABLED && menu_histogram_enabled ? (
    menu_histogram_buffer_mode > 0.5 ? (
      // PER-PIXEL BUFFER MODE: Draw directly from pixel buffer
      histogram_pixel_initialized ? (
        // Draw negative (reduction) line (orange, from top)
        draw_gr_histogram_neg_line_pixel(
          histogram_pixel_buffer,
          1, 0.5, 0, // Orange
          HISTOGRAM_OPACITY
        );
        
        // Draw positive (addition) line (blue, from bottom)
        draw_gr_histogram_pos_line_pixel(
          histogram_pixel_buffer,
          0.2, 0.5, 1, // Blue
          HISTOGRAM_OPACITY
        );
      );
    ) : (
      // ORIGINAL MODE: Draw negative (reduction) and positive (addition) GR as separate lines
      histogram_initialized ? (
        // Draw negative (reduction) line (orange, from top)
        draw_gr_histogram_neg_line(
          histogram_buffer,
          histogram_pos,
          histogram_max_samples,
          1, 0.5, 0, // Orange
          HISTOGRAM_OPACITY
        );
        
        // Draw positive (addition) line (blue, from bottom)
        draw_gr_histogram_pos_line(
          histogram_buffer,
          histogram_pos,
          histogram_max_samples,
          0.2, 0.5, 1, // Blue
          HISTOGRAM_OPACITY
        );
      );
    );
  );
);

