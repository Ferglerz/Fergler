// UI Utilities Module
// Pure UI utility functions and coordinate conversions
// Contains control accessor functions and basic UI utilities
//
// Dependencies:
// - 01_Utils/01_constants.jsfx-inc (for GRAPH_* and UI constants)
// - 01_Utils/04_file_reading.jsfx-inc (for get_slider_name function)
// - 04_UI_Rendering/00_ui_constants.jsfx-inc (for UI constants)
// - 01_Utils/05_memory.jsfx-inc (for control_defs array)

@init

//==============================================================================
// BASIC UI UTILITIES
//==============================================================================

function is_point_in_control(x, y, control_index) local(group_idx) (
  ctrl_x = control_defs[control_index*11 + 1];
  ctrl_y = control_defs[control_index*11 + 2];
  ctrl_w = control_defs[control_index*11 + 3];
  ctrl_h = control_defs[control_index*11 + 4];
  group_idx = control_defs[control_index*11 + 10];

  // Add group offset if control is in a group
  group_idx >= 0 ? (
    ctrl_x += group_defs[group_idx*6 + 0];
    ctrl_y += group_defs[group_idx*6 + 1];
  );
  
  x >= ctrl_x && x <= ctrl_x + ctrl_w && y >= ctrl_y && y <= ctrl_y + ctrl_h;
);


function update_slider_value(control_index, mouse_x, mouse_y) local(group_idx, control_type, param_index, option_count, option_index, i, opt_value, reverse_mode, ctrl_x_rel, ctrl_x_abs, group_x_val, slider_orientation, format_options, array_index) (
  slider_config = control_defs[control_index*11 + 8];
  slider_orientation = slider_config & 0xFF;  // Extract slider orientation from config
  format_options = (slider_config >> 32) & 0xFF;  // Extract format options
  min_val = control_defs[control_index*11 + 6];
  max_val = control_defs[control_index*11 + 7];
  group_idx = control_defs[control_index*11 + 10];
  control_type = control_defs[control_index*11 + 0];
  param_index = control_defs[control_index*11 + 5];

  slider_orientation == ORIENTATION_VERTICAL ? ( // Vertical slider
    ctrl_y = control_defs[control_index*11 + 2];
    ctrl_h = control_defs[control_index*11 + 4];

    // Add group offset if control is in a group
    group_idx >= 0 ? (
      ctrl_y += group_defs[group_idx*6 + 1];
    );

    normalized_pos = (mouse_y - ctrl_y) / ctrl_h;
    normalized_pos = max(0, min(1, normalized_pos));
    // Invert for vertical slider (0 at top, 1 at bottom)
    normalized_pos = 1 - normalized_pos;
  ) : ( // Horizontal slider (normal or reverse)
    ctrl_x_rel = control_defs[control_index*11 + 1];
    ctrl_w = control_defs[control_index*11 + 3];

    // Add group offset if control is in a group
    group_idx >= 0 ? (
      group_x_val = group_defs[group_idx*6 + 0];
      ctrl_x = ctrl_x_rel + group_x_val;
    ) : (
      ctrl_x = ctrl_x_rel;
    );
    
    normalized_pos = (mouse_x - ctrl_x) / ctrl_w;
    normalized_pos = max(0, min(1, normalized_pos));
    
    // Handle reverse sliders - invert the normalized position
    format_options & OPTION_REVERSE ? (
      normalized_pos = 1.0 - normalized_pos;
    );
  );
  
  // For freq_list_slider (type 4), map position to enumerated values
  control_type == 4 ? (
    // Get the number of enumerated options
    option_count = get_dropdown_option_count(param_index);
    
    option_count > 0 ? (
      // Check if this is a reverse slider
      reverse_mode = (format_options & OPTION_REVERSE);
      
      // Map normalized position (0.0 to 1.0) to option index (0 to option_count-1)
      // Use (option_count - 1) to ensure even distribution across all options
      reverse_mode ? (
        // For reverse sliders, left = last option, right = first option
        option_index = floor((1 - normalized_pos) * (option_count - 1) + 0.5);
      ) : (
        // For normal sliders, left = first option, right = last option
        option_index = floor(normalized_pos * (option_count - 1) + 0.5);
      );
      
      // Clamp to valid range (safety check)
      option_index = max(0, min(option_count - 1, option_index));
      
      // Get the pre-parsed numeric value at this index (fast, no string conversion)
      // This returns ONLY values from our cached enumerated list
      get_dropdown_option_value(param_index, option_index);
    ) : (
      // Fallback: no enumerated options, use continuous range
      min_val + normalized_pos * (max_val - min_val);
    );
  ) : (
    // For normal sliders, use continuous range with increment snapping
    raw_value = min_val + normalized_pos * (max_val - min_val);
    // Inline get_slider_increment: slider_properties_base[control_index * 4 + 0]
    array_index = control_index * 4 + 0;
    increment = (array_index >= 0 && array_index < NUM_CONTROLS * 4) ? slider_properties_base[array_index] : 0;
    increment > 0 ? (
      // Snap to nearest increment step
      floor(raw_value / increment + 0.5) * increment
    ) : (
      raw_value
    );
  );
);

// Shared function to update value from mouse delta
function update_value_from_mouse_delta(current_value, min_val, max_val, mouse_dy, sensitivity, param_index) local(array_index) (
  // Vertical mouse movement controls value (down = increase, up = decrease)
  value_range = max_val - min_val;
  delta = -mouse_dy * sensitivity * value_range / 100; // Negative because down = increase
  
  new_value = current_value + delta;
  new_value = max(min_val, min(max_val, new_value));
  
  // Apply increment snapping - inline get_slider_increment
  // Get slider increment from file_reading module (uses slider_num, 1-indexed)
  increment = get_slider_increment(param_index);
  increment > 0 ? (
    // Snap to nearest increment step
    floor(new_value / increment + 0.5) * increment
  ) : (
    new_value
  );
);

//==============================================================================
// SLIDER PROPERTIES SYSTEM
//==============================================================================

// Set slider property for a control
function set_slider_property(control_index, property_index, value) (
  array_index = control_index * 4 + property_index;
  array_index >= 0 && array_index < NUM_CONTROLS * 4 ? (
    slider_properties_base[array_index] = value;
  );
);

// Convenience functions for common properties
function set_slider_increment(control_index, increment) (
  set_slider_property(control_index, 0, increment);
);

//==============================================================================
// COORDINATE CLAMPING HELPERS
//==============================================================================

// Note: Graph coordinate conversion functions (db_to_graph_x, db_to_graph_y, etc.)
// are now defined in 03_Compression/02_graph_data_core.jsfx-inc where they belong


function clamp_x_to_graph(x) (
  max(GRAPH_X, min(GRAPH_X + GRAPH_SIZE, x))
);

function clamp_y_to_graph(y) (
  max(GRAPH_Y, min(GRAPH_Y + GRAPH_SIZE, y))
);

//==============================================================================
// DRAWING HELPERS
//==============================================================================

function draw_indicator_circle(x, y, radius, r, g, b, alpha, filled) (
  gfx_set(r, g, b, alpha);
  gfx_circle(x, y, radius, filled, 1); 
);

// Draw formatted text at position with color
function draw_text_at(r, g, b, a, x, y, format_str, value) (
  gfx_set(r, g, b, a);
  gfx_x = x;
  gfx_y = y;
  gfx_printf(format_str, value);
);

//==============================================================================
// DISPLAY FORMATTING FUNCTIONS
//==============================================================================

// Calculate decimal places based on increment
function get_decimal_places(increment) (
  increment <= 0 ? 2 : (
    increment >= 1 ? 0 : (
      increment >= 0.1 ? 1 : (
        increment >= 0.01 ? 2 : 3
      )
    )
  )
);

// Format value with appropriate decimal places and suffix
function format_value_with_suffix(value, increment, display_mode) local(decimal_places, format_str) (
  decimal_places = get_decimal_places(increment);
  
  display_mode == DISPLAY_PERCENT ? (
    sprintf(#temp_display_str, "%%.%df %%", decimal_places, value);
  ) : display_mode == DISPLAY_DB ? (
    sprintf(#temp_display_str, "%%.%df dB", decimal_places, value);
  ) : display_mode == DISPLAY_MS ? (
    sprintf(#temp_display_str, "%%.%df ms", decimal_places, value);
  ) : display_mode == DISPLAY_HZ ? (
    sprintf(#temp_display_str, "%%.%df Hz", decimal_places, value);
  ) : (
    sprintf(#temp_display_str, "%%.%df", decimal_places, value);
  );
  
  temp_display_str;
);

