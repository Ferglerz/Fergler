// UI Rendering - Controls Module
// Generic control rendering (sliders, buttons, dropdowns) and dispatcher
// Dependencies: 01_Utils/01_constants.jsfx-inc, 01_Utils/04_file_reading.jsfx-inc, 04_UI/01_ui_constants.jsfx-inc

@init

//==============================================================================
// STREAMLINED SLIDER SYSTEM
//==============================================================================
//
// The streamlined slider system provides a single function call to create sliders
// with configurable behavior. All slider types (horizontal, vertical, reverse)
// are handled by the same unified function with different configuration parameters.
//
// USAGE EXAMPLES:
//
// 1. Basic slider with ms suffix:
//    config = create_horizontal_slider(DISPLAY_MS, FILL_LEFT_TO_RIGHT, FORMAT_NORMAL, 0);
//    define_slider(index, x, y, w, h, param, min, max, "Label", config);
//
// 2. Frequency slider with k suffix and custom fill direction:
//    config = create_horizontal_slider(DISPLAY_HZ, FILL_RIGHT_TO_LEFT, FORMAT_K, 0);
//    define_slider(index, x, y, w, h, param, min, max, "Label", config);
//
// 3. Slider with rounded number formatting (2.1k style):
//    config = create_horizontal_slider(DISPLAY_NORMAL, FILL_LEFT_TO_RIGHT, FORMAT_K, OPTION_ROUNDED);
//    define_slider(index, x, y, w, h, param, min, max, "Label", config);
//
// 4. Slider with hidden value display:
//    config = create_horizontal_slider(DISPLAY_HIDE_VALUE, FILL_LEFT_TO_RIGHT, FORMAT_NORMAL, 0);
//    define_slider(index, x, y, w, h, param, min, max, "Label", config);
//
// 5. Small knob with dB display:
//    config = create_knob_small(DISPLAY_DB, FORMAT_NORMAL, 0);
//    define_slider(index, x, y, w, h, param, min, max, "Label", config);
//
// 6. Vertical slider with percent display:
//    config = create_vertical_slider(DISPLAY_PERCENT, FILL_LEFT_TO_RIGHT, FORMAT_NORMAL, 0);
//    define_slider(index, x, y, w, h, param, min, max, "Label", config);
//
// AUTOMATIC FEATURES:
// - Stepped behavior automatically applies to sliders with enumerated options
// - Number formatting (2.1k instead of 2000) is configurable for any slider
// - Fill direction is a parameter for all sliders
// - Smart text positioning (left/right anchored based on slider position)
// - Support for all display modes (ms, dB, %, etc.)
//
// CONFIGURATION FUNCTIONS:
// - create_horizontal_slider(display_mode, fill_direction, formatting, format_options)
// - create_vertical_slider(display_mode, fill_direction, formatting, format_options)
// - create_reverse_horizontal_slider(display_mode, fill_direction, formatting, format_options)
// - create_reverse_vertical_slider(display_mode, fill_direction, formatting, format_options)
// - create_knob_small(display_mode, formatting, format_options)
// - create_knob_large(display_mode, formatting, format_options)
// - create_reverse_knob_small(display_mode, formatting, format_options)
// - create_reverse_knob_large(display_mode, formatting, format_options)
//
// DISPLAY MODES: DISPLAY_NORMAL, DISPLAY_PERCENT, DISPLAY_DB, DISPLAY_MS, DISPLAY_HZ, DISPLAY_HIDE_VALUE
// FILL DIRECTIONS: FILL_LEFT_TO_RIGHT, FILL_RIGHT_TO_LEFT, FILL_CENTER_OUT
// FORMATTING: FORMAT_NORMAL, FORMAT_K, FORMAT_NONE
// FORMAT OPTIONS: OPTION_ROUNDED, OPTION_AUTO_STEP, OPTION_BIDIRECTIONAL, OPTION_REVERSE
//

// Get dynamic display mode for time controls
function get_time_display_mode(param_index, display_mode) local(
  time_unit
) (
  // Check if this is the Attack control that should use dynamic units
  param_index == 1 ? ( // Attack only
    time_unit = slider(33); // Time Unit selector (param 33)
    time_unit == 0 ? DISPLAY_MS : ( // ms
      time_unit == 1 ? DISPLAY_US : ( // us
        time_unit == 2 ? DISPLAY_S : display_mode // s, or fallback to original
      )
    );
  ) : (
    display_mode; // Not Attack control, use original display mode
  );
);

// Value formatting function
function format_slider_value(param_index, value, display_mode, formatting, format_options) local(
  decimal_places, formatted_str, freq_khz, dynamic_display_mode
) (
  // Calculate decimal places from slider increment
  increment = get_slider_increment(param_index);
  decimal_places = increment >= 1 ? 0 : (increment >= 0.1 ? 1 : (increment >= 0.01 ? 2 : 3));
  
  // Always round value to its increment
  rounded_value = floor(value / increment + 0.5) * increment;
  
  // Apply formatting based on mutually exclusive formatting parameter
  formatting == FORMAT_K ? ( // Format with k suffix (2.1k style)
    rounded_value >= 1000 ? (
      sprintf(#temp_display_str, "%.1fk", rounded_value / 1000);
    ) : rounded_value >= 100 ? (
      sprintf(#temp_display_str, "%.0f", rounded_value);
    ) : (
      sprintf(#temp_display_str, "%%.%df", decimal_places);
      sprintf(#temp_display_str, #temp_display_str, rounded_value);
    );
  ) : formatting == FORMAT_NONE ? ( // No formatting (display raw value)
    sprintf(#temp_display_str, "%g", rounded_value);
  ) : ( // Default formatting (FORMAT_NORMAL)
    sprintf(#temp_display_str, "%%.%df", decimal_places);
    sprintf(#temp_display_str, #temp_display_str, rounded_value);
  );
  
  // Apply additional format options (like rounding)
  format_options & OPTION_ROUNDED ? (
    // Apply additional rounding if requested
    sprintf(#temp_display_str, "%%.%df", decimal_places);
    sprintf(#temp_display_str, #temp_display_str, value);
  );
  
  // Get dynamic display mode for time controls
  dynamic_display_mode = get_time_display_mode(param_index, display_mode);
  
  // Add suffix based on display mode
  dynamic_display_mode == DISPLAY_PERCENT ? (
    sprintf(#temp_display_str, "%s %%", #temp_display_str)
  ) : dynamic_display_mode == DISPLAY_DB ? (
    sprintf(#temp_display_str, "%s dB", #temp_display_str)
  ) : dynamic_display_mode == DISPLAY_MS ? (
    sprintf(#temp_display_str, "%s ms", #temp_display_str)
  ) : dynamic_display_mode == DISPLAY_US ? (
    sprintf(#temp_display_str, "%s us", #temp_display_str)
  ) : dynamic_display_mode == DISPLAY_S ? (
    sprintf(#temp_display_str, "%s s", #temp_display_str)
  ) : dynamic_display_mode == DISPLAY_HZ ? (
    // Handle Hz display mode with special logic for k suffix
    value == 0 ? (
      sprintf(#temp_display_str, "Off");
    ) : value > 999 ? (
      // Display as kHz (for values over 999)
      freq_khz = value / 1000;
      freq_khz == floor(freq_khz) ? (
        sprintf(#temp_display_str, "%.0fk", freq_khz);
      ) : (
        sprintf(#temp_display_str, "%.1fk", freq_khz);
      );
    ) : (
      // Display as Hz
      sprintf(#temp_display_str, "%.0f Hz", value);
    );
  ) : (
    0; // Satisfy syntax requirement
  );
  
  #temp_display_str; // Return formatted string
);

//==============================================================================
// ENHANCED KNOB RENDERING FUNCTIONS
//==============================================================================
// NOTE: These functions must be defined BEFORE draw_slider because draw_slider calls them

// Enhanced small knob rendering with different knob types
function draw_knob_at_position(x, y, value, min_val, max_val, knob_type) (
  // Helper function to draw a knob at a specific position with given parameters
  center_x = x + KNOB_RADIUS;
  center_y = y + KNOB_RADIUS;

  // Draw drop shadow first (offset down and right)
  gfx_set(KNOB_SHADOW_R, KNOB_SHADOW_G, KNOB_SHADOW_B, 0.3);
  gfx_circle(center_x + KNOB_SHADOW_OFFSET, center_y + KNOB_SHADOW_OFFSET, KNOB_RADIUS, 1);

  // Draw knob background
  gfx_set(KNOB_BG_R, KNOB_BG_G, KNOB_BG_B, 1);
  gfx_circle(center_x, center_y, KNOB_RADIUS, 1);

  // Calculate normalized value
  normalized_value = (value - min_val) / (max_val - min_val);
  normalized_value = max(0, min(1, normalized_value));

  knob_type == KNOB_TYPE_ANGULAR ? (
    // Angular knob - draw indicator based on angle
    current_angle = KNOB_ANGLE_START + normalized_value * KNOB_ANGLE_RANGE;

    // Calculate indicator position (8 pixels from center)
    indicator_distance = 8;
    indicator_x = center_x + cos(current_angle) * indicator_distance;
    indicator_y = center_y + sin(current_angle) * indicator_distance;

    // Draw indicator circle
    gfx_set(KNOB_INDICATOR_R, KNOB_INDICATOR_G, KNOB_INDICATOR_B, 1);
    gfx_circle(indicator_x, indicator_y, KNOB_INDICATOR_SIZE, 1);
  ) : (
    // Rotary knob - draw arc based on value
    arc_angle = normalized_value * 2 * $pi;
    gfx_set(KNOB_INDICATOR_R, KNOB_INDICATOR_G, KNOB_INDICATOR_B, 1);
    gfx_arc(center_x, center_y, KNOB_RADIUS - 2, 0, arc_angle, 1);
  );
);

// Enhanced large knob rendering with different knob types
function draw_large_knob_at_position(x, y, value, min_val, max_val, knob_type) (
  // Helper function to draw a large knob at a specific position with given parameters
  center_x = x + LARGE_KNOB_RADIUS;
  center_y = y + LARGE_KNOB_RADIUS;

  // Draw drop shadow first (offset down and right)
  gfx_set(LARGE_KNOB_SHADOW_R, LARGE_KNOB_SHADOW_G, LARGE_KNOB_SHADOW_B, 0.3);
  gfx_circle(center_x + 1, center_y + 1, LARGE_KNOB_RADIUS, 1);

  // Draw knob background (inner gray circle)
  gfx_set(LARGE_KNOB_BG_R, LARGE_KNOB_BG_G, LARGE_KNOB_BG_B, 1);
  gfx_circle(center_x, center_y, LARGE_KNOB_RADIUS, 1);

  // Calculate normalized value
  normalized_value = (value - min_val) / (max_val - min_val);
  normalized_value = max(0, min(1, normalized_value));

  // Calculate arc angles based on knob type
  knob_type == LARGE_KNOB_TYPE_LTR ? (
    start_angle = LARGE_KNOB_ANGLE_LTR_START;
    end_angle = LARGE_KNOB_ANGLE_LTR_START + normalized_value * (LARGE_KNOB_ANGLE_LTR_END - LARGE_KNOB_ANGLE_LTR_START);
    indicator_angle = end_angle;
  ) : knob_type == LARGE_KNOB_TYPE_RTL ? (
    start_angle = LARGE_KNOB_ANGLE_RTL_START;
    end_angle = LARGE_KNOB_ANGLE_RTL_START + normalized_value * (LARGE_KNOB_ANGLE_RTL_END - LARGE_KNOB_ANGLE_RTL_START);
    indicator_angle = end_angle;
  ) : ( // LARGE_KNOB_TYPE_BIDIRECTIONAL
    start_angle = LARGE_KNOB_ANGLE_BIDIR_START;
    end_angle = LARGE_KNOB_ANGLE_BIDIR_START + normalized_value * (LARGE_KNOB_ANGLE_BIDIR_END - LARGE_KNOB_ANGLE_BIDIR_START);
    indicator_angle = end_angle;
  );

  // Draw yellow arc from start to current value using gfx_arc()
  gfx_set(LARGE_KNOB_ARC_R, LARGE_KNOB_ARC_G, LARGE_KNOB_ARC_B, 1);
  inner_radius = LARGE_KNOB_RADIUS - LARGE_KNOB_ARC_DEPTH;
  outer_radius = LARGE_KNOB_RADIUS;
  // Draw arc as a thick ring by drawing multiple arcs at different radii
  i = 0;
  while (i <= LARGE_KNOB_ARC_DEPTH) (
    current_radius = inner_radius + i;
    gfx_arc(center_x, center_y, current_radius, start_angle, end_angle, 1);
    i += 1;
  );

  // Draw white indicator bar
  gfx_set(LARGE_KNOB_BAR_R, LARGE_KNOB_BAR_G, LARGE_KNOB_BAR_B, 1);

  // Calculate bar endpoints
  bar_inner_x = center_x + cos(indicator_angle) * inner_radius;
  bar_inner_y = center_y + sin(indicator_angle) * inner_radius;
  bar_outer_x = center_x + cos(indicator_angle) * (outer_radius + LARGE_KNOB_BAR_OVERHANG);
  bar_outer_y = center_y + sin(indicator_angle) * (outer_radius + LARGE_KNOB_BAR_OVERHANG);

  // Draw bar as a thick line (3 pixels wide for smaller knob)
  bar_width = 3;
  angle_perp = indicator_angle + $pi/2; // Perpendicular angle

  // Calculate perpendicular offset for bar width
  offset_x = cos(angle_perp) * bar_width/2;
  offset_y = sin(angle_perp) * bar_width/2;

  // Draw bar as a rectangle (simplified approach)
  bar_mid_x = (bar_inner_x + bar_outer_x) / 2;
  bar_mid_y = (bar_inner_y + bar_outer_y) / 2;
  bar_length = sqrt((bar_outer_x - bar_inner_x)^2 + (bar_outer_y - bar_inner_y)^2);

  // Draw thick line by drawing multiple parallel lines
  i = -bar_width/2;
  while (i <= bar_width/2) (
    line_x1 = bar_inner_x + offset_x * i / (bar_width/2);
    line_y1 = bar_inner_y + offset_y * i / (bar_width/2);
    line_x2 = bar_outer_x + offset_x * i / (bar_width/2);
    line_y2 = bar_outer_y + offset_y * i / (bar_width/2);

    gfx_line(line_x1, line_y1, line_x2, line_y2, 1);
    i += 1;
  );
);

// Generic knob rendering function for backward compatibility
function draw_generic_knob(x, y, value, min_val, max_val, label) (
  // Draw label
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x; gfx_y = y - LABEL_HEIGHT;
  gfx_drawstr(label);

  // Draw the knob using the helper function
  draw_knob_at_position(x, y, value, min_val, max_val, KNOB_TYPE_ANGULAR);

  // Draw value text
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x + KNOB_SIZE + 10; gfx_y = y + 3;
  gfx_printf("%.1f", value);
);

//==============================================================================
// SLIDER RENDERING
//==============================================================================

// Slider function that handles all slider types with configurable behavior
function draw_slider(x, y, w, h, value, min_val, max_val, label, param_index, slider_config) local(
  label_w, label_h, value_str_w, value_str_h, fill_direction, formatted_str, 
  normalized_pos, fill_w, handle_x, handle_y, center_x, fader_x, fill_start_x, fill_width,
  decimal_places, dynamic_display_mode, option_count, value_index, freq_value,
  reverse_mode, step_size, stepped_value, display_value, slider_orientation, knob_size,
  knob_center_x, knob_center_y, knob_radius, knob_angle, knob_indicator_x, knob_indicator_y, formatting
) (
  // Extract configuration parameters
  slider_orientation = slider_config & 0xFF;             // Bits 0-7: slider orientation (0=horizontal, 1=vertical, 2=small knob, 3=large knob)
  display_mode = (slider_config >> 8) & 0xFF;           // Bits 8-15: display mode
  fill_direction = (slider_config >> 16) & 0xFF;        // Bits 16-23: fill direction
  formatting = (slider_config >> 24) & 0xFF;            // Bits 24-31: formatting (0=normal, 1=k, 2=none)
  format_options = (slider_config >> 32) & 0xFF;        // Bits 32-39: format options (rounded, auto-step, bidirectional, reverse)
  
  // Check if this slider has enumerated options (stepped behavior)
  option_count = get_dropdown_option_count(param_index);
  
  // Calculate stepped value if slider has enumerated options
  option_count > 0 ? (
    // Get the index from our cached reverse lookup table (O(1) lookup)
    value_index = get_freq_list_index(param_index, value);
    
    // Get the actual discrete value from our cached enumerated list
    stepped_value = get_dropdown_option_value(param_index, value_index);
    
    // Calculate normalized position based on index in enumerated list
    reverse_mode = (format_options & OPTION_REVERSE);
    reverse_mode ? (
      // For reverse sliders, first option is at right (1.0), last option is at left (0.0)
      normalized_pos = 1.0 - (value_index / (option_count - 1));
    ) : (
      // For normal sliders, first option is at left (0.0), last option is at right (1.0)
      normalized_pos = value_index / (option_count - 1);
    );
    
    // Use stepped value for display
    display_value = stepped_value;
  ) : (
    // No enumerated options, use continuous range
    normalized_pos = (value - min_val) / (max_val - min_val);
    display_value = value;
  );
  
  // Draw label - center aligned for horizontal sliders and knobs
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  slider_orientation == ORIENTATION_VERTICAL ? ( // Vertical slider
    gfx_x = x + w + 8; gfx_y = y;
  ) : slider_orientation == ORIENTATION_KNOB_SMALL || slider_orientation == ORIENTATION_KNOB_LARGE ? ( // Knob style
    gfx_x = x; gfx_y = y - LABEL_HEIGHT;
  ) : ( // Horizontal slider - center align
    gfx_measurestr(label, label_w, label_h);
    gfx_x = x + (w - label_w) / 2;
    gfx_y = y - LABEL_HEIGHT;
  );
  gfx_drawstr(label);

  slider_orientation == ORIENTATION_KNOB_SMALL || slider_orientation == ORIENTATION_KNOB_LARGE ? ( // Knob style
    // Use enhanced knob rendering functions
    slider_orientation == ORIENTATION_KNOB_LARGE ? (
      // Large knob - use enhanced large knob rendering
      draw_large_knob_at_position(x, y, display_value, min_val, max_val, LARGE_KNOB_TYPE_LTR);
    ) : (
      // Small knob - use enhanced small knob rendering
      draw_knob_at_position(x, y, display_value, min_val, max_val, KNOB_TYPE_ANGULAR);
    );
    
    // Draw value text (if not hidden)
    display_mode != DISPLAY_HIDE_VALUE ? (
      gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
      knob_size = slider_orientation == ORIENTATION_KNOB_LARGE ? LARGE_KNOB_SIZE : KNOB_SIZE;
      gfx_x = x; gfx_y = y + knob_size + 5;
      
      // Format the value with appropriate decimal places and formatting
      formatted_str = format_slider_value(param_index, display_value, display_mode, formatting, format_options);
      gfx_drawstr(formatted_str);
    );
  ) : slider_orientation == ORIENTATION_VERTICAL ? ( // Vertical slider
    // Draw slider background
    gfx_set(SLIDER_BG_R, SLIDER_BG_G, SLIDER_BG_B, 1);
    gfx_rect(x, y, w, h);

    // Draw slider fill from bottom
    fill_h = normalized_pos * h;
    gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
    gfx_rect(x, y + h - fill_h, w, fill_h);

    // Draw handle
    handle_y = y + h - fill_h - 3;
    gfx_set(1, 1, 1, 1);
    gfx_rect(x - 2, handle_y, w + 4, 6);

    // Draw value text (if not hidden)
    display_mode != DISPLAY_HIDE_VALUE ? (
      gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
      gfx_x = x + w + 8; gfx_y = y + h/2;
      
      // Format the value with appropriate decimal places and formatting
      formatted_str = format_slider_value(param_index, display_value, display_mode, formatting, format_options);
      gfx_drawstr(formatted_str);
    );
  ) : ( // Horizontal slider (includes normal and reverse styles)
    // Draw slider background
    gfx_set(SLIDER_BG_R, SLIDER_BG_G, SLIDER_BG_B, 1);
    gfx_rect(x, y, w, h);

    // Draw slider fill based on fill direction
    fill_w = normalized_pos * w;

    fill_direction == FILL_LEFT_TO_RIGHT ? (
      // Fill from LEFT edge to fader position
      gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
      gfx_rect(x, y, fill_w, h);
    ) : fill_direction == FILL_CENTER_OUT ? (
      // Fill from center to fader position (both directions)
      center_x = x + w * 0.5;
      fader_x = x + fill_w;

      // Fill left side (from center to fader if fader is right of center)
      fader_x > center_x ? (
        gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
        gfx_rect(center_x, y, fader_x - center_x, h);
      );

      // Fill right side (from center to fader if fader is left of center)
      fader_x < center_x ? (
        gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
        gfx_rect(fader_x, y, center_x - fader_x, h);
      );
    ) : (
      // Default (RIGHT_TO_LEFT): Fill from RIGHT edge to fader position
      fill_start_x = x + fill_w;
      fill_width = w - fill_w;
      gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
      gfx_rect(fill_start_x, y, fill_width, h);
    );

    // Draw handle
    handle_x = x + fill_w - 3;
    gfx_set(1, 1, 1, 1);
    gfx_rect(handle_x, y - 2, 6, h + 4);

    // Draw value text (if not hidden)
    display_mode != DISPLAY_HIDE_VALUE ? (
      // Format the value with appropriate decimal places and formatting
      formatted_str = format_slider_value(param_index, display_value, display_mode, formatting, format_options);
      gfx_measurestr(formatted_str, value_str_w, value_str_h);
      
      // Smart positioning: left-anchored when >50%, right-anchored when <50%
      normalized_pos > 0.5 ? (
        // >50%: Anchor left, black text
        gfx_set(0, 0, 0, 1);  // Black
        gfx_x = x + 3;
      ) : (
        // <50%: Anchor right, white text
        gfx_set(1, 1, 1, 1);  // White
        gfx_x = x + w - value_str_w - 3;
      );
      gfx_y = y + (h - value_str_h) / 2;  // Center vertically
      gfx_drawstr(formatted_str);
    );
  );
);

//==============================================================================
// BUTTON RENDERING
//==============================================================================

function draw_generic_button(x, y, w, h, is_on, label) (
  // Draw button background
  is_on ? (
    gfx_set(BUTTON_ON_R, BUTTON_ON_G, BUTTON_ON_B, 1);
  ) : (
    gfx_set(BUTTON_OFF_R, BUTTON_OFF_G, BUTTON_OFF_B, 1);
  );
  gfx_rect(x, y, w, h);

  // Draw button border
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_rect(x, y, w, h, 0);

  // Draw button text
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x + 5; gfx_y = y + 5;
  gfx_drawstr(label);
);

//==============================================================================
// DROPDOWN RENDERING
//==============================================================================

function draw_generic_dropdown(x, y, w, h, current_value, label, param_index) (
  current_index = floor(current_value);
  
  // Draw label
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x; gfx_y = y - LABEL_HEIGHT;
  gfx_drawstr(label);

  // Draw dropdown background
  gfx_set(SLIDER_BG_R, SLIDER_BG_G, SLIDER_BG_B, 1);
  gfx_rect(x, y, w, h);

  // Draw dropdown border
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_rect(x, y, w, h, 0);

  // Draw current selection text
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x + 5; gfx_y = y + 5;

  // Display text using dynamic dropdown options
  get_dropdown_option_count(param_index) > 0 ? (
    // Use dynamically extracted dropdown options
    current_index < get_dropdown_option_count(param_index) ? (
      gfx_drawstr(get_dropdown_option(param_index, current_index));
    ) : (
      gfx_drawstr("Unknown");
    );
  ) : (
    // Fallback for non-dropdown parameters
    gfx_printf("%.0f", current_value);
  );

  // Draw dropdown arrow
  gfx_x = x + w - 15; gfx_y = y + 8;
  gfx_drawstr("v");
);

//==============================================================================
// GENERIC CONTROL DISPATCHER
//==============================================================================

function draw_control(index) local(group_idx) (
  type = control_defs[index*11 + 0];
  x = control_defs[index*11 + 1];
  y = control_defs[index*11 + 2];
  w = control_defs[index*11 + 3];
  h = control_defs[index*11 + 4];
  param_index = control_defs[index*11 + 5];
  min_val = control_defs[index*11 + 6];
  max_val = control_defs[index*11 + 7];
  group_idx = control_defs[index*11 + 10];

  // Add group offset if control is in a group
  group_idx >= 0 ? (
    x += group_defs[group_idx*6 + 0];
    y += group_defs[group_idx*6 + 1];
  );

  // Get current parameter value
  current_value = slider(param_index);

  // Handle different control types
  type == 0 ? ( // Slider - use unified system (includes knob-style sliders)
    slider_config = control_defs[index*11 + 8];
    draw_slider(x, y, w, h, current_value, min_val, max_val, get_slider_name(param_index), param_index, slider_config);
  ) : type == 1 ? ( // Button
    draw_generic_button(x, y, w, h, current_value > 0.5, get_slider_name(param_index));
  ) : type == 2 ? ( // Dropdown
    draw_generic_dropdown(x, y, w, h, current_value, get_slider_name(param_index), param_index);
  ) : (
    0; // Unknown control type
  );
);

