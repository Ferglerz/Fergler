// UI Rendering - Controls Module
// Generic control rendering (sliders, buttons, dropdowns) and dispatcher
// Dependencies: 01_Utils/01_constants.jsfx-inc, 01_Utils/04_file_reading.jsfx-inc, 04_UI/01_ui_constants.jsfx-inc

@init

//==============================================================================
// STREAMLINED SLIDER SYSTEM
//==============================================================================
//
// The streamlined slider system provides a single function call to create sliders
// with configurable behavior. All slider types (horizontal, vertical, reverse)
// are handled by the same unified function with different configuration parameters.
//
// USAGE EXAMPLES:
//
// 1. Basic slider with ms suffix:
//    define_unified_slider(index, x, y, w, h, param, min, max, "Label", SLIDER_CONFIG_MS);
//
// 2. Frequency slider with k suffix and custom fill direction:
//    config = create_slider_config(0, DISPLAY_MODE_NORMAL, SLIDER_FILL_RIGHT_TO_LEFT, FORMAT_OPTION_FREQUENCY);
//    define_unified_slider(index, x, y, w, h, param, min, max, "Label", config);
//
// 3. Slider with rounded number formatting (2.1k style):
//    define_unified_slider(index, x, y, w, h, param, min, max, "Label", SLIDER_CONFIG_ROUNDED);
//
// 4. Slider with hidden value display:
//    define_unified_slider(index, x, y, w, h, param, min, max, "Label", SLIDER_CONFIG_HIDE_VALUE);
//
// AUTOMATIC FEATURES:
// - Stepped behavior automatically applies to sliders with enumerated options
// - Number formatting (2.1k instead of 2000) is configurable for any slider
// - Fill direction is a parameter for all sliders
// - Smart text positioning (left/right anchored based on slider position)
// - Support for all display modes (ms, dB, %, etc.)
//
// CONFIGURATION CONSTANTS:
// - SLIDER_CONFIG_NORMAL: Basic horizontal slider
// - SLIDER_CONFIG_REVERSE: Reverse horizontal slider (right-to-left fill)
// - SLIDER_CONFIG_VERTICAL: Vertical slider
// - SLIDER_CONFIG_FREQUENCY: Frequency formatting (k suffix)
// - SLIDER_CONFIG_ROUNDED: Rounded number formatting (2.1k style)
// - SLIDER_CONFIG_HIDE_VALUE: Hide value display
// - SLIDER_CONFIG_PERCENT: Percent suffix
// - SLIDER_CONFIG_DB: dB suffix
// - SLIDER_CONFIG_MS: ms suffix
//

// Get dynamic display mode for time controls
function get_time_display_mode(param_index, display_mode) local(
  time_unit
) (
  // Check if this is a time control that should use dynamic units
  param_index == 1 || param_index == 3 || param_index == 5 || param_index == 6 ? ( // Attack, Release, Lookahead, RMS Window
    time_unit = slider(33); // Time Unit selector (param 33)
    time_unit == 0 ? DISPLAY_MODE_MS : ( // ms
      time_unit == 1 ? DISPLAY_MODE_US : ( // us
        time_unit == 2 ? DISPLAY_MODE_S : display_mode // s, or fallback to original
      )
    );
  ) : (
    display_mode; // Not a time control, use original display mode
  );
);

// Unified value formatting function
function format_slider_value_unified(param_index, value, display_mode, formatting, format_options) local(
  decimal_places, formatted_str, freq_khz, dynamic_display_mode
) (
  // Calculate decimal places from slider increment
  increment = get_slider_increment(param_index);
  decimal_places = increment >= 1 ? 0 : (increment >= 0.1 ? 1 : (increment >= 0.01 ? 2 : 3));
  
  // Always round value to its increment
  rounded_value = floor(value / increment + 0.5) * increment;
  
  // Apply formatting based on mutually exclusive formatting parameter
  formatting == FORMAT_K ? ( // Format with k suffix (2.1k style)
    rounded_value >= 1000 ? (
      sprintf(#temp_display_str, "%.1fk", rounded_value / 1000);
    ) : rounded_value >= 100 ? (
      sprintf(#temp_display_str, "%.0f", rounded_value);
    ) : (
      sprintf(#temp_display_str, "%%.%df", decimal_places);
      sprintf(#temp_display_str, #temp_display_str, rounded_value);
    );
  ) : formatting == FORMAT_NONE ? ( // No formatting (display raw value)
    sprintf(#temp_display_str, "%g", rounded_value);
  ) : ( // Default formatting (FORMAT_NORMAL)
    sprintf(#temp_display_str, "%%.%df", decimal_places);
    sprintf(#temp_display_str, #temp_display_str, rounded_value);
  );
  
  // Apply additional format options (like rounding)
  format_options & OPTION_ROUNDED ? (
    // Apply additional rounding if requested
    sprintf(#temp_display_str, "%%.%df", decimal_places);
    sprintf(#temp_display_str, #temp_display_str, value);
  );
  
  // Get dynamic display mode for time controls
  dynamic_display_mode = get_time_display_mode(param_index, display_mode);
  
  // Add suffix based on display mode
  dynamic_display_mode == DISPLAY_MODE_PERCENT ? (
    sprintf(#temp_display_str, "%s %%", #temp_display_str)
  ) : dynamic_display_mode == DISPLAY_MODE_DB ? (
    sprintf(#temp_display_str, "%s dB", #temp_display_str)
  ) : dynamic_display_mode == DISPLAY_MODE_MS ? (
    sprintf(#temp_display_str, "%s ms", #temp_display_str)
  ) : dynamic_display_mode == DISPLAY_MODE_US ? (
    sprintf(#temp_display_str, "%s us", #temp_display_str)
  ) : dynamic_display_mode == DISPLAY_MODE_S ? (
    sprintf(#temp_display_str, "%s s", #temp_display_str)
  ) : dynamic_display_mode == DISPLAY_MODE_HZ ? (
    // Handle Hz display mode with special logic for k suffix
    value == 0 ? (
      sprintf(#temp_display_str, "Off");
    ) : value > 999 ? (
      // Display as kHz (for values over 999)
      freq_khz = value / 1000;
      freq_khz == floor(freq_khz) ? (
        sprintf(#temp_display_str, "%.0fk", freq_khz);
      ) : (
        sprintf(#temp_display_str, "%.1fk", freq_khz);
      );
    ) : (
      // Display as Hz
      sprintf(#temp_display_str, "%.0f Hz", value);
    );
  ) : (
    0; // Satisfy syntax requirement
  );
  
  #temp_display_str; // Return formatted string
);

// Unified slider function that handles all slider types with configurable behavior
function draw_unified_slider(x, y, w, h, value, min_val, max_val, label, param_index, slider_config) local(
  label_w, label_h, value_str_w, value_str_h, fill_direction, formatted_str, 
  normalized_pos, fill_w, handle_x, handle_y, center_x, fader_x, fill_start_x, fill_width,
  decimal_places, dynamic_display_mode, option_count, value_index, freq_value,
  reverse_mode, step_size, stepped_value, display_value, slider_orientation, knob_size,
  knob_center_x, knob_center_y, knob_radius, knob_angle, knob_indicator_x, knob_indicator_y, formatting
) (
  // Extract configuration parameters
  slider_orientation = slider_config & 0xFF;             // Bits 0-7: slider orientation (0=horizontal, 1=vertical, 2=small knob, 3=large knob)
  display_mode = (slider_config >> 8) & 0xFF;           // Bits 8-15: display mode
  fill_direction = (slider_config >> 16) & 0xFF;        // Bits 16-23: fill direction
  formatting = (slider_config >> 24) & 0xFF;            // Bits 24-31: formatting (0=normal, 1=k, 2=none)
  format_options = (slider_config >> 32) & 0xFF;        // Bits 32-39: format options (rounded, auto-step, bidirectional, reverse)
  
  // Check if this slider has enumerated options (stepped behavior)
  option_count = get_dropdown_option_count(param_index);
  
  // Calculate stepped value if slider has enumerated options
  option_count > 0 ? (
    // Get the index from our cached reverse lookup table (O(1) lookup)
    value_index = get_freq_list_index(param_index, value);
    
    // Get the actual discrete value from our cached enumerated list
    stepped_value = get_dropdown_option_value(param_index, value_index);
    
    // Calculate normalized position based on index in enumerated list
    reverse_mode = (format_options & OPTION_REVERSE);
    reverse_mode ? (
      // For reverse sliders, first option is at right (1.0), last option is at left (0.0)
      normalized_pos = 1.0 - (value_index / (option_count - 1));
    ) : (
      // For normal sliders, first option is at left (0.0), last option is at right (1.0)
      normalized_pos = value_index / (option_count - 1);
    );
    
    // Use stepped value for display
    display_value = stepped_value;
  ) : (
    // No enumerated options, use continuous range
    normalized_pos = (value - min_val) / (max_val - min_val);
    display_value = value;
  );
  
  // Draw label - center aligned for horizontal sliders and knobs
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  slider_orientation == ORIENTATION_VERTICAL ? ( // Vertical slider
    gfx_x = x + w + 8; gfx_y = y;
  ) : slider_orientation == ORIENTATION_KNOB_SMALL || slider_orientation == ORIENTATION_KNOB_LARGE ? ( // Knob style
    gfx_x = x; gfx_y = y - LABEL_HEIGHT;
  ) : ( // Horizontal slider - center align
    gfx_measurestr(label, label_w, label_h);
    gfx_x = x + (w - label_w) / 2;
    gfx_y = y - LABEL_HEIGHT;
  );
  gfx_drawstr(label);

  slider_orientation == ORIENTATION_KNOB_SMALL || slider_orientation == ORIENTATION_KNOB_LARGE ? ( // Knob style
    // Draw knob
    knob_size = slider_orientation == ORIENTATION_KNOB_LARGE ? LARGE_KNOB_SIZE : KNOB_SIZE;
    knob_center_x = x + knob_size / 2;
    knob_center_y = y + knob_size / 2;
    knob_radius = knob_size / 2;
    
    // Calculate knob angle based on normalized position
    knob_angle = -135 * $pi / 180 + normalized_pos * 270 * $pi / 180; // -135° to +135°
    
    // Draw knob background
    gfx_set(KNOB_BG_R, KNOB_BG_G, KNOB_BG_B, 1);
    gfx_circle(knob_center_x, knob_center_y, knob_radius, 1);
    
    // Draw knob indicator
    knob_indicator_x = knob_center_x + cos(knob_angle) * (knob_radius - 2);
    knob_indicator_y = knob_center_y + sin(knob_angle) * (knob_radius - 2);
    gfx_set(KNOB_INDICATOR_R, KNOB_INDICATOR_G, KNOB_INDICATOR_B, 1);
    gfx_circle(knob_indicator_x, knob_indicator_y, KNOB_INDICATOR_SIZE, 1);
    
    // Draw value text (if not hidden)
    display_mode != DISPLAY_MODE_HIDE_VALUE ? (
      gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
      gfx_x = x; gfx_y = y + knob_size + 5;
      
      // Format the value with appropriate decimal places and formatting
      formatted_str = format_slider_value_unified(param_index, display_value, display_mode, formatting, format_options);
      gfx_drawstr(formatted_str);
    );
  ) : slider_orientation == ORIENTATION_VERTICAL ? ( // Vertical slider
    // Draw slider background
    gfx_set(SLIDER_BG_R, SLIDER_BG_G, SLIDER_BG_B, 1);
    gfx_rect(x, y, w, h);

    // Draw slider fill from bottom
    fill_h = normalized_pos * h;
    gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
    gfx_rect(x, y + h - fill_h, w, fill_h);

    // Draw handle
    handle_y = y + h - fill_h - 3;
    gfx_set(1, 1, 1, 1);
    gfx_rect(x - 2, handle_y, w + 4, 6);

    // Draw value text (if not hidden)
    display_mode != DISPLAY_MODE_HIDE_VALUE ? (
      gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
      gfx_x = x + w + 8; gfx_y = y + h/2;
      
      // Format the value with appropriate decimal places and formatting
      formatted_str = format_slider_value_unified(param_index, display_value, display_mode, formatting, format_options);
      gfx_drawstr(formatted_str);
    );
  ) : ( // Horizontal slider (includes normal and reverse styles)
    // Draw slider background
    gfx_set(SLIDER_BG_R, SLIDER_BG_G, SLIDER_BG_B, 1);
    gfx_rect(x, y, w, h);

    // Draw slider fill based on fill direction
    fill_w = normalized_pos * w;

    fill_direction == FILL_LEFT_TO_RIGHT ? (
      // Fill from LEFT edge to fader position
      gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
      gfx_rect(x, y, fill_w, h);
    ) : fill_direction == FILL_CENTER_OUT ? (
      // Fill from center to fader position (both directions)
      center_x = x + w * 0.5;
      fader_x = x + fill_w;

      // Fill left side (from center to fader if fader is right of center)
      fader_x > center_x ? (
        gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
        gfx_rect(center_x, y, fader_x - center_x, h);
      );

      // Fill right side (from center to fader if fader is left of center)
      fader_x < center_x ? (
        gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
        gfx_rect(fader_x, y, center_x - fader_x, h);
      );
    ) : (
      // Default (RIGHT_TO_LEFT): Fill from RIGHT edge to fader position
      fill_start_x = x + fill_w;
      fill_width = w - fill_w;
      gfx_set(SLIDER_FILL_R, SLIDER_FILL_G, SLIDER_FILL_B, 1);
      gfx_rect(fill_start_x, y, fill_width, h);
    );

    // Draw handle
    handle_x = x + fill_w - 3;
    gfx_set(1, 1, 1, 1);
    gfx_rect(handle_x, y - 2, 6, h + 4);

    // Draw value text (if not hidden)
    display_mode != DISPLAY_MODE_HIDE_VALUE ? (
      // Format the value with appropriate decimal places and formatting
      formatted_str = format_slider_value_unified(param_index, display_value, display_mode, formatting, format_options);
      gfx_measurestr(formatted_str, value_str_w, value_str_h);
      
      // Smart positioning: left-anchored when >50%, right-anchored when <50%
      normalized_pos > 0.5 ? (
        // >50%: Anchor left, black text
        gfx_set(0, 0, 0, 1);  // Black
        gfx_x = x + 3;
      ) : (
        // <50%: Anchor right, white text
        gfx_set(1, 1, 1, 1);  // White
        gfx_x = x + w - value_str_w - 3;
      );
      gfx_y = y + (h - value_str_h) / 2;  // Center vertically
      gfx_drawstr(formatted_str);
    );
  );
);

//==============================================================================
// HELPER FUNCTIONS
//==============================================================================

//==============================================================================
// BUTTON RENDERING
//==============================================================================

function draw_generic_button(x, y, w, h, is_on, label) (
  // Draw button background
  is_on ? (
    gfx_set(BUTTON_ON_R, BUTTON_ON_G, BUTTON_ON_B, 1);
  ) : (
    gfx_set(BUTTON_OFF_R, BUTTON_OFF_G, BUTTON_OFF_B, 1);
  );
  gfx_rect(x, y, w, h);

  // Draw button border
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_rect(x, y, w, h, 0);

  // Draw button text
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x + 5; gfx_y = y + 5;
  gfx_drawstr(label);
);

//==============================================================================
// DROPDOWN RENDERING
//==============================================================================

function draw_generic_dropdown(x, y, w, h, current_value, label, param_index) (
  current_index = floor(current_value);
  
  // Draw label
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x; gfx_y = y - LABEL_HEIGHT;
  gfx_drawstr(label);

  // Draw dropdown background
  gfx_set(SLIDER_BG_R, SLIDER_BG_G, SLIDER_BG_B, 1);
  gfx_rect(x, y, w, h);

  // Draw dropdown border
  gfx_set(0.6, 0.6, 0.6, 1);
  gfx_rect(x, y, w, h, 0);

  // Draw current selection text
  gfx_set(TEXT_R, TEXT_G, TEXT_B, 1);
  gfx_x = x + 5; gfx_y = y + 5;

  // Display text using dynamic dropdown options
  get_dropdown_option_count(param_index) > 0 ? (
    // Use dynamically extracted dropdown options
    current_index < get_dropdown_option_count(param_index) ? (
      gfx_drawstr(get_dropdown_option(param_index, current_index));
    ) : (
      gfx_drawstr("Unknown");
    );
  ) : (
    // Fallback for non-dropdown parameters
    gfx_printf("%.0f", current_value);
  );

  // Draw dropdown arrow
  gfx_x = x + w - 15; gfx_y = y + 8;
  gfx_drawstr("v");
);

//==============================================================================
// GENERIC CONTROL DISPATCHER
//==============================================================================

function draw_control(index) local(group_idx) (
  type = control_defs[index*11 + 0];
  x = control_defs[index*11 + 1];
  y = control_defs[index*11 + 2];
  w = control_defs[index*11 + 3];
  h = control_defs[index*11 + 4];
  param_index = control_defs[index*11 + 5];
  min_val = control_defs[index*11 + 6];
  max_val = control_defs[index*11 + 7];
  group_idx = control_defs[index*11 + 10];

  // Add group offset if control is in a group
  group_idx >= 0 ? (
    x += group_defs[group_idx*6 + 0];
    y += group_defs[group_idx*6 + 1];
  );

  // Get current parameter value
  current_value = slider(param_index);

  // Handle different control types
  type == 0 ? ( // Slider - use unified system (includes knob-style sliders)
    slider_config = control_defs[index*11 + 8];
    draw_unified_slider(x, y, w, h, current_value, min_val, max_val, get_slider_name(param_index), param_index, slider_config);
  ) : type == 1 ? ( // Button
    draw_generic_button(x, y, w, h, current_value > 0.5, get_slider_name(param_index));
  ) : type == 2 ? ( // Dropdown
    draw_generic_dropdown(x, y, w, h, current_value, get_slider_name(param_index), param_index);
  ) : (
    0; // Unknown control type
  );
);

