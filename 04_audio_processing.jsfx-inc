// Audio Processing Module
// Handles DSP functions including filtering, RMS calculation, envelope following,
// lookahead processing, and program-dependent release algorithms

@init


//==============================================================================
// FILTER PROCESSING
//==============================================================================

function calc_biquad_hp(freq) (
  w = 2 * PI * freq * SRATE_INV;
  cosw = cos(w);
  sinw = sin(w);
  alpha = sinw / sqrt(2);

  b0 = (1 + cosw) / 2;
  b1 = -(1 + cosw);
  b2 = (1 + cosw) / 2;
  a0 = 1 + alpha;
  a1 = -2 * cosw;
  a2 = 1 - alpha;

  a1 /= a0; a2 /= a0; b0 /= a0; b1 /= a0; b2 /= a0;
);

function calc_biquad_lp(freq) (
  w = 2 * PI * freq * SRATE_INV;
  cosw = cos(w);
  sinw = sin(w);
  alpha = sinw / sqrt(2);

  b0 = (1 - cosw) / 2;
  b1 = 1 - cosw;
  b2 = (1 - cosw) / 2;
  a0 = 1 + alpha;
  a1 = -2 * cosw;
  a2 = 1 - alpha;

  a1 /= a0; a2 /= a0; b0 /= a0; b1 /= a0; b2 /= a0;
);

//==============================================================================
// RMS AND LEVEL DETECTION
//==============================================================================

function process_rms_detection(detect_l, detect_r) local(detect_squared, rms_level, peak_level, normalized_rms) (
  // RMS calculation with optional normalization
  detect_squared = (detect_l * detect_l + detect_r * detect_r) * 0.5;
  rms_sum -= rms_buffer[rms_pos];
  rms_buffer[rms_pos] = detect_squared;
  rms_sum += detect_squared;
  rms_pos = (rms_pos + 1) % rms_samples;

  rms_level = sqrt(rms_sum / rms_samples);

  // Apply RMS normalization if enabled
  rms_normalization > 0.5 ? (
    // Track running maximum for normalization
    rms_level > rms_max ? (rms_max = rms_level) : (rms_max = rms_max * 0.9999); // slow decay

    // Normalize RMS to 0..1 relative to running max
    normalized_rms = rms_level / (rms_max + eps);

    // Use peak detection for final level but shape with normalized RMS
    peak_level = max(abs(detect_l), abs(detect_r));
    detector_level = normalized_rms * peak_level;
  ) : (
    // Standard RMS or peak detection
    rms_size_ms > 0 ? (
      detector_level = rms_level;
    ) : (
      detector_level = max(abs(detect_l), abs(detect_r)); // peak mode when RMS window = 0
    );
  );

  detector_level
);

//==============================================================================
// ENVELOPE FOLLOWING AND PROGRAM RELEASE
//==============================================================================

function process_envelope_following(target_gr_db, detector_level) local(global_attack_coef, rel_mult, rel_fast, rel_med, rel_slow, gr_amount, det_delta, rel_coef_use, blend_fast, blend_slow, sum, base, fixed_rel_coef) (
  // Global smoothing with program-dependent release
  global_attack_coef = exp(-1/(max(0.0001, attack_ms*0.001)*srate));

  // Attack always uses global attack coefficient
  target_gr_db < global_smoothed_gain_db ? (
    global_smoothed_gain_db = global_attack_coef * global_smoothed_gain_db + (1 - global_attack_coef) * target_gr_db;
  ) : (
    // Release path: check if program-dependent mode is enabled
    prog_release_mode > 0.5 ? (
      // Program-dependent release: use release slider as multiplier (0..2000ms -> 0.5x..2.0x)
      rel_mult = 0.5 + (release_ms / 2000.0) * 1.5;

      // Base release coefficients adjusted by multiplier
      rel_fast = exp(-1/(base_fast_s * rel_mult * srate));
      rel_med = exp(-1/(base_med_s * rel_mult * srate));
      rel_slow = exp(-1/(base_slow_s * rel_mult * srate));

      gr_amount = abs(target_gr_db);
      det_delta = prev_detector_db - linear_to_db(detector_level);

      // Select release coefficient based on program release type
      rel_coef_use = rel_med;
      prog_release_type == 0 ? (
        // Level-dependent: deeper GR -> slower release
        blend_fast = clamp(1 - gr_amount / 6, 0, 1);
        blend_slow = clamp(gr_amount / 6, 0, 1);
        sum = blend_fast + blend_slow + eps;
        rel_coef_use = (blend_fast * rel_fast + blend_slow * rel_slow) / sum;
      ) : prog_release_type == 1 ? (
        // Rate-of-change: fast release if level drops rapidly
        rel_coef_use = det_delta > 3 ? rel_fast : rel_slow;
      ) : (
        // Hybrid: combine level base then bias by rate-of-change
        blend_fast = clamp(1 - gr_amount / 6, 0, 1);
        blend_slow = clamp(gr_amount / 6, 0, 1);
        base = (blend_fast * rel_fast + blend_slow * rel_slow) / max(blend_fast + blend_slow, eps);
        rel_coef_use = det_delta > 3 ? min(base, rel_fast) : max(base, rel_slow);
      );

      global_smoothed_gain_db = rel_coef_use * global_smoothed_gain_db + (1 - rel_coef_use) * target_gr_db;
    ) : (
      // Fixed release mode: use release slider as direct time
      fixed_rel_coef = exp(-1/(max(0.0001, release_ms*0.001) * srate));
      global_smoothed_gain_db = fixed_rel_coef * global_smoothed_gain_db + (1 - fixed_rel_coef) * target_gr_db;
    );
  );

  global_smoothed_gain_db
);

//==============================================================================
// LOOKAHEAD PROCESSING
//==============================================================================

function process_lookahead(input_l_orig, input_r_orig) local(delayed_pos, processed_l, processed_r) (
  lookahead_samples > 0 ? (
    lookahead_buffer_l[lookahead_pos] = input_l_orig;
    lookahead_buffer_r[lookahead_pos] = input_r_orig;

    delayed_pos = (lookahead_pos - lookahead_samples + max_lookahead_samples) % max_lookahead_samples;
    processed_l = lookahead_buffer_l[delayed_pos];
    processed_r = lookahead_buffer_r[delayed_pos];

    lookahead_pos = (lookahead_pos + 1) % max_lookahead_samples;
  ) : (
    processed_l = input_l_orig;
    processed_r = input_r_orig;
  );

  // Return processed signals via global variables
  lookahead_out_l = processed_l;
  lookahead_out_r = processed_r;
);

//==============================================================================
// FILTER APPLICATION
//==============================================================================

function apply_sidechain_filters(detect_l, detect_r) local(detect_l_filtered, detect_r_filtered) (
  // Apply highpass filter
  detect_l_filtered = hp_b0 * detect_l + hp_b1 * hp_x1_l + hp_b2 * hp_x2_l - hp_a1 * hp_y1_l - hp_a2 * hp_y2_l;
  hp_x2_l = hp_x1_l; hp_x1_l = detect_l; hp_y2_l = hp_y1_l; hp_y1_l = detect_l_filtered;

  detect_r_filtered = hp_b0 * detect_r + hp_b1 * hp_x1_r + hp_b2 * hp_x2_r - hp_a1 * hp_y1_r - hp_a2 * hp_y2_r;
  hp_x2_r = hp_x1_r; hp_x1_r = detect_r; hp_y2_r = hp_y1_r; hp_y1_r = detect_r_filtered;

  // Apply lowpass filter
  detect_l = lp_b0 * detect_l_filtered + lp_b1 * lp_x1_l + lp_b2 * lp_x2_l - lp_a1 * lp_y1_l - lp_a2 * lp_y2_l;
  lp_x2_l = lp_x1_l; lp_x1_l = detect_l_filtered; lp_y2_l = lp_y1_l; lp_y1_l = detect_l;

  detect_r = lp_b0 * detect_r_filtered + lp_b1 * lp_x1_r + lp_b2 * lp_x2_r - lp_a1 * lp_y1_r - lp_a2 * lp_y2_r;
  lp_x2_r = lp_x1_r; lp_x1_r = detect_r_filtered; lp_y2_r = lp_y1_r; lp_y1_r = detect_r;

  // Return filtered signals via global variables
  filtered_l = detect_l;
  filtered_r = detect_r;
);


//==============================================================================
// LEVEL CALCULATION AND CURVE APPLICATION
//==============================================================================

function calculate_gain_reduction(input_level_db) local(adjusted_input_db, target_output_db, target_gr_db, gr_factor, curve_factor) (
  // Apply compression curve with global offset
  adjusted_input_db = input_level_db - global_offset_db;
  target_output_db = interpolate_compression_curve(adjusted_input_db);
  target_output_db += global_offset_db;
  target_gr_db = target_output_db - input_level_db;

  // Apply strength and curves
  target_gr_db *= strength;

  strength_curve != 0 ? (
    gr_factor = abs(target_gr_db) / abs(max_gr_db);
    curve_factor = pow(gr_factor, pow(2, strength_curve));
    target_gr_db *= curve_factor;
  );

  target_gr_db = max(max_gr_db, target_gr_db);

  target_gr_db
);

//==============================================================================
// FINAL MIX PROCESSING
//==============================================================================

function apply_final_mix(processed_l, processed_r, input_l_orig, input_r_orig) local(mix_dry, mix_wet_factor, final_l, final_r) (
  // Final mix
  mix_dry = (100 - mix_wet) * 0.01;
  mix_wet_factor = mix_wet * 0.01;

  final_l = processed_l * mix_wet_factor + input_l_orig * mix_dry;
  final_r = processed_r * mix_wet_factor + input_r_orig * mix_dry;

  // Return final signals via global variables
  final_out_l = final_l;
  final_out_r = final_r;
);