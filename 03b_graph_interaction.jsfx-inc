// Graph Interaction Module
// Mouse interaction and point manipulation for graph editing
// Depends on: 02a_math_utils.jsfx-inc, 02d_ui_utils.jsfx-inc, 03a_graph_data.jsfx-inc, 01d_ui_interaction.jsfx-inc

@init

//==============================================================================
// MOUSE INTERACTION HANDLERS
//==============================================================================

function handle_point_movement() (
  // Only allow movement of non-corner points
  selected_point > 0 && selected_point < num_points - 1 ? (
    new_input_db = graph_x_to_db(mouse_x);
    new_output_db = graph_y_to_db(mouse_y);

    // Constrain to graph bounds
    new_input_db = clamp(new_input_db, GRAPH_MIN_DB, GRAPH_MAX_DB);
    new_output_db = clamp(new_output_db, GRAPH_MIN_DB, GRAPH_MAX_DB);

    // Store old position to check if significant movement occurred
    old_input_db = graph_points[selected_point*2];

    // Update point position
    graph_points[selected_point*2] = new_input_db;
    graph_points[selected_point*2 + 1] = new_output_db;

    // Re-sort points to maintain order
    sort_points();

    // Check if significant movement occurred and clean up displaced points
    abs(new_input_db - old_input_db) > 1.0 ? (
      remove_displaced_points(new_input_db, new_output_db);
    );
  );
);

function handle_curve_adjustment() (
  // Only allow curve adjustment of non-corner points
  selected_point > 0 && selected_point < num_points - 1 ? (
    // Calculate curve amount based on drag distance
    drag_distance = sqrt(sqr(mouse_x - mouse_x_prev) + sqr(mouse_y - mouse_y_prev));
    max_drag_distance = 100; // Maximum drag distance for 100% curve
    
    // Calculate curve amount (0-100%)
    curve_amount = clamp(drag_distance / max_drag_distance * 100, 0, 100);
    
    // Set the curve amount for this point
    set_curve_amount(selected_point, curve_amount);
  );
);

function handle_point_addition() (
  new_input_db = clamp(graph_x_to_db(mouse_x), GRAPH_MIN_DB, GRAPH_MAX_DB);
  new_output_db = clamp(graph_y_to_db(mouse_y), GRAPH_MIN_DB, GRAPH_MAX_DB);

  // Check if too close to existing points (buffer area)
  too_close = 0;
  i = 1;
  while (i < num_points - 1 && !too_close) (
    point_x = db_to_graph_x(graph_points[i*2]);
    point_y = db_to_graph_y(graph_points[i*2 + 1]);
    dist_sq = (mouse_x - point_x) * (mouse_x - point_x) + (mouse_y - point_y) * (mouse_y - point_y);
    dist_sq < (MOUSE_CLICK_RADIUS * 2) * (MOUSE_CLICK_RADIUS * 2) ? (
      too_close = 1;
    );
    i += 1;
  );

  !too_close ? (
    add_point(new_input_db, new_output_db);
  ) : (
    -1; // Return -1 if too close to add
  );
);

function handle_point_deletion() (
  point_to_delete = find_point_at_mouse(mouse_x, mouse_y);
  point_to_delete > 0 && point_to_delete < num_points - 1 ? (
    delete_point(point_to_delete);
  );
);

function process_mouse_input() (
  // Handle custom UI controls first (they have priority)
  handle_ui_mouse_input();

  // Only process graph mouse input if not interacting with UI controls
  !ui_mouse_down ? (
    // Always update hover state first
    hovered_point = find_point_at_mouse(mouse_x, mouse_y);

    mouse_cap & 1 ? ( // Left mouse button pressed
      !mouse_down ? ( // Start of click/drag
        mouse_down = 1;

        mouse_cap & 16 ? ( // Alt+click = delete point
          handle_point_deletion();
          selected_point = -1;
        ) : (
          // Find point under mouse for selection
          selected_point = find_point_at_mouse(mouse_x, mouse_y);
          selected_point == -1 && is_point_in_graph(mouse_x, mouse_y) ? (
            // Click in empty space - add point
            selected_point = handle_point_addition();
          );
        );

        mouse_x_prev = mouse_x;
        mouse_y_prev = mouse_y;
      ) : ( // Continue drag
        selected_point >= 0 ? (
          mouse_cap & 4 ? ( // Cmd+drag = adjust curve
            handle_curve_adjustment();
          ) : (
            // Normal drag = move point
            handle_point_movement();
          );
        );

        mouse_x_prev = mouse_x;
        mouse_y_prev = mouse_y;
      );
    ) : mouse_cap & 2 ? ( // Right mouse button
      !mouse_down ? (
        mouse_down = 1;
        handle_point_deletion();
      );
    ) : (
      // Mouse button released - reset state
      mouse_down = 0;
      selected_point = -1;
    );
  );
);

//==============================================================================
// GRAPH INTERACTION UTILITIES
//==============================================================================

function get_selected_point() (
  selected_point;
);

function set_selected_point(point_index) (
  selected_point = point_index;
);

function get_hovered_point() (
  hovered_point;
);

function is_mouse_down() (
  mouse_down;
);

function set_mouse_down(down) (
  mouse_down = down;
);

function get_mouse_previous_position() (
  x = mouse_x_prev;
  y = mouse_y_prev;
  // Return via global variables since JSFX doesn't support multiple return values
  mouse_x_prev;
);

function set_mouse_previous_position(x, y) (
  mouse_x_prev = x;
  mouse_y_prev = y;
);
