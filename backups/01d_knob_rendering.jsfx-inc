// Knob Rendering Module
// Handles rendering of small and large knobs
// Dependencies: 01_Utils/01_constants.jsfx-inc, UI_Sliders/00_slider_constants.jsfx-inc, UI_Sliders/01a_value_formatting.jsfx-inc, UI_Sliders/01b_value_text_rendering.jsfx-inc

@init

//==============================================================================
// KNOB RENDERING
//==============================================================================
//
// This module provides knob rendering for small and large knobs.
// It handles:
// - Small knobs with angular indicator (dot that rotates)
// - Large knobs with arc fill and indicator bar
// - Multiple knob types (LTR, RTL, bidirectional)
// - Drop shadows for depth
// - Enumerated and continuous knob types
// - Label rendering above knob
// - Value text rendering below knob
//
// USAGE:
//   draw_knob(x, y, value, min_val, max_val, "Label", param_index,
//             ORIENTATION_KNOB_SMALL, " dB", FORMAT_K, 0);
//
// KNOB TYPES:
//   Small Knob:
//     KNOB_TYPE_ANGULAR - Rotating dot indicator
//     KNOB_TYPE_ROTARY - Arc fill (not currently used)
//   Large Knob:
//     LARGE_KNOB_TYPE_LTR - Left to right arc fill
//     LARGE_KNOB_TYPE_RTL - Right to left arc fill
//     LARGE_KNOB_TYPE_BIDIR - Bidirectional arc fill
//

//==============================================================================
// SMALL KNOB RENDERING
//==============================================================================

// Enhanced small knob rendering with different knob types
// Size parameters: knob_radius, shadow_offset, indicator_size
// Angle parameters: angle_start, angle_range (in radians)
// Color parameters: shadow_r, shadow_g, shadow_b, bg_r, bg_g, bg_b, indicator_r, indicator_g, indicator_b
function draw_knob_at_position(x, y, value, min_val, max_val, knob_type, knob_radius, shadow_offset, indicator_size, angle_start, angle_range, shadow_r, shadow_g, shadow_b, bg_r, bg_g, bg_b, indicator_r, indicator_g, indicator_b) (
  // Helper function to draw a knob at a specific position with given parameters
  center_x = x + knob_radius;
  center_y = y + knob_radius;

  // Draw drop shadow first (offset down and right)
  gfx_set(shadow_r, shadow_g, shadow_b, 0.3);
  gfx_circle(center_x + shadow_offset, center_y + shadow_offset, knob_radius, 1);

  // Draw knob background
  gfx_set(bg_r, bg_g, bg_b, 1);
  gfx_circle(center_x, center_y, knob_radius, 1);

  // Calculate normalized value
  normalized_value = (value - min_val) / (max_val - min_val);
  normalized_value = max(0, min(1, normalized_value));

  knob_type == KNOB_TYPE_ANGULAR ? (
    // Angular knob - draw indicator based on angle
    current_angle = angle_start + normalized_value * angle_range;

    // Calculate indicator position (8 pixels from center)
    indicator_distance = 8;
    indicator_x = center_x + cos(current_angle) * indicator_distance;
    indicator_y = center_y + sin(current_angle) * indicator_distance;

    // Draw indicator circle
    gfx_set(indicator_r, indicator_g, indicator_b, 1);
    gfx_circle(indicator_x, indicator_y, indicator_size, 1);
  ) : (
    // Rotary knob - draw arc based on value
    arc_angle = normalized_value * 2 * $pi;
    gfx_set(indicator_r, indicator_g, indicator_b, 1);
    gfx_arc(center_x, center_y, knob_radius - 2, 0, arc_angle, 1);
  );
);

//==============================================================================
// LARGE KNOB RENDERING
//==============================================================================

// Enhanced large knob rendering with different knob types
// Size parameters: knob_radius, arc_depth, bar_overhang
// Angle parameters: angle_ltr_start, angle_ltr_end, angle_rtl_start, angle_rtl_end, angle_bidir_start, angle_bidir_end (in radians)
// Color parameters: shadow_r, shadow_g, shadow_b, bg_r, bg_g, bg_b, arc_r, arc_g, arc_b, bar_r, bar_g, bar_b
function draw_large_knob_at_position(x, y, value, min_val, max_val, knob_type, knob_radius, arc_depth, bar_overhang, angle_ltr_start, angle_ltr_end, angle_rtl_start, angle_rtl_end, angle_bidir_start, angle_bidir_end, shadow_r, shadow_g, shadow_b, bg_r, bg_g, bg_b, arc_r, arc_g, arc_b, bar_r, bar_g, bar_b) (
  // Helper function to draw a large knob at a specific position with given parameters
  center_x = x + knob_radius;
  center_y = y + knob_radius;

  // Draw drop shadow first (offset down and right)
  gfx_set(shadow_r, shadow_g, shadow_b, 0.3);
  gfx_circle(center_x + 1, center_y + 1, knob_radius, 1);

  // Draw knob background (inner gray circle)
  gfx_set(bg_r, bg_g, bg_b, 1);
  gfx_circle(center_x, center_y, knob_radius, 1);

  // Calculate normalized value
  normalized_value = (value - min_val) / (max_val - min_val);
  normalized_value = max(0, min(1, normalized_value));

  // Calculate arc angles based on knob type
  knob_type == LARGE_KNOB_TYPE_LTR ? (
    start_angle = angle_ltr_start;
    end_angle = angle_ltr_start + normalized_value * (angle_ltr_end - angle_ltr_start);
    indicator_angle = end_angle;
  ) : knob_type == LARGE_KNOB_TYPE_RTL ? (
    start_angle = angle_rtl_start;
    end_angle = angle_rtl_start + normalized_value * (angle_rtl_end - angle_rtl_start);
    indicator_angle = end_angle;
  ) : ( // LARGE_KNOB_TYPE_BIDIRECTIONAL
    start_angle = angle_bidir_start;
    end_angle = angle_bidir_start + normalized_value * (angle_bidir_end - angle_bidir_start);
    indicator_angle = end_angle;
  );

  // Draw yellow arc from start to current value using gfx_arc()
  gfx_set(arc_r, arc_g, arc_b, 1);
  inner_radius = knob_radius - arc_depth;
  outer_radius = knob_radius;
  // Draw arc as a thick ring by drawing multiple arcs at different radii
  i = 0;
  while (i <= arc_depth) (
    current_radius = inner_radius + i;
    gfx_arc(center_x, center_y, current_radius, start_angle, end_angle, 1);
    i += 1;
  );

  // Draw white indicator bar
  gfx_set(bar_r, bar_g, bar_b, 1);

  // Calculate bar endpoints
  bar_inner_x = center_x + cos(indicator_angle) * inner_radius;
  bar_inner_y = center_y + sin(indicator_angle) * inner_radius;
  bar_outer_x = center_x + cos(indicator_angle) * (outer_radius + bar_overhang);
  bar_outer_y = center_y + sin(indicator_angle) * (outer_radius + bar_overhang);

  // Draw bar as a thick line (3 pixels wide for smaller knob)
  bar_width = 3;
  angle_perp = indicator_angle + $pi/2; // Perpendicular angle

  // Calculate perpendicular offset for bar width
  offset_x = cos(angle_perp) * bar_width/2;
  offset_y = sin(angle_perp) * bar_width/2;

  // Draw bar as a rectangle (simplified approach)
  bar_mid_x = (bar_inner_x + bar_outer_x) / 2;
  bar_mid_y = (bar_inner_y + bar_outer_y) / 2;
  bar_length = sqrt((bar_outer_x - bar_inner_x)^2 + (bar_outer_y - bar_inner_y)^2);

  // Draw thick line by drawing multiple parallel lines
  i = -bar_width/2;
  while (i <= bar_width/2) (
    line_x1 = bar_inner_x + offset_x * i / (bar_width/2);
    line_y1 = bar_inner_y + offset_y * i / (bar_width/2);
    line_x2 = bar_outer_x + offset_x * i / (bar_width/2);
    line_y2 = bar_outer_y + offset_y * i / (bar_width/2);

    gfx_line(line_x1, line_y1, line_x2, line_y2, 1);
    i += 1;
  );
);

//==============================================================================
// KNOB STYLE CONFIGURATION (Module-level variables)
//==============================================================================

// Style configuration variables - set these before rendering
// Small knob sizes
knob_style_small_radius = 8;
knob_style_small_size = 17;
knob_style_shadow_offset = 2;
knob_style_indicator_size = 2;
knob_style_angle_start = -135 * $pi / 180;
knob_style_angle_range = 270 * $pi / 180;

// Large knob sizes
knob_style_large_radius = 19;
knob_style_large_size = 38;
knob_style_arc_depth = 2;
knob_style_bar_overhang = 2;
knob_style_angle_ltr_start = 0 * $pi / 180;
knob_style_angle_ltr_end = 270 * $pi / 180;
knob_style_angle_rtl_start = 90 * $pi / 180;
knob_style_angle_rtl_end = 360 * $pi / 180;
knob_style_angle_bidir_start = -135 * $pi / 180;
knob_style_angle_bidir_end = 135 * $pi / 180;

// Colors (RGB values 0-1)
knob_style_text_r = 1.0; knob_style_text_g = 1.0; knob_style_text_b = 1.0;
knob_style_shadow_r = 0.0; knob_style_shadow_g = 0.0; knob_style_shadow_b = 0.0;
knob_style_bg_r = 0.3; knob_style_bg_g = 0.3; knob_style_bg_b = 0.3;
knob_style_indicator_r = 0.0; knob_style_indicator_g = 0.0; knob_style_indicator_b = 0.0;
knob_style_arc_r = 0.8; knob_style_arc_g = 0.6; knob_style_arc_b = 0.2;
knob_style_bar_r = 1.0; knob_style_bar_g = 1.0; knob_style_bar_b = 1.0;

// Layout
knob_style_label_height = 11;

//==============================================================================
// KNOB RENDERING WRAPPER
//==============================================================================

// Draw knob control (small or large) - uses style configuration variables
// suffix_str: Suffix string to append (e.g., " ms", " dB"). Empty string means no suffix.
function draw_knob(x, y, value, min_val, max_val, label, param_index, knob_type, suffix_str, formatting, format_options, display_mode) local(
  normalized_pos, option_count, value_index, reverse_mode, stepped_value, display_value, raw_value
) (
  // Store raw value for enumerated sliders (format_slider_value needs the index, not the frequency)
  raw_value = value;
  // Check if this knob has enumerated options (stepped behavior)
  option_count = get_dropdown_option_count(param_index);
  
  // Calculate stepped value if knob has enumerated options
  option_count > 0 ? (
    // Slider value IS the index for enumerated sliders
    value_index = floor(value);
    value_index = max(0, min(option_count - 1, value_index));
    
    // Get the actual discrete value from our cached enumerated list
    stepped_value = get_dropdown_option_value(param_index, value_index);
    
    // Calculate normalized position based on index in enumerated list
    reverse_mode = (format_options & OPTION_REVERSE);
    option_count > 1 ? (
      reverse_mode ? (
        // For reverse knobs, first option is at right (1.0), last option is at left (0.0)
        normalized_pos = 1.0 - (value_index / (option_count - 1));
      ) : (
        // For normal knobs, first option is at left (0.0), last option is at right (1.0)
        normalized_pos = value_index / (option_count - 1);
      );
    ) : (
      // Only one option - center it
      normalized_pos = 0.5;
    );
    
    // Use stepped value for display
    display_value = stepped_value;
  ) : (
    // No enumerated options, use continuous range
    normalized_pos = (value - min_val) / (max_val - min_val);
    display_value = value;
  );
  
  // Draw label - center aligned for knobs
  gfx_set(knob_style_text_r, knob_style_text_g, knob_style_text_b, 1);
  gfx_x = x; gfx_y = y - knob_style_label_height;
  gfx_drawstr(label);

  knob_type == ORIENTATION_KNOB_LARGE ? (
    // Large knob - use enhanced large knob rendering
    draw_large_knob_at_position(x, y, display_value, min_val, max_val, LARGE_KNOB_TYPE_LTR, knob_style_large_radius, knob_style_arc_depth, knob_style_bar_overhang, knob_style_angle_ltr_start, knob_style_angle_ltr_end, knob_style_angle_rtl_start, knob_style_angle_rtl_end, knob_style_angle_bidir_start, knob_style_angle_bidir_end, knob_style_shadow_r, knob_style_shadow_g, knob_style_shadow_b, knob_style_bg_r, knob_style_bg_g, knob_style_bg_b, knob_style_arc_r, knob_style_arc_g, knob_style_arc_b, knob_style_bar_r, knob_style_bar_g, knob_style_bar_b);
    
    // Draw value text
    // For enumerated sliders, pass the raw value (index) to format_slider_value, not the converted frequency
    // format_slider_value will handle the conversion and formatting
    option_count > 0 ? (
      draw_control_value_text(x, y + knob_style_large_size + 5, param_index, raw_value, suffix_str, formatting, format_options, display_mode, knob_style_text_r, knob_style_text_g, knob_style_text_b);
    ) : (
      draw_control_value_text(x, y + knob_style_large_size + 5, param_index, display_value, suffix_str, formatting, format_options, display_mode, knob_style_text_r, knob_style_text_g, knob_style_text_b);
    );
  ) : (
    // Small knob - use enhanced small knob rendering
    draw_knob_at_position(x, y, display_value, min_val, max_val, KNOB_TYPE_ANGULAR, knob_style_small_radius, knob_style_shadow_offset, knob_style_indicator_size, knob_style_angle_start, knob_style_angle_range, knob_style_shadow_r, knob_style_shadow_g, knob_style_shadow_b, knob_style_bg_r, knob_style_bg_g, knob_style_bg_b, knob_style_indicator_r, knob_style_indicator_g, knob_style_indicator_b);
    
    // Draw value text
    // For enumerated sliders, pass the raw value (index) to format_slider_value, not the converted frequency
    // format_slider_value will handle the conversion and formatting
    option_count > 0 ? (
      draw_control_value_text(x, y + knob_style_small_size + 5, param_index, raw_value, suffix_str, formatting, format_options, display_mode, knob_style_text_r, knob_style_text_g, knob_style_text_b);
    ) : (
      draw_control_value_text(x, y + knob_style_small_size + 5, param_index, display_value, suffix_str, formatting, format_options, display_mode, knob_style_text_r, knob_style_text_g, knob_style_text_b);
    );
  );
);



