// Harmonic Processing Models Module
// Harmonic generation algorithms, character-specific processing, and harmonic application
// Depends on: 00b_math_utils.jsfx-inc, 00c_audio_utils.jsfx-inc

@init

//==============================================================================
// HARMONIC PROCESSING HELPERS
//==============================================================================

function apply_enhanced_tape_processing(driven, amount, combined_factor, even_boost, odd_boost) local(
  scaled_saturation, x, x2, x3, x5, x7, even_boost_factor, odd_boost_factor, result, asymmetric_factor
) (
  scaled_saturation = amount * combined_factor;
  x = driven;
  
  even_boost_factor = 1 + even_boost * 0.01;
  odd_boost_factor = 1 + odd_boost * 0.01;
  asymmetric_factor = x > 0 ? 1.0 : 0.9;
  
  x2 = x * x;
  x3 = x2 * x;
  x5 = x3 * x2;
  x7 = x5 * x2;
  
  // Tape baseline: very subtle even harmonics, strong odd harmonics (odd-dominant)
  result = x + x2 * scaled_saturation * 0.0005 * even_boost_factor * asymmetric_factor;
  
  odd_boost > 0 ? (
    result += x3 * scaled_saturation * 0.01 * odd_boost_factor * asymmetric_factor +
              x5 * scaled_saturation * 0.005 * odd_boost_factor * asymmetric_factor +
              x7 * scaled_saturation * 0.0025 * odd_boost_factor * asymmetric_factor
  );
  
  result;
);

function apply_enhanced_tube_processing(driven, amount, combined_factor, even_boost, odd_boost) local(
  scaled_saturation, x, x2, x3, x5, odd_boost_factor, even_boost_factor, result, asymmetric_factor
) (
  scaled_saturation = amount * combined_factor;
  x = driven;
  
  odd_boost_factor = 1 + odd_boost * 0.01;
  even_boost_factor = 1 + even_boost * 0.01;
  asymmetric_factor = x > 0 ? 1.0 : 0.85;
  
  x2 = x * x;
  x3 = x2 * x;
  x5 = x3 * x2;
  
  // Tube baseline: strong even harmonics (even-dominant)
  result = x + x2 * scaled_saturation * 0.01 * even_boost_factor * asymmetric_factor;
  
  odd_boost > 0 ? (
    result += x3 * scaled_saturation * 0.002 * odd_boost_factor * asymmetric_factor +
              x5 * scaled_saturation * 0.001 * odd_boost_factor * asymmetric_factor
  );
  
  result;
);

function apply_optical_processing(driven, amount, combined_factor, even_boost, odd_boost) local(
  scaled_saturation, x, x2, x3, x4, even_boost_factor, odd_boost_factor, result
) (
  scaled_saturation = amount * combined_factor;
  x = driven;
  
  x2 = x * x;
  x3 = x2 * x;
  x4 = x2 * x2;
  
  even_boost_factor = 1 + even_boost * 0.01;
  odd_boost_factor = 1 + odd_boost * 0.01;
  
  // Optical baseline: VERY subtle harmonics - transparent character
  result = x + x2 * scaled_saturation * 0.02 * even_boost_factor +
           x4 * scaled_saturation * 0.005 * even_boost_factor;
  
  odd_boost > 0 ? (
    result += x3 * scaled_saturation * 0.01 * odd_boost_factor
  );
  
  result;
);

//==============================================================================
// TUBE-STYLE TECHNIQUES (Helper Functions)
//==============================================================================

function apply_asymmetric_sharpening(input, sharpening_amount) local(
  sharpen, result
) (
  sharpen = -input;
  (sharpen > 0.0) ? (
    sharpen = 1.0 + sqrt(sharpen)
  ) : (
    sharpen = 1.0 - sqrt(-sharpen)
  );
  result = input - input * abs(input) * sharpen * sharpening_amount;
  result;
);

function apply_power_factor_saturation(input, power_factor, gain_scaling) local(
  factor, result
) (
  // OPTIMIZATION: Use native pow() instead of loop-based multiplication
  factor = pow(input, power_factor + 1);

  ((power_factor % 2 == 1) && (input != 0.0)) ? (
    factor = (factor / input) * abs(input)
  );

  factor *= gain_scaling;
  result = input - factor;
  result;
);

function apply_soft_clipping(input, clip_threshold, compensation_factor) local(
  result
) (
  result = input;
  (result > clip_threshold) ? result = clip_threshold;
  (result < -clip_threshold) ? result = -clip_threshold;
  result *= compensation_factor;
  result;
);

// Combined tube-style processing with level preservation
function apply_tube_processing(input, amount, power_factor, sharpening_amount, clip_threshold) local(
  harmonic_content, result
) (
  // Apply extremely subtle tube techniques to generate harmonic content only
  harmonic_content = 0;
  harmonic_content += apply_power_factor_saturation(input, power_factor, amount * 0.0001);
  harmonic_content += apply_asymmetric_sharpening(input, sharpening_amount * amount * 0.0001);
  harmonic_content = apply_soft_clipping(harmonic_content, clip_threshold, 1.0);
  result = input + harmonic_content;
  result;
);

//==============================================================================
// HARMONIC PROCESSING APPLICATION
//==============================================================================

function apply_harmonic_processing(input, gr_amount, envelope_amount, detector_level, type, drive, mix, even_boost, odd_boost) (
  debug_counter_harmonics += 1;
  
  type == 0 ? input : (
    // OPTIMIZATION: Use pre-calculated global values (shared between L/R channels)
    dry_signal = input;
    driven = input;
    
    drive_factor = (drive / 100.0) * 0.5;
    harmonic_amount_driven = harmonic_amount * drive_factor;
    
    processed = type == 1 ? (
      apply_enhanced_tape_processing(driven, harmonic_amount_driven, harmonic_combined_factor, even_boost, odd_boost)
    ) : (
      apply_enhanced_tube_processing(driven, harmonic_amount_driven, harmonic_combined_factor, even_boost, odd_boost)
    );

    // OPTIMIZATION: Use pre-calculated intensity (calculated once in audio chain)
    wet_signal = dry_signal + harmonic_intensity * (processed - dry_signal);
    mix * wet_signal + (1 - mix) * dry_signal
  )
);

