// Harmonic Processing Models Module
// Harmonic generation algorithms, character-specific processing, and harmonic application
// Depends on: 00b_math_utils.jsfx-inc, 00c_audio_utils.jsfx-inc

@init

//==============================================================================
// HARMONIC PROCESSING HELPERS
//==============================================================================

function apply_enhanced_tape_processing(driven, amount, combined_factor, even_boost, odd_boost) local(
  scaled_saturation, x, x2, x3, x5, x7, even_boost_factor, odd_boost_factor, result, asymmetric_factor
) (
  scaled_saturation = amount * combined_factor;
  x = driven;
  
  even_boost_factor = 1 + even_boost * 0.01;
  odd_boost_factor = 1 + odd_boost * 0.01;
  asymmetric_factor = x > 0 ? 1.0 : 0.9;
  
  x2 = x * x;
  x3 = x2 * x;
  x5 = x3 * x2;
  x7 = x5 * x2;
  
  // Tape baseline: very subtle even harmonics, strong odd harmonics (odd-dominant)
  result = x + x2 * scaled_saturation * 0.0005 * even_boost_factor * asymmetric_factor;
  
  odd_boost > 0 ? (
    result += x3 * scaled_saturation * 0.01 * odd_boost_factor * asymmetric_factor +
              x5 * scaled_saturation * 0.005 * odd_boost_factor * asymmetric_factor +
              x7 * scaled_saturation * 0.0025 * odd_boost_factor * asymmetric_factor
  );
  
  result;
);

function apply_enhanced_tube_processing(driven, amount, combined_factor, even_boost, odd_boost) local(
  scaled_saturation, x, x2, x3, x5, odd_boost_factor, even_boost_factor, result, asymmetric_factor
) (
  scaled_saturation = amount * combined_factor;
  x = driven;
  
  odd_boost_factor = 1 + odd_boost * 0.01;
  even_boost_factor = 1 + even_boost * 0.01;
  asymmetric_factor = x > 0 ? 1.0 : 0.85;
  
  x2 = x * x;
  x3 = x2 * x;
  x5 = x3 * x2;
  
  // Tube baseline: strong even harmonics (even-dominant)
  result = x + x2 * scaled_saturation * 0.01 * even_boost_factor * asymmetric_factor;
  
  odd_boost > 0 ? (
    result += x3 * scaled_saturation * 0.002 * odd_boost_factor * asymmetric_factor +
              x5 * scaled_saturation * 0.001 * odd_boost_factor * asymmetric_factor
  );
  
  result;
);

//==============================================================================
// TUBE-STYLE TECHNIQUES (Helper Functions)
//==============================================================================

function apply_asymmetric_sharpening(input, sharpening_amount) local(
  sharpen, result
) (
  sharpen = -input;
  (sharpen > 0.0) ? (
    sharpen = 1.0 + sqrt(sharpen)
  ) : (
    sharpen = 1.0 - sqrt(-sharpen)
  );
  result = input - input * abs(input) * sharpen * sharpening_amount;
  result;
);

function apply_power_factor_saturation(input, power_factor, gain_scaling) local(
  factor, result
) (
  // OPTIMIZATION: Use native pow() instead of loop-based multiplication
  factor = pow(input, power_factor + 1);

  ((power_factor % 2 == 1) && (input != 0.0)) ? (
    factor = (factor / input) * abs(input)
  );

  factor *= gain_scaling;
  result = input - factor;
  result;
);

function apply_soft_clipping(input, clip_threshold, compensation_factor) local(
  result
) (
  result = input;
  (result > clip_threshold) ? result = clip_threshold;
  (result < -clip_threshold) ? result = -clip_threshold;
  result *= compensation_factor;
  result;
);

//==============================================================================
// HARMONIC PROCESSING APPLICATION
//==============================================================================

function apply_harmonic_processing(input, gr_amount, envelope_amount, detector_level, type, drive, mix, even_boost, odd_boost) (
  debug_counter_harmonics += 1;
  
  // Early exit if mix is 0% (harmonics off)
  mix <= 0.0001 ? input : (
    // OPTIMIZATION: Use pre-calculated global values (shared between L/R channels)
    dry_signal = input;
    driven = input;
    
    drive_factor = (drive / 100.0) * 0.5;
    harmonic_amount_driven = harmonic_amount * drive_factor;
    
    // type: 0 = Tape, 1 = Tube (Off removed, mix=0% means off)
    processed = type == 0 ? (
      apply_enhanced_tape_processing(driven, harmonic_amount_driven, harmonic_combined_factor, even_boost, odd_boost)
    ) : (
      apply_enhanced_tube_processing(driven, harmonic_amount_driven, harmonic_combined_factor, even_boost, odd_boost)
    );

    // OPTIMIZATION: Use pre-calculated intensity (calculated once in audio chain)
    wet_signal = dry_signal + harmonic_intensity * (processed - dry_signal);
    mix * wet_signal + (1 - mix) * dry_signal
  )
);

