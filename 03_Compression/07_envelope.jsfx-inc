// Envelope Processing Module
// Envelope following and program-dependent release algorithms
// Depends on: 00b_math_utils.jsfx-inc, 00d_dsp_utils.jsfx-inc

@init

//==============================================================================
// ENVELOPE FOLLOWING AND PROGRAM RELEASE
//==============================================================================

//--- Helper: Blend between two coefficients based on normalized weights ---
function blend_two_coefficients(coef1, coef2, blend_factor) (
  coef1 * (1 - blend_factor) + coef2 * blend_factor
);

//--- Helper: Normalized blend using fast/slow weights ---
function normalized_blend(blend_fast, blend_slow, coef_fast, coef_slow) local(sum) (
  sum = blend_fast + blend_slow + eps;
  (blend_fast * coef_fast + blend_slow * coef_slow) / sum
);

//==============================================================================
// PROGRAM RELEASE STRATEGIES
//==============================================================================

//--- Type 1: Input-Dependent (single threshold) ---
function release_input_dependent_single(input_level_db) local(level_above_threshold, blend_fast, blend_slow) (
  level_above_threshold = input_level_db - input_level_threshold_db;
  // Optimized: inline clamp to avoid function call overhead
  blend_fast = max(0, min(1, 1 - level_above_threshold / 20));
  blend_slow = max(0, min(1, level_above_threshold / 20));
  normalized_blend(blend_fast, blend_slow, rel_fast, rel_slow)
);

//--- Type 2: GR-Dependent ---
function release_gr_dependent(gr_amount) local(blend_fast, blend_slow) (
  // Optimized: inline clamp to avoid function call overhead
  blend_fast = max(0, min(1, 1 - gr_amount / gr_blend_threshold_db));
  blend_slow = max(0, min(1, gr_amount / gr_blend_threshold_db));
  normalized_blend(blend_fast, blend_slow, rel_fast, rel_slow)
);

//--- Type 3: Rate-of-Change ---
function release_rate_of_change(det_delta) (
  det_delta > 3 ? rel_fast : rel_slow
);

//--- Type 4: Dual Threshold (three zones) ---
function release_dual_threshold(input_level_db) local(
  threshold_lower, threshold_upper, threshold_range, blend_factor, distance_above
) (
  threshold_lower = min(input_level_threshold_db, input_level_threshold_2_db);
  threshold_upper = max(input_level_threshold_db, input_level_threshold_2_db);
  threshold_range = threshold_upper - threshold_lower;
  
  input_level_db < threshold_lower ? (
    // Zone 1: Fast release
    rel_fast_cached
  ) : input_level_db < threshold_upper ? (
    // Zone 2: Blend fast to medium
    blend_factor = (input_level_db - threshold_lower) / (threshold_range + eps);
    blend_two_coefficients(rel_fast_cached, rel_med_cached, blend_factor)
  ) : (
    // Zone 3: Blend medium to slow
    distance_above = input_level_db - threshold_upper;
    // Optimized: inline clamp to avoid function call overhead
    blend_factor = max(0, min(1, distance_above / 20));
    blend_two_coefficients(rel_med_cached, rel_slow_cached, blend_factor)
  )
);

//==============================================================================
// HOLD PROCESSING
//==============================================================================

//--- Process Hold Logic ---
// Holds the largest gain reduction target for the specified hold_ms
// Returns the effective target GR to use for envelope following
function process_hold(target_gr_db) local(target_gr_abs, hold_target_abs) (
  // Only process hold if hold_ms > 0
  hold_ms > 0 ? (
    target_gr_abs = abs(target_gr_db);
    hold_target_abs = abs(hold_target_gr_db);
    
    // Check if new target is larger (more extreme) than current hold target
    // "More extreme" means further from zero (larger absolute value)
    target_gr_abs > hold_target_abs ? (
      // Larger target detected - reset hold counter and update hold target
      hold_target_gr_db = target_gr_db;
      hold_counter_samples = hold_samples;
      target_gr_db = hold_target_gr_db;  // Use held value for envelope
    ) : (
      // Current target is not larger - check if hold is still active
      hold_counter_samples > 0 ? (
        // Hold is active - use held target and decrement counter
        hold_counter_samples -= 1;
        target_gr_db = hold_target_gr_db;  // Use held value for envelope
      ) : (
        // Hold expired - use current target (release will start from held value)
        // The envelope is already at the held value, so release will naturally
        // start from there when it receives a smaller target
        target_gr_db;
      );
    );
  ) : (
    // Hold disabled - reset hold state and pass through target unchanged
    hold_counter_samples = 0;
    hold_target_gr_db = 0;
    target_gr_db;
  );
  
  target_gr_db;
);

//==============================================================================
// MAIN PROGRAM RELEASE SELECTOR
//==============================================================================

//--- Program-Dependent Release Coefficient Selection ---
// OPTIMIZATION: Pass pre-calculated abs(target_gr_db) to avoid redundant abs() call
function select_program_release_coef(target_gr_abs, detector_level_db) local(
  det_delta, input_level_db
) (
  debug_counter_prog_release += 1;

  // Cache release coefficients when timing or sample rate changes
  (cached_release_ms != release_ms || cached_srate_env != srate) ? (
    cached_release_ms = release_ms;
    cached_srate_env = srate;
    rel_mult = 0.5 + (release_ms / 2000.0) * 1.5;
    rel_fast_cached = exp(-1/(base_fast_s * rel_mult * srate));
    rel_med_cached  = exp(-1/(base_med_s  * rel_mult * srate));
    rel_slow_cached = exp(-1/(base_slow_s * rel_mult * srate));
  );

  // Initialize common variables used by strategy functions
  // OPTIMIZATION: Use passed-in pre-calculated abs value
  det_delta = prev_detector_db - detector_level_db;
  input_level_db = detector_level_db;

  // Dispatch to appropriate release strategy
  prog_release_type == 0 ? rel_med_cached :
  prog_release_type == 1 ? release_input_dependent_single(input_level_db) :
  prog_release_type == 2 ? release_gr_dependent(target_gr_abs) :
  prog_release_type == 3 ? release_rate_of_change(det_delta) :
  prog_release_type == 4 ? release_dual_threshold(input_level_db) :
  rel_med_cached  // Default fallback
);

//--- Single-Stage Envelope Following (modularized) ---
// OPTIMIZATION: Calculate abs(target_gr_db) once and reuse
function process_single_stage_envelope(target_gr_db, detector_level_db) local(target_gr_abs) (
  debug_counter_single_envelope += 1;

  // OPTIMIZATION: Calculate abs() once for reuse in comparison and release calculation
  target_gr_abs = abs(target_gr_db);

  global_attack_coef = attack_coeff;
  // Attack when target is "more extreme" than current (closer to zero = less extreme)
  target_gr_abs > abs(global_smoothed_gain_db) ? (
    global_smoothed_gain_db = global_attack_coef * global_smoothed_gain_db + (1 - global_attack_coef) * target_gr_db;
  ) : (
    prog_release_type > 0 ? (
      rel_coef_use = select_program_release_coef(target_gr_abs, detector_level_db);
      global_smoothed_gain_db = rel_coef_use * global_smoothed_gain_db + (1 - rel_coef_use) * target_gr_db;
    ) : (
      fixed_rel_coef = release_coeff;
      global_smoothed_gain_db = fixed_rel_coef * global_smoothed_gain_db + (1 - fixed_rel_coef) * target_gr_db;
    );
  );
  global_smoothed_gain_db;
);

//--- Main Envelope Following Function ---
function process_envelope_following(target_gr_db, detector_level_db) (
  // Debug counter: track envelope processing
  debug_counter_envelope += 1;
  
  // Process hold logic first - this modifies target_gr_db if hold is active
  target_gr_db = process_hold(target_gr_db);
  
  // Use traditional single-stage envelope with program release
  global_smoothed_gain_db = process_single_stage_envelope(target_gr_db, detector_level_db);
  
  global_smoothed_gain_db;
);

