// Envelope Processing Module
// Envelope following and program-dependent release algorithms

@init

//==============================================================================
// ENVELOPE STATE INITIALIZATION
//==============================================================================

function init_envelope_state() (
  // Hold state variables
  hold_counter_samples = 0;  // Counts down from hold_ms in samples
  hold_target_gr_db = 0;     // The held gain reduction value
  hold_baseline_gr_db = 0;   // Baseline gain reduction used to detect new holds
  
  // Global smoothed gain reduction (envelope follower output)
  global_smoothed_gain_db = 0;
  
  // Program release state
  base_fast_s = 0.05;  // 50ms
  base_med_s = 0.3;    // 300ms
  base_slow_s = 1.0;   // 1000ms
  
  // Min() envelope mode state variables (currently unused - may be for future feature)
  min_env_yR = 0;  // Release filter state
  min_env_yA = 0;  // Attack filter state
);

//==============================================================================
// CURVE SHAPING CONSTANTS
//==============================================================================

CURVE_CALIBRATION_DB = 10.0;
CURVE_FAST_MULTIPLIER = 1.5;
CURVE_SLOW_MULTIPLIER = 1.5;

curve_fast_coeff_cached = 0;
curve_slow_coeff_cached = 0;
rel_input_fast_cached = 0;

//==============================================================================
// ENVELOPE FOLLOWING AND PROGRAM RELEASE
//==============================================================================

//--- Helper: Clamp coefficient to [0, 1] range ---
function clamp_coeff(value) (
  max(0, min(1, value))
);

//--- Helper: Blend between two coefficients based on normalized weights ---
function blend_two_coefficients(coef1, coef2, blend_factor) (
  coef1 * (1 - blend_factor) + coef2 * blend_factor
);

//--- Helper: Normalized blend using fast/slow weights ---
function normalized_blend(blend_fast, blend_slow, coef_fast, coef_slow) local(sum) (
  sum = blend_fast + blend_slow;
  sum > EPS ? (
    (blend_fast * coef_fast + blend_slow * coef_slow) / sum
  ) : (
    coef_fast
  )
);

//--- Helper: Apply exponential smoothing envelope update ---
function apply_envelope_smoothing(coeff, target_value) (
  global_smoothed_gain_db = coeff * global_smoothed_gain_db + (1 - coeff) * target_value;
  global_smoothed_gain_db;
);

//==============================================================================
// PROGRAM RELEASE STRATEGIES (must be before curve shaping functions)
//==============================================================================

//--- Type 2: GR-Dependent ---
function release_gr_dependent(gr_amount) local(blend_fast, blend_slow) (
  blend_fast = clamp_coeff(1 - gr_amount / gr_blend_threshold_db);
  blend_slow = clamp_coeff(gr_amount / gr_blend_threshold_db);
  normalized_blend(blend_fast, blend_slow, rel_fast_cached, rel_slow_cached)
);

//==============================================================================
// CURVE SHAPING FUNCTIONS
//==============================================================================

//--- Helper: Blend curve-shaped coefficient with base coefficient ---
function blend_curve_with_base(curve_shape_factor, base_coeff, release_curve_is_positive) local(blended_coeff) (
  release_curve_is_positive ? (
    blended_coeff = blend_two_coefficients(curve_fast_coeff_cached, curve_slow_coeff_cached, curve_shape_factor)
  ) : (
    blended_coeff = blend_two_coefficients(curve_slow_coeff_cached, curve_fast_coeff_cached, curve_shape_factor)
  );
  clamp_coeff(blended_coeff)
);

//--- Helper: Apply curve amount blending to coefficient ---
function apply_curve_amount_blending(base_coeff, curve_shaped_coeff, curve_amount) local(curve_blend) (
  curve_blend = clamp_coeff(curve_amount / 2.0);
  blend_two_coefficients(base_coeff, curve_shaped_coeff, curve_blend)
);

//--- Calculate Curve-Shaped Release Coefficient for Regular Mode ---
// Modifies time constant based on distance from target GR
// Positive curves: slow when far, fast when close
// Negative curves: fast when far, slow when close
function calculate_curve_shaped_release_coeff(current_gr_db, target_gr_db, release_curve) local(
  distance, blend_factor, curve_amount, blended_coeff
) (
  abs(release_curve) < 0.001 ? (
    release_coeff
  ) : (
    distance = abs(current_gr_db - target_gr_db);
    blend_factor = min(1.0, distance / CURVE_CALIBRATION_DB);
    curve_amount = abs(release_curve);
    
    blended_coeff = blend_curve_with_base(blend_factor, release_coeff, release_curve > 0);
    apply_curve_amount_blending(release_coeff, blended_coeff, curve_amount)
  )
);

//--- Calculate GR-Dependent Curve Release Coefficient ---
// Uses GR threshold as inflection point in logistic/S-curve
// Positive curves: slow far from threshold (high GR), speed up approaching threshold, slow down approaching 0 GR
// Negative curves: fast far from threshold (high GR), slow down approaching threshold, speed up approaching 0 GR
function calculate_gr_dependent_curve_release_coeff(current_gr_abs, release_curve, gr_threshold) local(
  distance_from_threshold, normalized_pos, curve_shape, blended_coeff, curve_amount, base_gr_release
) (
  abs(release_curve) < 0.001 ? (
    release_gr_dependent(current_gr_abs)
  ) : (
    distance_from_threshold = abs(current_gr_abs - gr_threshold);
    
    gr_threshold > EPS ? (
      normalized_pos = min(2.0, distance_from_threshold / gr_threshold)
    ) : (
      normalized_pos = 0
    );
    
    release_curve > 0 ? (
      curve_shape = clamp_coeff((normalized_pos * 0.5) * (normalized_pos * 0.5))
    ) : (
      curve_shape = clamp_coeff(1.0 - (normalized_pos * 0.5) * (normalized_pos * 0.5))
    );
    
    blended_coeff = blend_curve_with_base(curve_shape, release_coeff, release_curve > 0);
    curve_amount = abs(release_curve);
    base_gr_release = release_gr_dependent(current_gr_abs);
    apply_curve_amount_blending(base_gr_release, blended_coeff, curve_amount)
  )
);

//==============================================================================
// PROGRAM RELEASE STRATEGIES (continued)
//==============================================================================

//--- Type 1: Input-Dependent (single threshold) ---
// Below threshold: fast release, above threshold: normal release
// Blend over 20 dB range: at threshold = 100% fast, 20 dB above = 100% normal
function release_input_dependent_single(input_level_db) local(level_above_threshold, blend_fast, blend_normal) (
  level_above_threshold = input_level_db - input_level_threshold_db;
  blend_fast = clamp_coeff(1 - level_above_threshold / 20);
  blend_normal = clamp_coeff(level_above_threshold / 20);
  normalized_blend(blend_fast, blend_normal, rel_input_fast_cached, release_coeff)
);

//--- Type 3: Rate-of-Change ---
function release_rate_of_change(det_delta) (
  det_delta > 3 ? rel_fast_cached : rel_slow_cached
);

//==============================================================================
// HOLD PROCESSING
//==============================================================================

//--- Process Hold Logic ---
// Holds the largest gain reduction target for the specified hold_ms
// Returns the effective target GR to use for envelope following
function process_hold(target_gr_db) local(
  target_gr_abs, hold_target_abs, hold_baseline_abs
) (
  hold_ms <= 0 ? (
    hold_counter_samples = 0;
    hold_target_gr_db = 0;
    hold_baseline_gr_db = 0;
  ) : (
    target_gr_abs = abs(target_gr_db);
    hold_target_abs = abs(hold_target_gr_db);
    hold_baseline_abs = abs(hold_baseline_gr_db);
    
    hold_counter_samples > 0 ? (
      target_gr_abs > hold_target_abs ? (
        hold_target_gr_db = target_gr_db;
        hold_target_abs = target_gr_abs;
        hold_counter_samples = hold_samples;
      );
      
      hold_counter_samples -= 1;
      hold_counter_samples = max(0, hold_counter_samples);
      target_gr_db = hold_target_gr_db;
      
      hold_counter_samples <= 0 ? (
        hold_baseline_gr_db = target_gr_db;
      );
    ) : (
      target_gr_abs > hold_baseline_abs ? (
        hold_target_gr_db = target_gr_db;
        hold_counter_samples = hold_samples;
        target_gr_db = hold_target_gr_db;
        hold_baseline_gr_db = hold_target_gr_db;
      ) : (
        hold_baseline_gr_db = target_gr_db;
        hold_target_gr_db = target_gr_db;
      );
    );
  );
  target_gr_db;
);

//==============================================================================
// MAIN PROGRAM RELEASE SELECTOR
//==============================================================================

//--- Program-Dependent Release Coefficient Selection ---
// For GR-dependent mode, current_gr_abs should be abs(global_smoothed_gain_db)
// NOTE: Cached coefficients are calculated in @slider in Composure.jsfx
function select_program_release_coef(target_gr_abs, detector_level_db, current_gr_abs) local(
  det_delta, input_level_db
) (
  debug_counter_prog_release += 1;

  det_delta = prev_detector_db - detector_level_db;
  input_level_db = detector_level_db;

  prog_release_type == 0 ? rel_med_cached :
  prog_release_type == 1 ? release_input_dependent_single(input_level_db) :
  prog_release_type == 2 ? release_gr_dependent(current_gr_abs) :
  prog_release_type == 3 ? release_rate_of_change(det_delta) :
  rel_med_cached
);

//--- Single-Stage Envelope Following ---
function process_single_stage_envelope(target_gr_db, detector_level_db) local(target_gr_abs, current_gr_abs, hysteresis_threshold) (
  debug_counter_single_envelope += 1;

  target_gr_abs = abs(target_gr_db);
  current_gr_abs = abs(global_smoothed_gain_db);

  // Hysteresis: prevent rapid oscillation between attack/release
  // Threshold scales with current GR to be more forgiving at higher compression levels
  hysteresis_threshold = max(0.1, current_gr_abs * 0.05);

  global_attack_coef = attack_coeff;
  target_gr_abs > (current_gr_abs + hysteresis_threshold) ? (
    apply_envelope_smoothing(global_attack_coef, target_gr_db);
  ) : (
    abs(release_curve) >= 0.001 ? (
      prog_release_type > 0 ? (
        prog_release_type == 2 ? (
          rel_coef_use = calculate_gr_dependent_curve_release_coeff(current_gr_abs, release_curve, gr_blend_threshold_db);
        ) : (
          base_rel_coef = select_program_release_coef(target_gr_abs, detector_level_db, current_gr_abs);
          rel_coef_use = calculate_curve_shaped_release_coeff(global_smoothed_gain_db, target_gr_db, release_curve);
          // TODO: Could blend between base_rel_coef and curve-shaped for more nuanced control
        );
        apply_envelope_smoothing(rel_coef_use, target_gr_db);
      ) : (
        fixed_rel_coef = calculate_curve_shaped_release_coeff(global_smoothed_gain_db, target_gr_db, release_curve);
        apply_envelope_smoothing(fixed_rel_coef, target_gr_db);
      );
    ) : (
      prog_release_type > 0 ? (
        rel_coef_use = select_program_release_coef(target_gr_abs, detector_level_db, current_gr_abs);
        apply_envelope_smoothing(rel_coef_use, target_gr_db);
      ) : (
        apply_envelope_smoothing(release_coeff, target_gr_db);
      );
    );
  );
  global_smoothed_gain_db;
);

//--- Main Envelope Following Function ---
function process_envelope_following(target_gr_db, detector_level_db) (
  debug_counter_envelope += 1;
  
  target_gr_db = process_hold(target_gr_db);
  global_smoothed_gain_db = process_single_stage_envelope(target_gr_db, detector_level_db);
  
  global_smoothed_gain_db;
);

