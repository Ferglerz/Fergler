// Envelope Release Module
// Release coefficient calculation and program-dependent release strategies
// Depends on: 00_envelope_utils.jsfx-inc

@init

//==============================================================================
// RELEASE COEFFICIENT UPDATE
//==============================================================================

function update_release_coefficient() (
  // Clamp release time to valid range
  release_ms = max(0.01, min(5000, release_ms));
  // Update cached sample rate calculations
  release_ms_srate = release_ms * srate;
  
  // Calculate release coefficient using standard time constant formula
  // Note: For valid release_ms values, exp() will never return 0 or 1, so no clamping needed here
  // The safety clamp in apply_envelope_smoothing() handles edge cases
  release_ms > 0 ? (
    release_coeff = exp(-1000 / (release_ms * srate));
  ) : (
    // Edge case: release_ms is 0 or invalid - use very fast but not instant to prevent clicks
    release_coeff = 1 - EPS;
  );
  
  // Cache program-dependent release coefficients (calculated when release_ms or srate changes)
  // These are used by program release modes and curve shaping functions
  // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
  rel_mult = 0.5 + (release_ms / 2000.0) * 1.5;
  rel_fast_cached = exp(-1/(base_fast_s * rel_mult * srate));
  rel_med_cached  = exp(-1/(base_med_s  * rel_mult * srate));
  rel_slow_cached = exp(-1/(base_slow_s * rel_mult * srate));
  
    // Cache curve shaping coefficients (only recalculate when release_ms or srate changes)
    // CURVE_FAST_MULTIPLIER and CURVE_SLOW_MULTIPLIER are defined in 00_envelope_utils.jsfx-inc
    // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
    release_ms > 0 ? (
      curve_fast_coeff_cached = exp(-1000 / ((release_ms / CURVE_FAST_MULTIPLIER) * srate));
      curve_slow_coeff_cached = exp(-1000 / ((release_ms * CURVE_SLOW_MULTIPLIER) * srate));
      
      // Cache input-dependent fast coefficient (4x faster than user's release setting)
      rel_input_fast_cached = exp(-1000 / ((release_ms * 0.25) * srate));
    ) : (
      // Edge case: release_ms is 0 or invalid - use very fast but not instant
      curve_fast_coeff_cached = 1 - EPS;
      curve_slow_coeff_cached = 1 - EPS;
      rel_input_fast_cached = 1 - EPS;
    );
);

//==============================================================================
// PROGRAM RELEASE STRATEGIES
//==============================================================================

//--- Type 2: GR-Dependent (single threshold - legacy) ---
function release_gr_dependent(gr_amount) local(blend_fast, blend_slow) (
  blend_fast = clamp_coeff(1 - gr_amount / gr_blend_threshold_reduction_db);
  blend_slow = clamp_coeff(gr_amount / gr_blend_threshold_reduction_db);
  // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
  normalized_blend(blend_fast, blend_slow, rel_fast_cached, rel_slow_cached)
);

//--- Type 2: GR-Dependent with separate thresholds for reduction and addition ---
// gr_amount: current GR amount (absolute value)
// is_negative_gr: true when GR is negative (reduction/cut, below 1:1), false when positive (addition/boost, above 1:1)
function release_gr_dependent_dual(gr_amount, is_negative_gr) local(blend_fast, blend_slow, threshold) (
  threshold = is_negative_gr ? gr_blend_threshold_reduction_db : gr_blend_threshold_addition_db;
  blend_fast = clamp_coeff(1 - gr_amount / threshold);
  blend_slow = clamp_coeff(gr_amount / threshold);
  // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
  normalized_blend(blend_fast, blend_slow, rel_fast_cached, rel_slow_cached)
);

//--- Type 1: Input-Dependent (single threshold) ---
// Below threshold: fast release, above threshold: normal release
// Blend over 20 dB range: at threshold = 100% fast, 20 dB above = 100% normal
function release_input_dependent_single(input_level_db) local(level_above_threshold, blend_fast, blend_normal) (
  level_above_threshold = input_level_db - input_level_threshold_db;
  blend_fast = clamp_coeff(1 - level_above_threshold / 20);
  blend_normal = clamp_coeff(level_above_threshold / 20);
  // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
  normalized_blend(blend_fast, blend_normal, rel_input_fast_cached, release_coeff)
);

//--- Type 3: Rate-of-Change ---
// det_delta: change in detector level (positive = level dropping, negative = level rising)
// Uses smooth blending based on sensitivity parameter for more noticeable effect
// rate_change_threshold_modifier: multiplier (0.5-4.0) that adjusts the depth of the effect
// Higher modifier (x4.0) = more depth (more effect), lower modifier (x0.5) = less depth (less effect)
// Base sensitivity is 10x: x4.0 multiplier = 40x effect, x0.5 multiplier = 5x effect
function release_rate_of_change(det_delta) local(blend_fast, blend_slow, normalized_delta, effective_sensitivity) (
  // Apply threshold modifier to sensitivity with 10x base sensitivity boost
  // Divide by (modifier * 10): higher modifier = lower effective sensitivity = more effect
  // x4.0 = divide by (4.0 * 10) = 1/40 sensitivity = 40x more effect
  // x0.5 = divide by (0.5 * 10) = 1/5 sensitivity = 5x more effect
  effective_sensitivity = rate_change_sensitivity_db / (rate_change_threshold_modifier * 10);
  
  // Normalize delta based on effective sensitivity (smaller sensitivity = more sensitive = more effect)
  // When level is dropping fast (positive det_delta), use fast release
  // When level is rising or dropping slowly, use slow release
  normalized_delta = det_delta / effective_sensitivity;
  
  // Smooth blend: at sensitivity threshold = 50% fast, at 2x sensitivity = 100% fast
  // Clamp to prevent overshoot
  normalized_delta = max(0, min(2.0, normalized_delta));
  blend_fast = clamp_coeff(normalized_delta * 0.5);
  blend_slow = clamp_coeff(1.0 - blend_fast);
  
  // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
  normalized_blend(blend_fast, blend_slow, rel_fast_cached, rel_slow_cached)
);

//--- Type 4: GR-Dependent Inverse ---
// Inverse of GR-dependent: high GR = slow release, low GR = fast release
// gr_amount: current GR amount (absolute value)
// is_negative_gr: true when GR is negative (reduction/cut, below 1:1), false when positive (addition/boost, above 1:1)
function release_gr_dependent_inverse_dual(gr_amount, is_negative_gr) local(blend_fast, blend_slow, threshold) (
  threshold = is_negative_gr ? gr_blend_threshold_reduction_db : gr_blend_threshold_addition_db;
  // Inverse: swap fast and slow blends
  blend_slow = clamp_coeff(1 - gr_amount / threshold);
  blend_fast = clamp_coeff(gr_amount / threshold);
  // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
  normalized_blend(blend_fast, blend_slow, rel_fast_cached, rel_slow_cached)
);

//--- Type 5: Input-Dependent Inverse ---
// Inverse of input-dependent: below threshold: slow release, above threshold: fast release
// Blend over 20 dB range: at threshold = 100% slow, 20 dB above = 100% fast
function release_input_dependent_inverse(input_level_db) local(level_above_threshold, blend_fast, blend_normal) (
  level_above_threshold = input_level_db - input_level_threshold_db;
  // Inverse: swap fast and normal blends
  blend_normal = clamp_coeff(1 - level_above_threshold / 20);
  blend_fast = clamp_coeff(level_above_threshold / 20);
  // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
  normalized_blend(blend_fast, blend_normal, rel_input_fast_cached, release_coeff)
);

//==============================================================================
// CURVE SHAPING FUNCTIONS
//==============================================================================

//--- Helper: Blend curve-shaped coefficient with base coefficient ---
function blend_curve_with_base(curve_shape_factor, base_coeff, release_curve_is_positive) local(blended_coeff) (
  release_curve_is_positive ? (
    blended_coeff = blend_two_coefficients(curve_fast_coeff_cached, curve_slow_coeff_cached, curve_shape_factor)
  ) : (
    blended_coeff = blend_two_coefficients(curve_slow_coeff_cached, curve_fast_coeff_cached, curve_shape_factor)
  );
  // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
  clamp_coeff(blended_coeff)
);

//--- Helper: Apply curve amount blending to coefficient ---
function apply_curve_amount_blending(base_coeff, curve_shaped_coeff, curve_amount) local(curve_blend) (
  curve_blend = clamp_coeff(curve_amount / 2.0);
  // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
  blend_two_coefficients(base_coeff, curve_shaped_coeff, curve_blend)
);

//--- Calculate Curve-Shaped Release Coefficient for Regular Mode ---
// Modifies time constant based on distance from target GR
// Positive curves: slow when far, fast when close
// Negative curves: fast when far, slow when close
// base_coeff: base coefficient to use instead of release_coeff (for program-dependent modes)
// Pass -1 to use default release_coeff
function calculate_curve_shaped_release_coeff(current_gr_db, target_gr_db, release_curve, base_coeff) local(
  distance, blend_factor, curve_amount, blended_coeff, base_to_use
) (
  abs(release_curve) < 0.001 ? (
    // No curve: return base coefficient (or release_coeff if -1 sentinel)
    base_coeff > 0 ? base_coeff : release_coeff
  ) : (
    // Use provided base_coeff if valid (> 0), otherwise use release_coeff
    base_to_use = base_coeff > 0 ? base_coeff : release_coeff;
    
    distance = abs(current_gr_db - target_gr_db);
    blend_factor = min(1.0, distance / CURVE_CALIBRATION_DB);
    curve_amount = abs(release_curve);
    
    blended_coeff = blend_curve_with_base(blend_factor, base_to_use, release_curve > 0);
    // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
    apply_curve_amount_blending(base_to_use, blended_coeff, curve_amount)
  )
);

//--- Calculate GR-Dependent Curve Release Coefficient ---
// Uses GR threshold as inflection point in logistic/S-curve
// Positive curves: slow far from threshold (high GR), speed up approaching threshold, slow down approaching 0 GR
// Negative curves: fast far from threshold (high GR), slow down approaching threshold, speed up approaching 0 GR
function calculate_gr_dependent_curve_release_coeff(current_gr_abs, release_curve, gr_threshold) local(
  distance_from_threshold, normalized_pos, curve_shape, blended_coeff, curve_amount, base_gr_release
) (
  abs(release_curve) < 0.001 ? (
    // No curve: use dual threshold function (is_reducing determined by caller context)
    // For backward compatibility, use reduction threshold as default
    release_gr_dependent(current_gr_abs)
  ) : (
    distance_from_threshold = abs(current_gr_abs - gr_threshold);
    
    gr_threshold > EPS ? (
      normalized_pos = min(2.0, distance_from_threshold / gr_threshold)
    ) : (
      normalized_pos = 0
    );
    
    release_curve > 0 ? (
      curve_shape = clamp_coeff((normalized_pos * 0.5) * (normalized_pos * 0.5))
    ) : (
      curve_shape = clamp_coeff(1.0 - (normalized_pos * 0.5) * (normalized_pos * 0.5))
    );
    
    blended_coeff = blend_curve_with_base(curve_shape, release_coeff, release_curve > 0);
    curve_amount = abs(release_curve);
    base_gr_release = release_gr_dependent(current_gr_abs);
    // Note: Safety clamp in apply_envelope_smoothing() handles edge cases
    apply_curve_amount_blending(base_gr_release, blended_coeff, curve_amount)
  )
);

//==============================================================================
// PROGRAM RELEASE SELECTOR
//==============================================================================

//--- Program-Dependent Release Coefficient Selection ---
// For GR-dependent mode, current_gr_abs should be abs(global_smoothed_gain_db)
// NOTE: Cached coefficients are calculated in @slider in Composure.jsfx
function select_program_release_coef(target_gr_abs, detector_level_db, current_gr_abs) local(
  det_delta, input_level_db
) (
  debug_counter_prog_release += 1;

  det_delta = prev_detector_db - detector_level_db;
  input_level_db = detector_level_db;

  prog_release_type == 0 ? release_coeff :
  prog_release_type == 1 ? release_input_dependent_single(input_level_db) :
  prog_release_type == 2 ? release_gr_dependent(current_gr_abs) :
  prog_release_type == 3 ? release_rate_of_change(det_delta) :
  prog_release_type == 4 ? release_gr_dependent(current_gr_abs) :  // Will use inverse in orchestration
  prog_release_type == 5 ? release_input_dependent_inverse(input_level_db) :
  release_coeff
);



