//==============================================================================
// AUDIO PROCESSING CHAIN FUNCTIONS
//==============================================================================
// Modular audio processing functions for the compressor
// Must be imported after utilities but before main processing

@init

//==============================================================================
// COMPLETE AUDIO PROCESSING CHAIN (INLINE OPTIMIZED)
//==============================================================================

function process_complete_audio_chain() (
  debug_counter_audio_chain += 1;

  input_l_orig = spl0;
  input_r_orig = spl1;
  has_stereo = (num_ch >= 2);
  has_sidechain_l = (use_sidechain && num_ch >= 3);
  has_sidechain_r = (use_sidechain && num_ch >= 4);

  // Detect on CURRENT input (not delayed) for lookahead to work
  detect_l = spl0;
  detect_r = spl1;

  stage_detection_source == 1 ? (
    detection_mode > 0.5 ? (
      detect_l = has_sidechain_l ? spl2 : spl0;
      detect_r = has_sidechain_r ? spl3 : (has_stereo ? spl1 : spl0);
    ) : (
      // FEEDBACK: Use previous sample's output (one-sample delay)
      detect_l = has_sidechain_l ? spl2 : final_l_prev;
      detect_r = has_sidechain_r ? spl3 : final_r_prev;
    );
  );

  (hp_filter_enabled || lp_filter_enabled) ? (
    apply_detection_filters(detect_l, detect_r);
    detect_l = filtered_l;
    detect_r = filtered_r;
  );

  should_listen = listen_to_sidechain && stage_detection_source == 1;
  should_listen ? (
    spl0 = detect_l;
    has_stereo ? spl1 = detect_r;
    // Update histogram tracking even in listen mode (for input histogram)
    detector_level = max(abs(detect_l), abs(detect_r));
    detector_level > detector_level_block_max ? (
      detector_level_block_max = detector_level;
    );
    // No gain reduction in listen mode
    gr_db_block_max = 0;
  ) : (
    stage_detection_analysis == 1 ? (
      detect_squared_l = detect_l * detect_l;
      detect_squared_r = detect_r * detect_r;
      
      // EXPONENTIAL SMOOTHING MODE: Coefficients pre-calculated in @block
      rms_size_ms > 0 ? (
        detect_squared = (detect_squared_l + detect_squared_r) * 0.5;
        rms_smoothed_squared = rms_smoothed_squared * rms_smoothing_coeff + detect_squared * rms_smoothing_one_minus;
        rms_level = sqrt(rms_smoothed_squared);
      ) : (
        rms_level = max(abs(detect_l), abs(detect_r));
      );

      rms_normalization > 0.5 ? (
        rms_level > rms_max ? (rms_max = rms_level) : (rms_max = rms_max * 0.9999);
        normalized_rms = rms_level / (rms_max + eps);
        peak_level = max(abs(detect_l), abs(detect_r));
        detector_level = normalized_rms * peak_level;
      ) : (
        rms_size_ms > 0 ? (
          detector_level = rms_level;
        ) : (
          detector_level = max(abs(detect_l), abs(detect_r));
        );
      );

      // OPTIMIZATION: Early exit using linear comparison (avoids expensive log())
      // Skip if: 1) below threshold, 2) no active release state
      can_skip_compression = (
        detector_level < comp_curve_min_threshold_linear &&
        global_smoothed_gain_db > -0.01 &&
        global_smoothed_gain_db < 0.01
      );
      
      can_skip_compression ? (
        target_gr_db = 0;
        gr_processing_skipped = 1;
      ) : (
        detector_level_db = linear_to_db(max(detector_level, MIN_DETECTOR_LEVEL));
        target_gr_db = calculate_gain_reduction_from_db(detector_level_db);
      );
      
      detector_level > detector_level_block_max ? (
        detector_level_block_max = detector_level;
      );
    );

    stage_envelope == 1 ? (
      // OPTIMIZATION: Skip envelope processing when both target and current are near zero
      can_skip_envelope = (
        abs(target_gr_db) < 0.01 &&
        abs(global_smoothed_gain_db) < 0.01
      );
      
      can_skip_envelope ? (
        global_smoothed_gain_db = 0;
      ) : (
        process_envelope_following(target_gr_db, detector_level_db);
      );
    );
    
    current_gr_db = stage_envelope == 1 ? global_smoothed_gain_db : target_gr_db;
    
    abs(current_gr_db) > abs(gr_db_block_max) ? (
      gr_db_block_max = current_gr_db;
    );

    // Cockos approach: Delay AUDIO, apply CURRENT gain to delayed audio
    // This lets the envelope "see" transients before they arrive
    lookahead_ms > 0 ? (
      process_lookahead_audio(input_l_orig, input_r_orig);
      audio_to_compress_l = lookahead_out_l;
      audio_to_compress_r = lookahead_out_r;
    ) : (
      audio_to_compress_l = input_l_orig;
      audio_to_compress_r = input_r_orig;
    );

    stage_gain_reduction == 1 ? (
      abs(current_gr_db) < 0.000001 ? (
        processed_l = audio_to_compress_l;
        processed_r = audio_to_compress_r;
      ) : (
        gain_reduction_linear = db_to_linear(current_gr_db);
        processed_l = audio_to_compress_l * gain_reduction_linear;
        processed_r = audio_to_compress_r * gain_reduction_linear;
      );
    ) : (
      processed_l = input_l_orig;
      processed_r = input_r_orig;
    );

    // OPTIMIZATION: Pre-calculate shared values once (not twice in L/R calls)
    harmonic_type > 0 && abs(target_gr_db) > 0.0001 ? (
      harmonic_envelope_amount = abs(global_smoothed_gain_db) / 30.0;
      harmonic_abs_gr = abs(target_gr_db);
      harmonic_gr_factor = harmonic_abs_gr * 0.3;
      harmonic_envelope_factor = 1 + harmonic_envelope_amount * 0.2;
      harmonic_combined_factor = harmonic_gr_factor * harmonic_envelope_factor;
      harmonic_even_factor = 1 + harmonic_even_boost;
      harmonic_odd_factor = 1 + harmonic_odd_boost;
      harmonic_amount = 1.0;
      harmonic_base_intensity = harmonic_amount * harmonic_abs_gr * 0.15;
      harmonic_intensity = harmonic_base_intensity * (1 + harmonic_envelope_amount * 0.2);
      
      processed_l = apply_harmonic_processing(processed_l, target_gr_db, harmonic_envelope_amount, detector_level,
                                             harmonic_type, harmonic_drive, harmonic_mix, 
                                             harmonic_even_boost, harmonic_odd_boost);
      processed_r = apply_harmonic_processing(processed_r, target_gr_db, harmonic_envelope_amount, detector_level,
                                             harmonic_type, harmonic_drive, harmonic_mix, 
                                             harmonic_even_boost, harmonic_odd_boost);
    );

    stage_final_mix == 1 ? (
      final_l = processed_l * makeup_gain_linear;
      final_r = processed_r * makeup_gain_linear;
      final_out_l = final_l;
      final_out_r = final_r;
    );

    brickwall_limiter > 0.5 ? (
      // OPTIMIZATION: Calculate abs() once and check both (avoids max() call)
      // Only process when output is -0.5dB or higher (0.944)
      abs_final_l = abs(final_l);
      abs_final_r = abs(final_r);
      (abs_final_l > 0.944 || abs_final_r > 0.944) ? (
        final_l = soft_clip_limiter(final_l, limiter_prev_l);
        final_r = soft_clip_limiter(final_r, limiter_prev_r);
      );
      limiter_prev_l = final_l;
      limiter_prev_r = final_r;
    );

    spl0 = final_l;
    spl1 = final_r;
    final_l_prev = final_l;
    final_r_prev = final_r;
  );
  
  debug_counter_samples += 1;
  debug_counter_samples >= debug_counter_reset_interval ? (
    debug_display_audio_chain = debug_counter_audio_chain;
    debug_display_gain_reduction = debug_counter_gain_reduction;
    debug_display_envelope = debug_counter_envelope;
    debug_display_min_envelope = debug_counter_min_envelope;
    debug_display_lookahead = debug_counter_lookahead;
    debug_display_harmonics = debug_counter_harmonics;
    debug_display_limiter = debug_counter_limiter;
    debug_display_curve_interp = debug_counter_curve_interp;
    debug_display_lut_lookup = debug_counter_lut_lookup;
    debug_display_db_to_linear = debug_counter_db_to_linear;
    debug_display_linear_to_db = debug_counter_linear_to_db;
    debug_display_clamp = debug_counter_clamp;
    debug_display_prog_release = debug_counter_prog_release;
    debug_display_single_envelope = debug_counter_single_envelope;
    debug_display_ui_curves = debug_counter_ui_curves;
    debug_display_ui_histogram = debug_counter_ui_histogram;
    debug_display_graph_bg = debug_counter_graph_bg;
    debug_display_grid = debug_counter_grid;
    
    debug_counter_audio_chain = 0;
    debug_counter_gain_reduction = 0;
    debug_counter_envelope = 0;
    debug_counter_min_envelope = 0;
    debug_counter_lookahead = 0;
    debug_counter_harmonics = 0;
    debug_counter_limiter = 0;
    debug_counter_curve_interp = 0;
    debug_counter_lut_lookup = 0;
    debug_counter_db_to_linear = 0;
    debug_counter_linear_to_db = 0;
    debug_counter_clamp = 0;
    debug_counter_prog_release = 0;
    debug_counter_single_envelope = 0;
    debug_counter_ui_curves = 0;
    debug_counter_ui_histogram = 0;
    debug_counter_graph_bg = 0;
    debug_counter_grid = 0;
    debug_counter_samples = 0;
  );
);
