// Compression Core Module
// Basic gain reduction calculation, core compression logic, and compression curve interpolation
// Dependencies: Utils/constants.jsfx-inc, Utils/math_utils.jsfx-inc, Compression/compression_constants.jsfx-inc, Compression/graph_data_core.jsfx-inc

@init

compression_init_complete = 0;

//==============================================================================
// COMPRESSION LOOKUP TABLE
//==============================================================================

comp_lut_dirty = 1;

function build_compression_lut() (
  !compression_init_complete ? (
    0;
  ) : (
    // CRITICAL: Ensure curve segments are generated first (single source of truth)
    curve_segments_db_dirty ? generate_curve_segments_db();
  
    i = 0;
    while (i < COMP_LUT_SIZE) (
      input_db = COMP_LUT_MIN_DB + (i * COMP_LUT_GRANULARITY);
      comp_lut[i] = sample_curve_at_db(input_db);
      i += 1;
    );
  
    comp_curve_threshold_dirty ? calculate_compression_threshold();
    comp_lut_dirty = 0;
  );
);

function lookup_compression_lut(input_db) (
  debug_counter_lut_lookup += 1;
  comp_lut_dirty ? build_compression_lut();
  
  input_db < COMP_LUT_MIN_DB ? (
    output_db = comp_lut[0]
  ) : input_db > COMP_LUT_MAX_DB ? (
    output_db = comp_lut[COMP_LUT_SIZE - 1]
  ) : (
    index_float = (input_db - COMP_LUT_MIN_DB) / COMP_LUT_GRANULARITY;
    index_int = max(0, min(COMP_LUT_SIZE - 2, floor(index_float)));
    index_frac = index_float - index_int;
    value1 = comp_lut[index_int];
    value2 = comp_lut[index_int + 1];
    output_db = value1 + index_frac * (value2 - value1)
  );
  
  // Clamp below minimum graph point: allow tangent to continue, but prevent boosts
  // This matches sample_curve_at_db() behavior
  input_db < GRAPH_MIN_DB ? (
    // Allow tangent to continue (output_db already extends the tangent from LUT)
    // But clamp to 1:1 max to prevent gain boosts
    min(output_db, input_db)
  ) : (
    // Clamp above maximum graph point: maintain Y value at GRAPH_MAX_DB
    // This prevents huge gains from angled top-right point
    input_db > GRAPH_MAX_DB ? (
      max_graph_idx = floor((GRAPH_MAX_DB - COMP_LUT_MIN_DB) / COMP_LUT_GRANULARITY);
      max_graph_idx = max(0, min(COMP_LUT_SIZE - 1, max_graph_idx));
      comp_lut[max_graph_idx]
    ) : (
      output_db
    )
  )
);

function invalidate_compression_lut() (
  comp_lut_dirty = 1;
);

//==============================================================================
// CURVE CACHE MANAGEMENT
//==============================================================================

// Function to mark curve cache as dirty (call when parameters change)
function invalidate_curve_cache() (
  curve_cache_dirty = 1;
  curve_segments_db_dirty = 1; // Invalidate dB curve (single source of truth)
  comp_lut_dirty = 1; // Invalidate compression LUT - must rebuild from new curve!
  lut_viz_cache_dirty = 1; // Also invalidate LUT visualization cache
);
