// Graph Data Core Module
// Graph point data management and point manipulation
// Depends on: 00a_constants.jsfx-inc, 00b_math_utils.jsfx-inc, 02d_ui_utils.jsfx-inc

@init

//==============================================================================
// GRAPH CONFIGURATION
//==============================================================================

// Graph layout and behavior (GRAPH_X, GRAPH_Y, GRAPH_SIZE defined in 05_ui_core.jsfx-inc)
GRAPH_RANGE_DB = 80; // -80 to 0
GRAPH_MIN_DB = -80;
GRAPH_MAX_DB = 0;

// Pre-calculated constants for coordinate conversion (optimization)
// These eliminate repeated divisions in coordinate conversion functions
// NOTE: These must be calculated AFTER GRAPH_SIZE/GRAPH_X/GRAPH_Y are defined
// Call init_graph_optimization_constants() from main @init after all imports
DB_TO_PIXEL_SCALE = 0;  // Will be: GRAPH_SIZE / GRAPH_RANGE_DB = 3.2875 pixels per dB
PIXEL_TO_DB_SCALE = 0;  // Will be: GRAPH_RANGE_DB / GRAPH_SIZE = 0.304... dB per pixel

// Pre-calculated offsets for histogram rendering (optimization)
HISTOGRAM_Y_OFFSET = 0;  // Will be: GRAPH_Y + GRAPH_SIZE + GRAPH_MIN_DB * DB_TO_PIXEL_SCALE
HISTOGRAM_X_OFFSET = 0;  // Will be: GRAPH_X - GRAPH_MIN_DB * DB_TO_PIXEL_SCALE

// GR histogram scale (40dB range for gain reduction display)
GR_PIXELS_PER_DB = 0;  // Will be: GRAPH_SIZE / 40

// Function to initialize optimization constants after GRAPH_SIZE is available
function init_graph_optimization_constants() (
  DB_TO_PIXEL_SCALE = GRAPH_SIZE / GRAPH_RANGE_DB;
  PIXEL_TO_DB_SCALE = GRAPH_RANGE_DB / GRAPH_SIZE;
  HISTOGRAM_Y_OFFSET = GRAPH_Y + GRAPH_SIZE + GRAPH_MIN_DB * DB_TO_PIXEL_SCALE;
  HISTOGRAM_X_OFFSET = GRAPH_X - GRAPH_MIN_DB * DB_TO_PIXEL_SCALE;
  GR_PIXELS_PER_DB = GRAPH_SIZE / 40;
);

// Point management
MIN_POINTS = 4;
MAX_POINTS = 12;
MOUSE_CLICK_RADIUS = 10;

// Optimization: Cache leftmost non-1:1 point for early exit
comp_curve_min_threshold_db = GRAPH_MAX_DB + 10;  // Threshold below which no compression occurs (default: no compression)
comp_curve_min_threshold_linear = 1.0;  // Threshold in linear domain (calculated from dB)
comp_curve_threshold_dirty = 1;  // Flag to recalculate threshold

// Graph state - these need to persist across @init calls
// Use a special flag to track if these have been initialized
!persistent_vars_initialized ? (
  num_points = 6;
  selected_point = -1;
  hovered_point = -1;
  mouse_down = 0;
  mouse_x_prev = 0;
  mouse_y_prev = 0;
  
  // Curve adjustment state
  curve_drag_started = 0;
  curve_drag_start_x = 0;
  curve_drag_start_y = 0;
  
  graph_initialized = 0;
  persistent_vars_initialized = 1;
  
  // Curve data - track which points have curves and their amounts (0-100%)
  // curve_amounts[i] = 0 means point i has no curve, > 0 means curved with that percentage
  curve_amounts = 0; // Will be allocated in memory
  curve_mode = 0; // 0 = normal mode, 1 = curve mode
);

//==============================================================================
// COORDINATE CONVERSION FUNCTIONS
//==============================================================================

// Convert between dB values and graph screen coordinates
// These functions depend on GRAPH constants defined above and in UI constants
// Optimized to use pre-calculated scale factors (eliminates divisions)

function db_to_graph_x(db) (
  GRAPH_X + (db - GRAPH_MIN_DB) * DB_TO_PIXEL_SCALE
);

function db_to_graph_y(db) (
  GRAPH_Y + GRAPH_SIZE - (db - GRAPH_MIN_DB) * DB_TO_PIXEL_SCALE
);

function graph_x_to_db(x) (
  (x - GRAPH_X) * PIXEL_TO_DB_SCALE + GRAPH_MIN_DB
);

function graph_y_to_db(y) (
  GRAPH_MAX_DB - (y - GRAPH_Y) * PIXEL_TO_DB_SCALE
);

function is_point_in_graph(x, y) (
  x >= GRAPH_X && x <= GRAPH_X + GRAPH_SIZE &&
  y >= GRAPH_Y && y <= GRAPH_Y + GRAPH_SIZE
);

//==============================================================================
// CURVE DATA MANAGEMENT
//==============================================================================

function init_curve_data() (
  // Memory allocation now handled in 01a_memory.jsfx-inc
  // Just initialize all curves to 0 (no curves)
  i = 0;
  while (i < MAX_POINTS) (
    curve_amounts[i] = 0;
    i += 1;
  );
);

function get_curve_amount(point_index) (
  point_index >= 0 && point_index < MAX_POINTS ? curve_amounts[point_index] : 0;
);

function set_curve_amount(point_index, amount) (
  point_index >= 0 && point_index < MAX_POINTS ? (
    curve_amounts[point_index] = clamp(amount, 0, 100);
  );
);

function has_curve(point_index) (
  get_curve_amount(point_index) > 0;
);

function clear_all_curves() (
  i = 0;
  while (i < MAX_POINTS) (
    curve_amounts[i] = 0;
    i += 1;
  );
);

//==============================================================================
// GRAPH DATA MANAGEMENT
//==============================================================================

function init_graph_points() (
  // Initialize points on diagonal line (1:1 compression)
  graph_points[0] = GRAPH_MIN_DB; graph_points[1] = GRAPH_MIN_DB;
  graph_points[2] = -60; graph_points[3] = -60;
  graph_points[4] = -40; graph_points[5] = -40;
  graph_points[6] = -20; graph_points[7] = -20;
  graph_points[8] = -10; graph_points[9] = -10;
  graph_points[10] = GRAPH_MAX_DB; graph_points[11] = GRAPH_MAX_DB;
);

function sort_points() (
  i = 1;
  while (i < num_points - 2) (
    j = i + 1;
    while (j < num_points - 1) (
      graph_points[i*2] > graph_points[j*2] ? (
        temp_in = graph_points[i*2];
        temp_out = graph_points[i*2 + 1];
        temp_curve = curve_amounts[i];

        graph_points[i*2] = graph_points[j*2];
        graph_points[i*2 + 1] = graph_points[j*2 + 1];
        curve_amounts[i] = curve_amounts[j];

        graph_points[j*2] = temp_in;
        graph_points[j*2 + 1] = temp_out;
        curve_amounts[j] = temp_curve;
      );
      j += 1;
    );
    i += 1;
  );
);

function add_point(input_db, output_db) (
  num_points >= MAX_POINTS ? -1 : (
    // Find the correct insertion position based on input_db value
    insert_pos = num_points - 1; // Default to before last corner point
    i = 1;
    while (i < num_points - 1) (
      graph_points[i*2] > input_db ? (
        insert_pos = i;
        i = num_points; // break
      ) : (
        i += 1;
      );
    );

    i = num_points;
    while (i > insert_pos) (
      graph_points[i*2] = graph_points[(i-1)*2];
      graph_points[i*2 + 1] = graph_points[(i-1)*2 + 1];
      // Shift curve amounts up as well
      curve_amounts[i] = curve_amounts[i-1];
      i -= 1;
    );

    graph_points[insert_pos*2] = input_db;
    graph_points[insert_pos*2 + 1] = output_db;
    // New points start with no curve
    curve_amounts[insert_pos] = 0;

    num_points += 1;
    // No need to sort since we inserted in the correct position
    // Return the insertion position as the new point index
    insert_pos;
  );
);

function delete_point(point_index) (
  point_index <= 0 || point_index >= num_points - 1 || num_points <= MIN_POINTS ? 0 : (
    i = point_index;
    while (i < num_points - 1) (
      graph_points[i*2] = graph_points[(i+1)*2];
      graph_points[i*2 + 1] = graph_points[(i+1)*2 + 1];
      // Shift curve amounts down as well
      curve_amounts[i] = curve_amounts[i+1];
      i += 1;
    );
    // Clear the curve amount for the last point
    curve_amounts[num_points - 1] = 0;
    num_points -= 1;
    1;
  );
);

function remove_displaced_points(moved_input_db, moved_output_db) (
  // Count how many points are at approximately the same position as the moved point
  same_position_count = 0;
  i = 1;
  while (i < num_points - 1) (
    abs(graph_points[i*2] - moved_input_db) < 2.0 && abs(graph_points[i*2 + 1] - moved_output_db) < 2.0 ? (
      same_position_count += 1;
    );
    i += 1;
  );

  // If more than 2 points are at the same position, remove the extras
  same_position_count > 2 ? (
    points_to_remove = same_position_count - 2;
    removal_count = 0;

    // Remove points from the end backwards to avoid index shifting issues
    i = num_points - 2; // Start from last non-corner point
    while (i > 0 && removal_count < points_to_remove && num_points > MIN_POINTS) (
      abs(graph_points[i*2] - moved_input_db) < 2.0 && abs(graph_points[i*2 + 1] - moved_output_db) < 2.0 ? (
        delete_point(i);
        removal_count += 1;
        i -= 1; // Adjust index after deletion
      ) : (
        i -= 1;
      );
    );
  );
);

function find_point_at_mouse(x, y) (
  // Skip corner points (indices 0 and num_points-1) - they are invisible and non-interactive
  found_point = -1;
  i = 1;
  while (i < num_points - 1) (
    point_x = db_to_graph_x(graph_points[i*2]);
    point_y = db_to_graph_y(graph_points[i*2 + 1]);
    dist_sq = (x - point_x) * (x - point_x) + (y - point_y) * (y - point_y);

    dist_sq < MOUSE_CLICK_RADIUS * MOUSE_CLICK_RADIUS ? (
      found_point = i;
      i = num_points; // Break out of loop
    ) : (
      i += 1;
    );
  );
  found_point;
);

//==============================================================================
// COMPRESSION THRESHOLD OPTIMIZATION
//==============================================================================

function calculate_compression_threshold() (
  // Find the leftmost point where compression actually occurs (input != output)
  // This lets us skip compression calculations when input is below this threshold
  // Note: Global offset is NOT factored in here - it's applied when checking the threshold
  
  // Default: assume no compression anywhere (set threshold very high)
  comp_curve_min_threshold_db = GRAPH_MAX_DB + 10;  // Higher than any possible input
  
  // Scan from left to right to find first non-1:1 point
  i = 1;  // Skip first corner point (index 0)
  while (i < num_points - 1) (
    input_db = graph_points[i*2];
    output_db = graph_points[i*2 + 1];
    
    // Check if this point deviates from 1:1 (with small tolerance for floating point)
    abs(input_db - output_db) > 0.01 ? (
      // Found the first compression point!
      // The threshold should be the PREVIOUS point (last 1:1 point before compression starts)
      i > 1 ? (
        // Use the previous point's input value
        comp_curve_min_threshold_db = graph_points[(i-1)*2];
      ) : (
        // First movable point is already compressing, use the corner point
        comp_curve_min_threshold_db = graph_points[0];  // GRAPH_MIN_DB (-80)
      );
      i = num_points;  // Break out of loop
    ) : (
      i += 1;
    );
  );
  
  // Convert threshold to linear domain ONCE (used for fast early exit checks in @sample)
  // This avoids expensive log() conversion every sample
  comp_curve_min_threshold_linear = db_to_linear(comp_curve_min_threshold_db);
  
  comp_curve_threshold_dirty = 0;
);

function invalidate_compression_threshold() (
  comp_curve_threshold_dirty = 1;
);

