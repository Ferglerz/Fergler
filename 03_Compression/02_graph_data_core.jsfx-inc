// Graph Data Core Module
// Graph point data management and point manipulation
// Depends on: 
//   - 01_Utils/01_constants.jsfx-inc
//   - 01_Utils/02_math_utils.jsfx-inc

@init

//==============================================================================
// GRAPH CONFIGURATION
//==============================================================================

GRAPH_RANGE_DB = 20;
GRAPH_MIN_DB = -20;
GRAPH_MAX_DB = 0;

MIN_POINTS = 4;
MAX_POINTS = 12;
MOUSE_CLICK_RADIUS = 10;

// Optimization: Cache leftmost non-1:1 point for early exit
comp_curve_min_threshold_db = GRAPH_MAX_DB + 10;
comp_curve_min_threshold_linear = 1.0;
comp_curve_threshold_dirty = 1;

// Graph state - persist across @init calls
!persistent_vars_initialized ? (
  num_points = 6;
  selected_point = -1;
  hovered_point = -1;
  mouse_down = 0;
  mouse_x_prev = 0;
  mouse_y_prev = 0;
  curve_drag_started = 0;
  curve_drag_start_x = 0;
  curve_drag_start_y = 0;
  graph_initialized = 0;
  persistent_vars_initialized = 1;
  // curve_amounts[i] = 0 means no curve, > 0 means curved with that percentage
  curve_amounts = 0;
  curve_mode = 0;
);

//==============================================================================
// CURVE DATA MANAGEMENT
//==============================================================================

function init_curve_data() (
  i = 0;
  while (i < MAX_POINTS) (
    curve_amounts[i] = 0;
    i += 1;
  );
);

function get_curve_amount(point_index) (
  point_index >= 0 && point_index < MAX_POINTS ? curve_amounts[point_index] : 0;
);

function set_curve_amount(point_index, amount) (
  point_index >= 0 && point_index < MAX_POINTS ? (
    curve_amounts[point_index] = clamp(amount, 0, 100);
  );
);

//==============================================================================
// DYNAMIC CORNER POINTS (TANGENT EXTENSION)
//==============================================================================

// Extends corner points as tangents from outermost user points
// Left: Stays on bottom edge (Y=-80), X adjusts to follow tangent
// Right: Stays on right edge (X=0), Y adjusts to follow tangent
function update_corner_points() (
  // LEFT CORNER (index 0) - Extends along bottom edge
  num_points >= 3 ? (
    p1_x = graph_points[2];
    p1_y = graph_points[3];
    p2_x = graph_points[4];
    p2_y = graph_points[5];
    
    dx = p2_x - p1_x;
    abs(dx) > 0.001 ? (
      slope = (p2_y - p1_y) / dx;
      
      // If first point above second, tangent can't reach Y=-80 going left
      p1_y > p2_y ? (
        graph_points[0] = GRAPH_MIN_DB;
        graph_points[1] = GRAPH_MIN_DB;
      ) : (
        graph_points[1] = GRAPH_MIN_DB;
        graph_points[0] = p1_x + (GRAPH_MIN_DB - p1_y) / slope;
        
        // If X goes right of -80, clamp X and adjust Y
        graph_points[0] > GRAPH_MIN_DB ? (
          graph_points[0] = GRAPH_MIN_DB;
          graph_points[1] = p1_y + slope * (GRAPH_MIN_DB - p1_x);
        );
      );
    ) : (
      graph_points[0] = GRAPH_MIN_DB;
      graph_points[1] = GRAPH_MIN_DB;
    );
  ) : (
    graph_points[0] = GRAPH_MIN_DB;
    graph_points[1] = GRAPH_MIN_DB;
  );
  
  // RIGHT CORNER (index num_points-1) - Extends along right edge
  num_points >= 3 ? (
    last_idx = num_points - 1;
    p1_x = graph_points[(last_idx - 2) * 2];
    p1_y = graph_points[(last_idx - 2) * 2 + 1];
    p2_x = graph_points[(last_idx - 1) * 2];
    p2_y = graph_points[(last_idx - 1) * 2 + 1];
    
    dx = p2_x - p1_x;
    abs(dx) > 0.001 ? (
      slope = (p2_y - p1_y) / dx;
      graph_points[last_idx * 2] = GRAPH_MAX_DB;
      graph_points[last_idx * 2 + 1] = p2_y + slope * (GRAPH_MAX_DB - p2_x);
    ) : (
      graph_points[last_idx * 2] = GRAPH_MAX_DB;
      graph_points[last_idx * 2 + 1] = p2_y;
    );
  ) : (
    last_idx = num_points - 1;
    graph_points[last_idx * 2] = GRAPH_MAX_DB;
    graph_points[last_idx * 2 + 1] = GRAPH_MAX_DB;
  );
);

//==============================================================================
// GRAPH DATA MANAGEMENT
//==============================================================================

function init_graph_points() (
  // Corner points at graph boundaries
  graph_points[0] = GRAPH_MIN_DB; graph_points[1] = GRAPH_MIN_DB;
  graph_points[10] = GRAPH_MAX_DB; graph_points[11] = GRAPH_MAX_DB;
  
  // Intermediate points distributed across the graph range (20%, 40%, 60%, 80% of range)
  // These are calculated relative to GRAPH_MIN_DB so they adapt to any range change
  graph_points[2] = GRAPH_MIN_DB + (GRAPH_RANGE_DB * 0.2); graph_points[3] = graph_points[2];
  graph_points[4] = GRAPH_MIN_DB + (GRAPH_RANGE_DB * 0.4); graph_points[5] = graph_points[4];
  graph_points[6] = GRAPH_MIN_DB + (GRAPH_RANGE_DB * 0.6); graph_points[7] = graph_points[6];
  graph_points[8] = GRAPH_MIN_DB + (GRAPH_RANGE_DB * 0.8); graph_points[9] = graph_points[8];
  
  update_corner_points();
);

function sort_points() (
  i = 1;
  while (i < num_points - 2) (
    j = i + 1;
    while (j < num_points - 1) (
      graph_points[i*2] > graph_points[j*2] ? (
        temp_in = graph_points[i*2];
        temp_out = graph_points[i*2 + 1];
        temp_curve = curve_amounts[i];

        graph_points[i*2] = graph_points[j*2];
        graph_points[i*2 + 1] = graph_points[j*2 + 1];
        curve_amounts[i] = curve_amounts[j];

        graph_points[j*2] = temp_in;
        graph_points[j*2 + 1] = temp_out;
        curve_amounts[j] = temp_curve;
      );
      j += 1;
    );
    i += 1;
  );
  update_corner_points();
);

function add_point(input_db, output_db) (
  num_points >= MAX_POINTS ? -1 : (
    insert_pos = num_points - 1;
    i = 1;
    while (i < num_points - 1) (
      graph_points[i*2] > input_db ? (
        insert_pos = i;
        i = num_points;
      ) : (
        i += 1;
      );
    );

    i = num_points;
    while (i > insert_pos) (
      graph_points[i*2] = graph_points[(i-1)*2];
      graph_points[i*2 + 1] = graph_points[(i-1)*2 + 1];
      curve_amounts[i] = curve_amounts[i-1];
      i -= 1;
    );

    graph_points[insert_pos*2] = input_db;
    graph_points[insert_pos*2 + 1] = output_db;
    curve_amounts[insert_pos] = 0;
    num_points += 1;
    update_corner_points();
    insert_pos;
  );
);

function delete_point(point_index) (
  point_index <= 0 || point_index >= num_points - 1 || num_points <= MIN_POINTS ? 0 : (
    i = point_index;
    while (i < num_points - 1) (
      graph_points[i*2] = graph_points[(i+1)*2];
      graph_points[i*2 + 1] = graph_points[(i+1)*2 + 1];
      curve_amounts[i] = curve_amounts[i+1];
      i += 1;
    );
    curve_amounts[num_points - 1] = 0;
    num_points -= 1;
    update_corner_points();
    1;
  );
);

function remove_displaced_points(moved_input_db, moved_output_db) (
  same_position_count = 0;
  i = 1;
  while (i < num_points - 1) (
    abs(graph_points[i*2] - moved_input_db) < 2.0 && abs(graph_points[i*2 + 1] - moved_output_db) < 2.0 ? (
      same_position_count += 1;
    );
    i += 1;
  );

  same_position_count > 2 ? (
    points_to_remove = same_position_count - 2;
    removal_count = 0;
    // Remove from end backwards to avoid index shifting issues
    i = num_points - 2;
    while (i > 0 && removal_count < points_to_remove && num_points > MIN_POINTS) (
      abs(graph_points[i*2] - moved_input_db) < 2.0 && abs(graph_points[i*2 + 1] - moved_output_db) < 2.0 ? (
        delete_point(i);
        removal_count += 1;
        i -= 1;
      ) : (
        i -= 1;
      );
    );
  );
);

//==============================================================================
// COMPRESSION THRESHOLD OPTIMIZATION
//==============================================================================

function calculate_compression_threshold() (
  // Find leftmost point where compression occurs (input != output) for early exit optimization
  // Note: Input offset is NOT factored in here - applied when checking threshold
  comp_curve_min_threshold_db = GRAPH_MAX_DB + 10;
  
  i = 1;
  while (i < num_points - 1) (
    input_db = graph_points[i*2];
    output_db = graph_points[i*2 + 1];
    
    abs(input_db - output_db) > 0.01 ? (
      // Threshold is PREVIOUS point (last 1:1 point before compression starts)
      i > 1 ? (
        comp_curve_min_threshold_db = graph_points[(i-1)*2];
      ) : (
        comp_curve_min_threshold_db = graph_points[0];
      );
      i = num_points;
    ) : (
      i += 1;
    );
  );
  
  // Convert to linear domain ONCE (avoids expensive log() conversion every sample)
  comp_curve_min_threshold_linear = db_to_linear(comp_curve_min_threshold_db);
  comp_curve_threshold_dirty = 0;
);

function invalidate_compression_threshold() (
  comp_curve_threshold_dirty = 1;
);

