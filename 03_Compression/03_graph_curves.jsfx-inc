// Graph Curves Module
// Bezier curve calculations for smooth curve rendering

@init

//==============================================================================
// CURVE GENERATION CONSTANTS
//==============================================================================

BEZIER_STEPS = 20;
MAX_CURVE_SEGMENTS = 500;

curve_segments_db = 0;
curve_segments_db_allocated = 0;
curve_segments_db_count = 0;
curve_segments_db_dirty = 1;

//==============================================================================
// HELPER FUNCTIONS
//==============================================================================

// Get point coordinates from graph_points array
function get_point_x(point_idx) (
  graph_points[point_idx * 2]
);

function get_point_y(point_idx) (
  graph_points[point_idx * 2 + 1]
);

// Check if point index is valid for curve calculations
function is_valid_curve_point(point_idx) (
  point_idx > 0 && point_idx < (num_points - 1)
);

// Store segment in curve_segments_db array
function store_segment(seg_idx, x1, y1, x2, y2) (
  curve_segments_db[seg_idx * 4 + 0] = x1;
  curve_segments_db[seg_idx * 4 + 1] = y1;
  curve_segments_db[seg_idx * 4 + 2] = x2;
  curve_segments_db[seg_idx * 4 + 3] = y2
);

// Calculate Bezier basis coefficients (u, uu, uuu, tt, ttt)
function calculate_bezier_coeffs(t) local(u) (
  u = 1 - t;
  bezier_u = u;
  bezier_uu = u * u;
  bezier_uuu = bezier_uu * u;
  bezier_tt = t * t;
  bezier_ttt = bezier_tt * t
);

// Evaluate cubic Bezier curve at parameter t
function evaluate_bezier_at_t(t, p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y) local(result_x, result_y) (
  calculate_bezier_coeffs(t);
  result_x = bezier_uuu * p0_x + 3 * bezier_uu * t * p1_x + 3 * bezier_u * bezier_tt * p2_x + bezier_ttt * p3_x;
  result_y = bezier_uuu * p0_y + 3 * bezier_uu * t * p1_y + 3 * bezier_u * bezier_tt * p2_y + bezier_ttt * p3_y;
  bezier_result_x = result_x;
  bezier_result_y = result_y
);

//==============================================================================
// BEZIER CURVE CALCULATIONS
//==============================================================================

function calculate_bezier_control_points(point_index, curve_amount) (
  prev_point_x = get_point_x(point_index - 1);
  prev_point_y = get_point_y(point_index - 1);
  curr_point_x = get_point_x(point_index);
  curr_point_y = get_point_y(point_index);
  next_point_x = get_point_x(point_index + 1);
  next_point_y = get_point_y(point_index + 1);
  
  curve_factor = curve_amount / 100.0;
  
  invisible1_x = curr_point_x + (prev_point_x - curr_point_x) * curve_factor;
  invisible1_y = curr_point_y + (prev_point_y - curr_point_y) * curve_factor;
  invisible2_x = curr_point_x + (next_point_x - curr_point_x) * curve_factor;
  invisible2_y = curr_point_y + (next_point_y - curr_point_y) * curve_factor;
  
  bezier_p0_x = invisible1_x;
  bezier_p0_y = invisible1_y;
  bezier_control1_x = curr_point_x;
  bezier_control1_y = curr_point_y;
  bezier_control2_x = curr_point_x;
  bezier_control2_y = curr_point_y;
  bezier_p3_x = invisible2_x;
  bezier_p3_y = invisible2_y;
);

function evaluate_bezier_curve(t, p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y) (
  evaluate_bezier_at_t(t, p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y);
);

//==============================================================================
// CURVE SEGMENT GENERATION (dB Space) 
//==============================================================================

function generate_curve_segments_db() (
  !curve_segments_db_allocated ? (
    curve_segments_db = freemem;
    freemem += MAX_CURVE_SEGMENTS * 4;
    curve_segments_db_allocated = 1;
  );
  
  segment_count = 0;
  
  num_points >= 2 ? (
    prev_x_db = get_point_x(0);
    prev_y_db = get_point_y(0);
    
    clamped_junction_x_db = 0;
    clamped_junction_y_db = 0;
    use_clamped_junction = 0;
    
    i = 0;
    while (i < num_points - 1) (
      next_idx = i + 1;
      next_point_has_curve = is_valid_curve_point(next_idx) && get_curve_amount(next_idx) > 0;
      
      next_point_has_curve ? (
        curve_amt = get_curve_amount(next_idx);
        calculate_bezier_control_points(next_idx, curve_amt);
        
        p0_x_db = bezier_p0_x;
        p0_y_db = bezier_p0_y;
        p1_x_db = bezier_control1_x;
        p1_y_db = bezier_control1_y;
        p2_x_db = bezier_control2_x;
        p2_y_db = bezier_control2_y;
        p3_x_db = bezier_p3_x;
        p3_y_db = bezier_p3_y;
        
        use_clamped_junction ? (
          p0_x_db = clamped_junction_x_db;
          p0_y_db = clamped_junction_y_db;
          use_clamped_junction = 0;
        );
        
        next_next_idx = i + 2;
        next_next_point_has_curve = is_valid_curve_point(next_next_idx) && get_curve_amount(next_next_idx) > 0;
        
        next_next_point_has_curve ? (
          next_curve_amount = get_curve_amount(next_next_idx);
          calculate_bezier_control_points(next_next_idx, next_curve_amount);
          next_p0_x_db = bezier_p0_x;
          next_p0_y_db = bezier_p0_y;
          
          p3_x_db > next_p0_x_db ? (
            junction_x_db = (p3_x_db + next_p0_x_db) / 2;
            junction_y_db = (p3_y_db + next_p0_y_db) / 2;
            p3_x_db = junction_x_db;
            p3_y_db = junction_y_db;
            clamped_junction_x_db = junction_x_db;
            clamped_junction_y_db = junction_y_db;
            use_clamped_junction = 1;
          );
        );
        
        t = 0;
        t_step = 1.0 / BEZIER_STEPS;
        while (t < 1 && segment_count < MAX_CURVE_SEGMENTS - 1) (
          evaluate_bezier_at_t(t, p0_x_db, p0_y_db, p1_x_db, p1_y_db, p2_x_db, p2_y_db, p3_x_db, p3_y_db);
          current_x_db = bezier_result_x;
          current_y_db = bezier_result_y;

          store_segment(segment_count, prev_x_db, prev_y_db, current_x_db, current_y_db);

          segment_count += 1;
          prev_x_db = current_x_db;
          prev_y_db = current_y_db;
          t += t_step;
        );
      ) : (
        end_x_db = get_point_x(next_idx);
        end_y_db = get_point_y(next_idx);
        
        store_segment(segment_count, prev_x_db, prev_y_db, end_x_db, end_y_db);
        
        segment_count += 1;
        prev_x_db = end_x_db;
        prev_y_db = end_y_db;
      );
      
      i += 1;
    );
  );
  
  curve_segments_db_count = segment_count;
  curve_segments_db_dirty = 0;
);

// Internal function to sample curve without clamping (used for boundary calculations)
function sample_curve_at_db_internal(input_db) (
  curve_segments_db_dirty ? generate_curve_segments_db();
  
  curve_segments_db_count == 0 ? (
    input_db
  ) : (
    first_x = curve_segments_db[0];
    first_y = curve_segments_db[1];
    input_db <= first_x ? (
      // Extend tangent from first segment for inputs below the curve
      // Calculate slope from first segment
      seg_x2_db = curve_segments_db[2];
      seg_y2_db = curve_segments_db[3];
      seg_width = seg_x2_db - first_x;
      abs(seg_width) > 0.0001 ? (
        // Calculate slope and extend line
        slope = (seg_y2_db - first_y) / seg_width;
        first_y + slope * (input_db - first_x)
      ) : (
        // Vertical segment, just return first Y
        first_y
      )
    ) : (
      last_idx = curve_segments_db_count - 1;
      last_x = curve_segments_db[last_idx * 4 + 2];
      input_db >= last_x ? (
        curve_segments_db[last_idx * 4 + 3]
      ) : (
        seg_idx = 0;
        output_db = input_db;
        found = 0;
        
        while (seg_idx < curve_segments_db_count && !found) (
          seg_base = seg_idx * 4;
          seg_x1_db = curve_segments_db[seg_base + 0];
          seg_y1_db = curve_segments_db[seg_base + 1];
          seg_x2_db = curve_segments_db[seg_base + 2];
          seg_y2_db = curve_segments_db[seg_base + 3];
          
          (input_db >= seg_x1_db - 0.0001 && input_db <= seg_x2_db + 0.0001) ||
          (input_db >= seg_x2_db - 0.0001 && input_db <= seg_x1_db + 0.0001) ? (
            seg_width = seg_x2_db - seg_x1_db;
            abs(seg_width) > 0.0001 ? (
              t = max(0, min(1, (input_db - seg_x1_db) / seg_width));
              output_db = seg_y1_db + t * (seg_y2_db - seg_y1_db);
            ) : (
              output_db = seg_y1_db;
            );
            found = 1;
          );
          
          seg_idx += 1;
        );
        
        output_db
      )
    )
  )
);

function sample_curve_at_db(input_db) (
  // Sample the curve at the input
  output_db = sample_curve_at_db_internal(input_db);
  
  // Clamp below minimum graph point: allow tangent to continue, but prevent boosts
  // The curve should continue naturally from corner point on its tangent
  // Only clamp if it would cause a boost (output > input)
  input_db < GRAPH_MIN_DB ? (
    // Allow tangent to continue, but clamp to 1:1 max to prevent gain boosts
    min(output_db, input_db)
  ) : (
    // Clamp above maximum graph point: maintain Y value at GRAPH_MAX_DB
    // This prevents huge gains from angled top-right point
    input_db > GRAPH_MAX_DB ? (
      clamped_y_at_max = sample_curve_at_db_internal(GRAPH_MAX_DB);
      clamped_y_at_max
    ) : (
      output_db
    )
  )
);

