// Graph Curves Module
// Bezier curve calculations for smooth curve rendering
// Depends on: 03a_graph_data_core.jsfx-inc

@init

//==============================================================================
// CURVE GENERATION CONSTANTS
//==============================================================================

BEZIER_STEPS = 20; // Number of line segments to approximate Bezier curves
MAX_CURVE_SEGMENTS = 500; // Maximum number of line segments for entire curve

// Curve segment cache (in dB space - the single source of truth)
curve_segments_db = 0;
curve_segments_db_allocated = 0;
curve_segments_db_count = 0;
curve_segments_db_dirty = 1;

//==============================================================================
// BEZIER CURVE CALCULATIONS
//==============================================================================

function calculate_bezier_control_points(point_index, curve_amount) (
  // Get the three points involved
  prev_point_x = graph_points[(point_index-1)*2];
  prev_point_y = graph_points[(point_index-1)*2 + 1];
  curr_point_x = graph_points[point_index*2];
  curr_point_y = graph_points[point_index*2 + 1];
  next_point_x = graph_points[(point_index+1)*2];
  next_point_y = graph_points[(point_index+1)*2 + 1];
  
  // Calculate curve factor
  curve_factor = curve_amount / 100.0;
  
  // Calculate invisible intermediate points (curve_factor % along the lines)
  // These will be the actual endpoints of our Bezier curve
  invisible1_x = curr_point_x + (prev_point_x - curr_point_x) * curve_factor;
  invisible1_y = curr_point_y + (prev_point_y - curr_point_y) * curve_factor;
  invisible2_x = curr_point_x + (next_point_x - curr_point_x) * curve_factor;
  invisible2_y = curr_point_y + (next_point_y - curr_point_y) * curve_factor;
  
  // For a proper curve, we need to use the current point as a control point
  // and the invisible points as endpoints
  // The control points should pull the curve toward the actual point
  
  // Control point 1: pulls curve toward current point from invisible1
  control1_x = curr_point_x;
  control1_y = curr_point_y;
  
  // Control point 2: pulls curve toward current point from invisible2  
  control2_x = curr_point_x;
  control2_y = curr_point_y;
  
  // Store invisible points as the actual curve endpoints
  bezier_p0_x = invisible1_x;
  bezier_p0_y = invisible1_y;
  bezier_control1_x = control1_x;
  bezier_control1_y = control1_y;
  bezier_control2_x = control2_x;
  bezier_control2_y = control2_y;
  bezier_p3_x = invisible2_x;
  bezier_p3_y = invisible2_y;
);

function evaluate_bezier_curve(t, p0_x, p0_y, p1_x, p1_y, p2_x, p2_y, p3_x, p3_y) (
  u = 1 - t;
  tt = t * t;
  uu = u * u;
  uuu = uu * u;
  ttt = tt * t;
  
  result_x = uuu * p0_x + 3 * uu * t * p1_x + 3 * u * tt * p2_x + ttt * p3_x;
  result_y = uuu * p0_y + 3 * uu * t * p1_y + 3 * u * tt * p2_y + ttt * p3_y;
  
  // Return result via global variables
  bezier_result_x = result_x;
  bezier_result_y = result_y;
);

//==============================================================================
// CURVE SEGMENT GENERATION (dB Space) - SINGLE SOURCE OF TRUTH
//==============================================================================

// Generate complete curve as line segments in dB space
// This is the canonical curve representation used by both UI and compression LUT
function generate_curve_segments_db() (
  // Allocate memory if needed
  !curve_segments_db_allocated ? (
    curve_segments_db = freemem;
    freemem += MAX_CURVE_SEGMENTS * 4; // 4 values per segment (x1,y1,x2,y2)
    curve_segments_db_allocated = 1;
  );
  
  segment_count = 0;
  
  // Only process if we have at least 2 points
  num_points >= 2 ? (
    // Start from first point - ensure it's at graph minimum
    // The first and last points should be at the graph boundaries
    prev_x_db = graph_points[0];
    prev_y_db = graph_points[1];
    
    // Track junction points for consecutive curves
    clamped_junction_x_db = 0;
    clamped_junction_y_db = 0;
    use_clamped_junction = 0;
    
    i = 0;
    while (i < num_points - 1) (
      // Check if point i+1 has a curve
      next_point_has_curve = 0;
      (i + 1) > 0 && (i + 1) < (num_points - 1) ? (
        curve_amount = get_curve_amount(i + 1);
        next_point_has_curve = curve_amount > 0;
      );
      
      next_point_has_curve ? (
        // Generate Bezier curve segments
        curve_amt = get_curve_amount(i + 1);
        calculate_bezier_control_points(i + 1, curve_amt);
        
        // Bezier control points are already in dB space
        p0_x_db = bezier_p0_x;
        p0_y_db = bezier_p0_y;
        p1_x_db = bezier_control1_x;
        p1_y_db = bezier_control1_y;
        p2_x_db = bezier_control2_x;
        p2_y_db = bezier_control2_y;
        p3_x_db = bezier_p3_x;
        p3_y_db = bezier_p3_y;
        
        // Use clamped junction if available
        use_clamped_junction ? (
          p0_x_db = clamped_junction_x_db;
          p0_y_db = clamped_junction_y_db;
          use_clamped_junction = 0;
        );
        
        // Check for consecutive curved points
        next_next_point_has_curve = 0;
        (i + 2) > 0 && (i + 2) < (num_points - 1) ? (
          next_curve_amount = get_curve_amount(i + 2);
          next_next_point_has_curve = next_curve_amount > 0;
        );
        
        // Handle crossing invisible control points
        next_next_point_has_curve ? (
          calculate_bezier_control_points(i + 2, next_curve_amount);
          next_p0_x_db = bezier_p0_x;
          next_p0_y_db = bezier_p0_y;
          
          // Check if they cross
          p3_x_db > next_p0_x_db ? (
            junction_x_db = (p3_x_db + next_p0_x_db) / 2;
            junction_y_db = (p3_y_db + next_p0_y_db) / 2;
            p3_x_db = junction_x_db;
            p3_y_db = junction_y_db;
            clamped_junction_x_db = junction_x_db;
            clamped_junction_y_db = junction_y_db;
            use_clamped_junction = 1;
          );
        );
        
        // Generate line segments along Bezier curve
        t = 0;
        while (t < 1 && segment_count < MAX_CURVE_SEGMENTS - 1) (
          // Calculate Bezier point at t
          u = 1 - t;
          tt = t * t;
          uu = u * u;
          uuu = uu * u;
          ttt = tt * t;
          
          current_x_db = uuu * p0_x_db + 3 * uu * t * p1_x_db + 3 * u * tt * p2_x_db + ttt * p3_x_db;
          current_y_db = uuu * p0_y_db + 3 * uu * t * p1_y_db + 3 * u * tt * p2_y_db + ttt * p3_y_db;
          
          // Store line segment in dB space
          curve_segments_db[segment_count*4 + 0] = prev_x_db;
          curve_segments_db[segment_count*4 + 1] = prev_y_db;
          curve_segments_db[segment_count*4 + 2] = current_x_db;
          curve_segments_db[segment_count*4 + 3] = current_y_db;
          
          segment_count += 1;
          prev_x_db = current_x_db;
          prev_y_db = current_y_db;
          t += 1.0 / BEZIER_STEPS;
        );
      ) : (
        // Straight line segment
        end_x_db = graph_points[(i+1)*2];
        end_y_db = graph_points[(i+1)*2 + 1];
        
        // Store line segment
        curve_segments_db[segment_count*4 + 0] = prev_x_db;
        curve_segments_db[segment_count*4 + 1] = prev_y_db;
        curve_segments_db[segment_count*4 + 2] = end_x_db;
        curve_segments_db[segment_count*4 + 3] = end_y_db;
        
        segment_count += 1;
        prev_x_db = end_x_db;
        prev_y_db = end_y_db;
      );
      
      i += 1;
    );
  );
  
  curve_segments_db_count = segment_count;
  curve_segments_db_dirty = 0;
);

// Invalidate the dB curve cache
function invalidate_curve_segments_db() (
  curve_segments_db_dirty = 1;
);

// Sample the curve at a specific input dB value
function sample_curve_at_db(input_db) (
  // Ensure curve is generated
  curve_segments_db_dirty ? generate_curve_segments_db();
  
  // Handle edge cases first
  curve_segments_db_count == 0 ? (
    input_db // No curve, return unity
  ) : (
    // Check if before first segment
    first_x = curve_segments_db[0];
    input_db <= first_x ? (
      curve_segments_db[1] // Return Y of first point
    ) : (
      // Check if after last segment
      last_x = curve_segments_db[(curve_segments_db_count-1)*4 + 2];
      input_db >= last_x ? (
        curve_segments_db[(curve_segments_db_count-1)*4 + 3] // Return Y of last point
      ) : (
        // Find the segment containing this input_db
        seg_idx = 0;
        output_db = input_db; // Default to unity if not found
        found = 0;
        
        while (seg_idx < curve_segments_db_count && !found) (
          seg_x1_db = curve_segments_db[seg_idx*4 + 0];
          seg_y1_db = curve_segments_db[seg_idx*4 + 1];
          seg_x2_db = curve_segments_db[seg_idx*4 + 2];
          seg_y2_db = curve_segments_db[seg_idx*4 + 3];
          
          // Check if input_db is within this segment (with small tolerance for floating point)
          (input_db >= seg_x1_db - 0.0001 && input_db <= seg_x2_db + 0.0001) ||
          (input_db >= seg_x2_db - 0.0001 && input_db <= seg_x1_db + 0.0001) ? (
            // Interpolate
            seg_width = seg_x2_db - seg_x1_db;
            abs(seg_width) > 0.0001 ? (
              // Optimized: inline clamp to avoid function call overhead
              t = max(0, min(1, (input_db - seg_x1_db) / seg_width));
              output_db = seg_y1_db + t * (seg_y2_db - seg_y1_db);
            ) : (
              output_db = seg_y1_db;
            );
            found = 1;
          );
          
          seg_idx += 1;
        );
        
        output_db
      )
    )
  );
);

