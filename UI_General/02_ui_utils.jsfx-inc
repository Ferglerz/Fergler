// UI Utilities Module
// Pure UI utility functions and coordinate conversions
// Contains control accessor functions and basic UI utilities
//
// Dependencies:
// - 01_Utils/01_constants.jsfx-inc (for GRAPH_* and UI constants)
// - UI_Sliders/00_file_reading.jsfx-inc (for get_slider_name function)
// - UI_General/00_ui_constants.jsfx-inc (for UI constants)
// - 01_Utils/05_memory.jsfx-inc (for control_defs array)

@init

//==============================================================================
// BASIC UI UTILITIES
//==============================================================================

function is_point_in_control(x, y, control_index) local(group_idx) (
  ctrl_x = control_defs[control_index*11 + 1];
  ctrl_y = control_defs[control_index*11 + 2];
  ctrl_w = control_defs[control_index*11 + 3];
  ctrl_h = control_defs[control_index*11 + 4];
  group_idx = control_defs[control_index*11 + 10];

  // Add group offset if control is in a group
  group_idx >= 0 ? (
    ctrl_x += group_defs[group_idx*6 + 0];
    ctrl_y += group_defs[group_idx*6 + 1];
  );
  
  x >= ctrl_x && x <= ctrl_x + ctrl_w && y >= ctrl_y && y <= ctrl_y + ctrl_h;
);


function update_slider_value(control_index, mouse_x, mouse_y) local(group_idx, control_type, param_index, option_count, option_index, i, opt_value, reverse_mode, ctrl_x_rel, ctrl_x_abs, group_x_val, slider_orientation, format_options, array_index) (
  slider_config = control_defs[control_index*11 + 8];
  slider_orientation = slider_config & 0xFF;  // Extract slider orientation from config
  format_options = (slider_config >> 32) & 0xFF;  // Extract format options
  min_val = control_defs[control_index*11 + 6];
  max_val = control_defs[control_index*11 + 7];
  group_idx = control_defs[control_index*11 + 10];
  control_type = control_defs[control_index*11 + 0];
  param_index = control_defs[control_index*11 + 5];

  slider_orientation == ORIENTATION_VERTICAL ? ( // Vertical slider
    ctrl_y = control_defs[control_index*11 + 2];
    ctrl_h = control_defs[control_index*11 + 4];

    // Add group offset if control is in a group
    group_idx >= 0 ? (
      ctrl_y += group_defs[group_idx*6 + 1];
    );

    normalized_pos = (mouse_y - ctrl_y) / ctrl_h;
    normalized_pos = max(0, min(1, normalized_pos));
    // Invert for vertical slider (0 at top, 1 at bottom)
    normalized_pos = 1 - normalized_pos;
  ) : ( // Horizontal slider (normal or reverse)
    ctrl_x_rel = control_defs[control_index*11 + 1];
    ctrl_w = control_defs[control_index*11 + 3];

    // Add group offset if control is in a group
    group_idx >= 0 ? (
      group_x_val = group_defs[group_idx*6 + 0];
      ctrl_x = ctrl_x_rel + group_x_val;
    ) : (
      ctrl_x = ctrl_x_rel;
    );
    
    normalized_pos = (mouse_x - ctrl_x) / ctrl_w;
    normalized_pos = max(0, min(1, normalized_pos));
    
    // Handle reverse sliders - invert the normalized position
    format_options & OPTION_REVERSE ? (
      normalized_pos = 1.0 - normalized_pos;
    );
  );
  
  // Check if this slider has enumerated options (for any slider type)
  option_count = get_dropdown_option_count(param_index);
  option_count > 0 ? (
    // Enumerated slider: divide slider width by number of options
    // Each option gets (slider_width / option_count) pixels
    // Map mouse position to option index
    
    // Calculate which option the mouse is over
    // For horizontal sliders: mouse_x relative to slider start
    slider_orientation == ORIENTATION_VERTICAL ? (
      // Vertical slider: use normalized position directly
      option_index = floor(normalized_pos * option_count);
    ) : (
      // Horizontal slider: calculate option index from mouse position
      // Each option occupies (ctrl_w / option_count) pixels
      pixels_per_option = ctrl_w / option_count;
      mouse_pos_in_slider = mouse_x - ctrl_x;
      option_index = floor(mouse_pos_in_slider / pixels_per_option);
    );
    
    // Clamp to valid range
    option_index = max(0, min(option_count - 1, option_index));
    
    // Return the option index (not the frequency value - slider stores index)
    option_index;
  ) : (
    // For normal sliders without enumerated options, use continuous range with increment snapping
    raw_value = min_val + normalized_pos * (max_val - min_val);
    // Inline get_slider_increment: slider_properties_base[control_index * 4 + 0]
    array_index = control_index * 4 + 0;
    increment = (array_index >= 0 && array_index < NUM_CONTROLS * 4) ? slider_properties_base[array_index] : 0;
    increment > 0 ? (
      // Snap to nearest increment step
      floor(raw_value / increment + 0.5) * increment
    ) : (
      raw_value
    );
  );
);

// Shared function to update value from mouse delta
function update_value_from_mouse_delta(current_value, min_val, max_val, mouse_dy, sensitivity, param_index) local(array_index) (
  // Vertical mouse movement controls value (down = increase, up = decrease)
  value_range = max_val - min_val;
  delta = -mouse_dy * sensitivity * value_range / 100; // Negative because down = increase
  
  new_value = current_value + delta;
  new_value = max(min_val, min(max_val, new_value));
  
  // Apply increment snapping - inline get_slider_increment
  // Get slider increment from file_reading module (uses slider_num, 1-indexed)
  increment = get_slider_increment(param_index);
  increment > 0 ? (
    // Snap to nearest increment step
    floor(new_value / increment + 0.5) * increment
  ) : (
    new_value
  );
);

//==============================================================================
// SLIDER PROPERTIES SYSTEM
//==============================================================================

// Set slider property for a control
function set_slider_property(control_index, property_index, value) (
  array_index = control_index * 4 + property_index;
  array_index >= 0 && array_index < NUM_CONTROLS * 4 ? (
    slider_properties_base[array_index] = value;
  );
);

// Convenience functions for common properties
function set_slider_increment(control_index, increment) (
  set_slider_property(control_index, 0, increment);
);

//==============================================================================
// COORDINATE CLAMPING HELPERS
//==============================================================================

// Note: Graph coordinate conversion functions (db_to_graph_x, db_to_graph_y, etc.)
// are now defined in UI_General/12_coordinate_conversion.jsfx-inc

// Clamp x coordinate to graph bounds
// Parameters: x (coordinate), graph_x (left edge), graph_size (graph size)
function clamp_x_to_graph(x, graph_x, graph_size) (
  max(graph_x, min(graph_x + graph_size, x))
);

// Clamp y coordinate to graph bounds
// Parameters: y (coordinate), graph_y (top edge), graph_size (graph size)
function clamp_y_to_graph(y, graph_y, graph_size) (
  max(graph_y, min(graph_y + graph_size, y))
);

//==============================================================================
// DRAWING HELPERS
//==============================================================================

function draw_indicator_circle(x, y, radius, r, g, b, alpha, filled) (
  gfx_set(r, g, b, alpha);
  gfx_circle(x, y, radius, filled, 1); 
);

// Draw formatted text at position with color
function draw_text_at(r, g, b, a, x, y, format_str, value) (
  gfx_set(r, g, b, a);
  gfx_x = x;
  gfx_y = y;
  gfx_printf(format_str, value);
);

//==============================================================================
// DISPLAY FORMATTING FUNCTIONS
//==============================================================================

// Calculate decimal places based on increment
function get_decimal_places(increment) (
  increment <= 0 ? 2 : (
    increment >= 1 ? 0 : (
      increment >= 0.1 ? 1 : (
        increment >= 0.01 ? 2 : 3
      )
    )
  )
);

// Format value with appropriate decimal places and suffix
function format_value_with_suffix(value, increment, display_mode) local(decimal_places, format_str) (
  decimal_places = get_decimal_places(increment);
  
  display_mode == DISPLAY_PERCENT ? (
    sprintf(#temp_display_str, "%%.%df %%", decimal_places, value);
  ) : display_mode == DISPLAY_DB ? (
    sprintf(#temp_display_str, "%%.%df dB", decimal_places, value);
  ) : display_mode == DISPLAY_MS ? (
    sprintf(#temp_display_str, "%%.%df ms", decimal_places, value);
  ) : display_mode == DISPLAY_HZ ? (
    sprintf(#temp_display_str, "%%.%df Hz", decimal_places, value);
  ) : (
    sprintf(#temp_display_str, "%%.%df", decimal_places, value);
  );
  
  temp_display_str;
);

// Format frequency for display (e.g., "Off", "4k", "1.5k", "500")
// Returns string via global variable for JSFX string handling
function format_freq_display(freq) local(freq_khz) (
  freq == 0 ? (
    // Off
    freq_display_str = "Off";
  ) : freq >= 1000 ? (
    // Display as kilohertz (e.g., 4k, 1.5k)
    freq_khz = freq / 1000;
    freq_khz == floor(freq_khz) ? (
      // Whole number kHz (e.g., 4k, 5k)
      sprintf(#freq_display_str, "%.0fk", freq_khz);
    ) : (
      // Fractional kHz (e.g., 1.25k, 1.5k)
      sprintf(#freq_display_str, "%.2fk", freq_khz);
    );
  ) : (
    // Display as Hz for frequencies below 1kHz
    sprintf(#freq_display_str, "%.0f", freq);
  );
  
  freq_display_str;
);

