// UI Utilities Module
// Pure UI utility functions and coordinate conversions
// Contains control accessor functions and basic UI utilities
//
// Dependencies:
// - 01_Utils/01_constants.jsfx-inc (for GRAPH_* and UI constants)
// - UI_Sliders/00_file_reading.jsfx-inc (for get_slider_name function)
// - UI_General/00_ui_constants.jsfx-inc (for UI constants)
// - 01_Utils/05_memory.jsfx-inc (for control_defs array)

@init

//==============================================================================
// BASIC UI UTILITIES
//==============================================================================

function is_point_in_control(x, y, control_index) local(group_idx) (
  ctrl_x = control_defs[control_index*11 + 1];
  ctrl_y = control_defs[control_index*11 + 2];
  ctrl_w = control_defs[control_index*11 + 3];
  ctrl_h = control_defs[control_index*11 + 4];
  group_idx = control_defs[control_index*11 + 10];

  // Add group offset if control is in a group
  group_idx >= 0 ? (
    ctrl_x += group_defs[group_idx*6 + 0];
    ctrl_y += group_defs[group_idx*6 + 1];
  );
  
  x >= ctrl_x && x <= ctrl_x + ctrl_w && y >= ctrl_y && y <= ctrl_y + ctrl_h;
);

// Step-point array base addresses (defined in 05_Composure_Controls.jsfx-inc)
// These are declared here for early access by helper functions
attack_step_points_base = 20000;
release_step_points_base = 20100;
hp_step_points_base = 20200;
lp_step_points_base = 20300;

// Step-point counts (initialized in 05_Composure_Controls.jsfx-inc)
attack_step_count = 0;
release_step_count = 0;
hp_step_count = 0;
lp_step_count = 0;

// Helper functions to get step-point info for a slider parameter
// Returns step-point count for the given parameter, or 0 if not a stepped slider
function get_step_point_count(param_index) (
  param_index == 1 ? attack_step_count :
  param_index == 3 ? release_step_count :
  param_index == 10 ? hp_step_count :
  param_index == 11 ? lp_step_count :
  0
);

// Returns step-point array base for the given parameter, or 0 if not a stepped slider
function get_step_points_base(param_index) (
  param_index == 1 ? attack_step_points_base :
  param_index == 3 ? release_step_points_base :
  param_index == 10 ? hp_step_points_base :
  param_index == 11 ? lp_step_points_base :
  0
);

function update_slider_value(control_index, mouse_x, mouse_y) local(group_idx, control_type, param_index, option_count, option_index, i, opt_value, reverse_mode, ctrl_x_rel, ctrl_x_abs, group_x_val, slider_orientation, format_options, array_index) (
  slider_config = control_defs[control_index*11 + 8];
  slider_orientation = slider_config & 0xFF;  // Extract slider orientation from config
  format_options = (slider_config >> 32) & 0xFF;  // Extract format options
  min_val = control_defs[control_index*11 + 6];
  max_val = control_defs[control_index*11 + 7];
  group_idx = control_defs[control_index*11 + 10];
  control_type = control_defs[control_index*11 + 0];
  param_index = control_defs[control_index*11 + 5];

  slider_orientation == ORIENTATION_VERTICAL ? ( // Vertical slider
    ctrl_y = control_defs[control_index*11 + 2];
    ctrl_h = control_defs[control_index*11 + 4];

    // Add group offset if control is in a group
    group_idx >= 0 ? (
      ctrl_y += group_defs[group_idx*6 + 1];
    );

    normalized_pos = (mouse_y - ctrl_y) / ctrl_h;
    normalized_pos = max(0, min(1, normalized_pos));
    // Invert for vertical slider (0 at top, 1 at bottom)
    normalized_pos = 1 - normalized_pos;
  ) : ( // Horizontal slider (normal or reverse)
    ctrl_x_rel = control_defs[control_index*11 + 1];
    ctrl_w = control_defs[control_index*11 + 3];

    // Add group offset if control is in a group
    group_idx >= 0 ? (
      group_x_val = group_defs[group_idx*6 + 0];
      ctrl_x = ctrl_x_rel + group_x_val;
    ) : (
      ctrl_x = ctrl_x_rel;
    );
    
    normalized_pos = (mouse_x - ctrl_x) / ctrl_w;
    normalized_pos = max(0, min(1, normalized_pos));
    
    // Handle reverse sliders - invert the normalized position
    format_options & OPTION_REVERSE ? (
      normalized_pos = 1.0 - normalized_pos;
    );
  );
  
  // Check if this slider has enumerated options or step-points
  option_count = get_dropdown_option_count(param_index);
  step_count = get_step_point_count(param_index);
  total_options = option_count > 0 ? option_count : step_count;
  
  total_options > 0 ? (
    // Stepped slider (enumerated or step-points): divide slider width by number of options
    // Each option gets (slider_width / total_options) pixels
    // Map mouse position to option index
    
    // Calculate which option the mouse is over
    // For horizontal sliders: mouse_x relative to slider start
    slider_orientation == ORIENTATION_VERTICAL ? (
      // Vertical slider: use normalized position directly
      option_index = floor(normalized_pos * total_options);
    ) : (
      // Horizontal slider: calculate option index from mouse position
      // Each option occupies (ctrl_w / total_options) pixels
      pixels_per_option = ctrl_w / total_options;
      mouse_pos_in_slider = mouse_x - ctrl_x;
      option_index = floor(mouse_pos_in_slider / pixels_per_option);
    );
    
    // Clamp to valid range
    option_index = max(0, min(total_options - 1, option_index));
    
    // Return value based on type
    option_count > 0 ? (
      // Enumerated slider: return the index (slider stores index)
      option_index;
    ) : (
      // Step-point slider: return the step-point value at that index
      step_points_base = get_step_points_base(param_index);
      step_points_base[option_index];
    );
  ) : (
    // For normal sliders without enumerated options, use continuous range with increment snapping
    raw_value = min_val + normalized_pos * (max_val - min_val);
    // Inline get_slider_increment: slider_properties_base[control_index * 4 + 0]
    array_index = control_index * 4 + 0;
    increment = (array_index >= 0 && array_index < NUM_CONTROLS * 4) ? slider_properties_base[array_index] : 0;
    increment > 0 ? (
      // Snap to nearest increment step
      floor(raw_value / increment + 0.5) * increment
    ) : (
      raw_value
    );
  );
);


// Find the index of the closest step-point for a given value
// Returns the index (0-based) of the closest step-point
function find_step_point_index(value, step_points_base, step_count) local(
  closest_index, closest_diff, i, test_value, test_diff
) (
  closest_index = 0;
  closest_diff = abs(step_points_base[0] - value);
  i = 1;
  while (i < step_count) (
    test_value = step_points_base[i];
    test_diff = abs(test_value - value);
    test_diff < closest_diff ? (
      closest_index = i;
      closest_diff = test_diff;
    );
    i += 1;
  );
  closest_index;
);

// Helper function to find closest step-point value
// Used for sliders with step-point arrays (attack, release, hp_freq, lp_freq)
function find_closest_step_point(value, step_points_base, step_count) local(closest_value, closest_diff, i, test_value, test_diff) (
  closest_value = step_points_base[0];
  closest_diff = abs(step_points_base[0] - value);
  i = 1;
  while (i < step_count) (
    test_value = step_points_base[i];
    test_diff = abs(test_value - value);
    test_diff < closest_diff ? (
      closest_value = test_value;
      closest_diff = test_diff;
    );
    i += 1;
  );
  closest_value;
);

//==============================================================================
// SLIDER PROPERTIES SYSTEM
//==============================================================================

// Set slider property for a control
function set_slider_property(control_index, property_index, value) (
  array_index = control_index * 4 + property_index;
  array_index >= 0 && array_index < NUM_CONTROLS * 4 ? (
    slider_properties_base[array_index] = value;
  );
);

//==============================================================================
// COORDINATE CLAMPING HELPERS
//==============================================================================

// Note: Graph coordinate conversion functions (db_to_graph_x, db_to_graph_y, etc.)
// are now defined in UI_General/12_coordinate_conversion.jsfx-inc

// Clamp x coordinate to graph bounds
// Parameters: x (coordinate), graph_x (left edge), graph_size (graph size)
function clamp_x_to_graph(x, graph_x, graph_size) (
  max(graph_x, min(graph_x + graph_size, x))
);

// Clamp y coordinate to graph bounds
// Parameters: y (coordinate), graph_y (top edge), graph_size (graph size)
function clamp_y_to_graph(y, graph_y, graph_size) (
  max(graph_y, min(graph_y + graph_size, y))
);

//==============================================================================
// DRAWING HELPERS
//==============================================================================

function draw_indicator_circle(x, y, radius, r, g, b, alpha, filled) (
  gfx_set(r, g, b, alpha);
  gfx_circle(x, y, radius, filled, 1); 
);

// Draw formatted text at position with color
function draw_text_at(r, g, b, a, x, y, format_str, value) (
  gfx_set(r, g, b, a);
  gfx_x = x;
  gfx_y = y;
  gfx_printf(format_str, value);
);

//==============================================================================
// DISPLAY FORMATTING FUNCTIONS
//==============================================================================

// Calculate decimal places based on increment
function get_decimal_places(increment) (
  increment <= 0 ? 2 : (
    increment >= 1 ? 0 : (
      increment >= 0.1 ? 1 : (
        increment >= 0.01 ? 2 : 3
      )
    )
  )
);

