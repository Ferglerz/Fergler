---
alwaysApply: true
---

# JSFX Modular Architecture - Composure Compressor

## Directory Structure and Dependencies

**CRITICAL**: Modules must be imported in strict dependency order. Lower-numbered directories must never depend on higher-numbered directories.

### Architecture Overview

```
Composure.jsfx (main file)
├── 01_Utils/           Foundation utilities (no dependencies)
├── 02_InputProcessing/ Input processing (depends on 01_Utils)
├── 03_Compression/     Compression engine (depends on 01_Utils, 02_InputProcessing)
└── 04_UI/             User interface (depends on 01_Utils, 03_Compression)
```

### Module Organization by Directory

#### 01_Utils/ - Foundation Layer
Core utilities with no external dependencies:
- `01_constants.jsfx-inc` - Global constants (audio, performance, memory layout)
- `02_math_utils.jsfx-inc` - Mathematical utilities and conversions
- `03_debug_logging.jsfx-inc` - Debug logging system
- `04_file_reading.jsfx-inc` - File I/O operations for slider definitions
- `05_memory.jsfx-inc` - Centralized memory allocation
- `06_state.jsfx-inc` - State variable initialization and management

**Responsibilities:**
- Define all global constants
- Provide math utilities (dB conversions, clamping, etc.)
- Handle memory allocation and buffer management
- Manage debug logging
- Initialize state variables

#### 02_InputProcessing/ - Input Processing Layer
Signal conditioning before compression (depends on 01_Utils):
- `01_dsp_utils.jsfx-inc` - DSP utilities (RMS detection, peak detection)
- `02_filters.jsfx-inc` - Biquad filters for HP/LP filtering
- `04_transient_detection.jsfx-inc` - Transient detection for dynamic envelope

**Responsibilities:**
- RMS and peak level detection
- Sidechain filtering
- Transient detection and analysis
- Input signal conditioning

#### 03_Compression/ - Compression Engine Layer
Core compression processing (depends on 01_Utils, 02_InputProcessing):
- `01_compression_constants.jsfx-inc` - Compression-specific constants
- `02_graph_data_core.jsfx-inc` - Graph point data structures
- `03_graph_curves.jsfx-inc` - Curve interpolation algorithms
- `04_graph_cache.jsfx-inc` - Compression lookup table (LUT) caching
- `05_compression_core.jsfx-inc` - Core compression calculations
- `06_gain_reduction.jsfx-inc` - Gain reduction computation
- `07_envelope.jsfx-inc` - Envelope following (attack/release)
- `08_harmonic_models.jsfx-inc` - Character models (tube, tape, FET, etc.)
- `09_audio_processing_chain.jsfx-inc` - Complete audio processing pipeline

**Responsibilities:**
- Manage compression curve graph points
- Calculate gain reduction from input levels
- Apply envelope following with attack/release
- Add harmonic character models
- Orchestrate complete audio processing chain

#### 04_UI/ - User Interface Layer
All UI rendering and interaction (depends on 01_Utils, 03_Compression):
- `01_ui_constants.jsfx-inc` - UI layout constants and colors
- `02_ui_utils.jsfx-inc` - UI utility functions
- `03_ui_threshold_lines.jsfx-inc` - Threshold line rendering
- `04_ui_interaction.jsfx-inc` - Mouse interaction and control handling
- `05_ui_rendering.jsfx-inc` - Core rendering functions
- `06_ui_controls.jsfx-inc` - Control definitions and layout
- `07_ui_graph_cache.jsfx-inc` - Graph rendering cache
- `08_ui_graph_curves.jsfx-inc` - Graph curve rendering
- `09_ui_graph_meters.jsfx-inc` - Graph meter and histogram rendering
- `10_ui_graph_display.jsfx-inc` - Complete graph display
- `11_ui_orchestration.jsfx-inc` - Main UI orchestration

**Responsibilities:**
- Define UI layout and colors
- Handle mouse interaction with controls and graph
- Render all UI elements (controls, graph, meters)
- Manage UI state and interaction feedback
- Display compression curve and real-time meters

## File Naming Convention

Within each directory, files use numbered prefixes to indicate load order:
- Format: `NN_descriptive_name.jsfx-inc`
- Example: `01_constants.jsfx-inc`, `02_math_utils.jsfx-inc`
- Main file: `Composure.jsfx`

## Module Design Principles

### Single Responsibility
Each module has one focused purpose:
- Constants modules only define constants
- Utility modules provide reusable functions
- Processing modules handle specific audio operations
- UI modules handle specific visual elements

### Clear Dependency Flow
```
01_Utils (foundation)
    ↓
02_InputProcessing (signal conditioning)
    ↓
03_Compression (core processing)
    ↓
04_UI (presentation)
```

### No Circular Dependencies
- Lower-numbered directories NEVER depend on higher-numbered directories
- Each module only depends on modules from lower directories
- Within a directory, lower-numbered files can be depended on by higher-numbered files

### Import Order in Main File
```jsfx
// 01_Utils: Foundation (no dependencies)
import 01_Utils/01_constants.jsfx-inc
import 01_Utils/02_math_utils.jsfx-inc
// ... rest of 01_Utils

// 02_InputProcessing (depends on 01_Utils)
import 02_InputProcessing/01_dsp_utils.jsfx-inc
// ... rest of 02_InputProcessing

// 03_Compression (depends on 01_Utils, 02_InputProcessing)
import 03_Compression/01_compression_constants.jsfx-inc
// ... rest of 03_Compression

// 04_UI (depends on 01_Utils, 03_Compression)
import 04_UI/01_ui_constants.jsfx-inc
// ... rest of 04_UI
```

## Memory Layout and Allocation

All memory allocation is centralized in `01_Utils/05_memory.jsfx-inc`:

### Memory Regions
- **Graph Points**: 10000+ (stores compression curve points)
- **Control Definitions**: 30000+ (stores UI control metadata)
- **Audio Buffers**: 40000+ (lookahead, RMS, transient detection buffers)
- **Compression LUT**: Uses allocated buffers for lookup table

### Allocation Strategy
1. Calculate all buffer sizes based on sample rate and parameters
2. Allocate sequentially from lowest to highest memory addresses
3. Call `freembuf(highest_index + 1)` when reducing memory usage
4. Respect 16,384-item boundaries for FFT/MDCT operations

## Key Execution Flow

### @init Section
1. Clear debug log
2. Read slider definitions from file
3. Allocate memory (centralized)
4. Initialize state variables
5. Initialize stage control flags
6. Initialize curve data
7. Setup UI control layout
8. Initialize graph points (if first load)
9. Mark compression system ready

### @slider Section
1. Detect which parameters changed
2. Update filter parameters
3. Update timing parameters (attack, release, lookahead, RMS)
4. Update makeup gain
5. Configure plugin delay compensation (PDC)
6. Update stage control flags
7. Update strength and global offset

### @block Section
1. Store histogram values from previous block
2. Reset block-level max trackers
3. Update filter coefficients for current block
4. Calculate and cache attack/release coefficients
5. Update RMS window size if changed

### @sample Section
- Calls `process_complete_audio_chain()` which orchestrates:
  1. Input stage (stereo handling, sidechain routing)
  2. Filtering stage (HP/LP filters on detection signal)
  3. Detection analysis (RMS/peak, gain reduction calculation)
  4. Character stage (apply compressor character)
  5. Envelope stage (attack/release following)
  6. Lookahead stage (delay compensation)
  7. Gain reduction stage (apply calculated GR)
  8. Harmonics stage (add harmonic distortion)
  9. Final mix stage (wet/dry blend)
  10. Limiter stage (brickwall limiting)
  11. Output stage

### @gfx Section
1. Update mouse state constants
2. Update histograms with block-max values
3. Render complete interface (via `render_complete_interface()`)
4. Render debug information (if enabled)

## Performance Optimization Guidelines

### Calculation Placement
- **@slider or @block**: Filter coefficients, envelope coefficients, cached constants
- **@sample**: Only per-sample operations (filtering, envelope following, gain application)

### Memory Efficiency
- Use centralized allocation to track total usage
- Reuse buffers where possible
- Clear unused memory regions with `freembuf()`

### Processing Efficiency
- Cache frequently-used calculations in @block
- Use lookup tables for expensive operations (compression curve)
- Minimize per-sample conditional logic
- Use stage flags to bypass disabled processing

## Extension Points

### Adding New Processing Stages
1. Create module in appropriate directory (e.g., `03_Compression/`)
2. Define processing function
3. Add stage control flag if needed
4. Update `09_audio_processing_chain.jsfx-inc` to call new function
5. Update UI if needed to expose new controls

### Adding New UI Elements
1. Create module in `04_UI/` with appropriate number
2. Define rendering function
3. Add interaction handling in `04_ui_interaction.jsfx-inc`
4. Update `11_ui_orchestration.jsfx-inc` to render new element

### Adding New Character Models
1. Add model to `08_harmonic_models.jsfx-inc`
2. Update compressor type slider enum
3. Add model-specific processing function
4. Update character application function to call new model
