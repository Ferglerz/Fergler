---
alwaysApply: true
---

# JSFX Implementation Guidelines - Composure Compressor

## Constants and Mathematical Operations

### Critical Constants
- **ALWAYS use `$pi` directly** - never define a separate PI variable
- Define all constants in appropriate module:
  - **Global constants** → `01_Utils/01_constants.jsfx-inc`
  - **Compression constants** → `03_Compression/01_compression_constants.jsfx-inc`
  - **UI constants** → `04_UI/01_ui_constants.jsfx-inc`

### Common Constants (from `01_Utils/01_constants.jsfx-inc`)
```jsfx
EPS = 0.000000000000000000000000000001;
MIN_DETECTOR_LEVEL = 0.000001;  // Prevent log(0)
DENORMAL_THRESHOLD = pow(10, -15);
```

### Audio Conversions (use functions from `01_Utils/02_math_utils.jsfx-inc`)
- **dB to linear**: `db_to_linear(db)` → `exp(db * 0.11512925464970229)` where constant = log(10)/20
- **Linear to dB**: `linear_to_db(linear)` → `log(linear) * 8.6858896380650366` where constant = 20/log(10)
- **Safe divisions**: add `EPS` to denominators to avoid divide-by-zero
- **Clamping**: use `clamp(value, min, max)` utility function

### Degrees/Radians
- **Degrees to radians**: multiply by `$pi/180`
- **Radians to degrees**: multiply by `180/$pi`

## Memory Management

### Allocation Strategy (centralized in `01_Utils/05_memory.jsfx-inc`)
```jsfx
function allocate_memory() (
  // 1. Calculate sizes based on parameters
  max_lookahead_samples = floor(max_lookahead_ms * 0.001 * srate);
  max_rms_samples = floor(max_rms_size_ms * 0.001 * srate);
  
  // 2. Allocate sequentially from lowest addresses
  buffer_start = 0;
  buffer_next = buffer_start;
  
  lookahead_buffer = buffer_next;
  buffer_next += max_lookahead_samples * 2;  // stereo
  
  rms_buffer = buffer_next;
  buffer_next += max_rms_samples;
  
  // 3. Call freembuf at end
  freembuf(buffer_next);
);
```

### Memory Rules
- Use lowest memory indices possible
- Allocate memory sequentially to avoid conflicts
- FFT/MDCT operations must NOT cross 16,384 item boundaries
- Call `freembuf(highest_index + 1)` after all allocations
- Update allocation when buffer sizes change

### Memory Operations
- `memcpy(dest, source, length)` - efficient copying
- `memset(dest, value, length)` - initialization
- Access via array syntax: `buffer[index]`

## Parameter System

### Slider Definitions (in main `.jsfx` file)
```jsfx
slider1:attack_ms=10<0.05,100,0.1>Attack (ms)
slider2:attack_curve=0<-2,2,0.01>-Attack Curve
slider13:harmonic_type=0<0,7,1{Off,Tube Even,Tube Odd,...}>-Harmonic Type
slider27:stage_filtering=1<0,1,1{Off,On}>-Detection Filtering
```

### Slider Naming Rules
- Use descriptive variable names after colon (e.g., `attack_ms`, not `slider1`)
- Prefix with `-` to hide from UI (e.g., `-Attack Curve`)
- Use enumerated lists for discrete choices: `{option1,option2,option3}`
- Always use declared variable names in code

### Updating Parameters
```jsfx
// In @slider or @block when modifying sliders programmatically
slider21 = new_value;
sliderchange(1 << 20);  // Notify UI: bit 20 = slider21 (0-indexed)

// Bitmask values:
// slider1 = 1 (1 << 0)
// slider2 = 2 (1 << 1)
// slider3 = 4 (1 << 2)
// slider21 = 1048576 (1 << 20)
```

Note: Changes in @slider section automatically update UI (no `sliderchange()` needed).

## Audio Processing Pipeline

### DSP Flow Architecture
```
Input (spl0/spl1)
  ↓
[Stage 1] Input routing (stereo/sidechain)
  ↓
[Stage 2] Detection filtering (HP/LP)
  ↓
[Stage 3] Detection analysis (RMS/peak → gain reduction)
  ↓
[Stage 4] Character application (compressor models)
  ↓
[Stage 5] Envelope following (attack/release)
  ↓
[Stage 6] Lookahead processing (delay buffer)
  ↓
[Stage 7] Gain reduction application
  ↓
[Stage 8] Harmonic processing (tube/tape/FET)
  ↓
[Stage 9] Final mix (wet/dry blend)
  ↓
[Stage 10] Brickwall limiter
  ↓
Output (spl0/spl1)
```

### Processing Chain Implementation
Main entry point: `process_complete_audio_chain()` in `03_Compression/09_audio_processing_chain.jsfx-inc`

Each stage can be bypassed via stage control flags:
```jsfx
stage_filtering ? (
  // Apply filtering
);

stage_harmonics ? (
  // Apply harmonic processing
);
```

### Processing Components

#### Filters (in `02_InputProcessing/02_filters.jsfx-inc`)
- Biquad filters for HP/LP filtering
- Coefficients calculated in `@block` (via `update_filter_coefficients()`)
- Applied in `@sample` (via `apply_detection_filters()`)
- Separate filter states for left/right channels

#### Detection (in `02_InputProcessing/01_dsp_utils.jsfx-inc`)
- **RMS detection**: Circular buffer or exponential smoothing
- **Peak detection**: Simple peak tracking
- **Feedforward mode**: Detect from input signal
- **Feedback mode**: Detect from output signal (after gain reduction)

#### Compression (in `03_Compression/`)
- **Curve interpolation**: Linear or bezier (in `03_graph_curves.jsfx-inc`)
- **Lookup table**: Cached curve for fast access (in `04_graph_cache.jsfx-inc`)
- **Gain reduction**: Calculate from detection level (in `06_gain_reduction.jsfx-inc`)
- **Strength parameter**: Applied as multiplier to gain reduction

#### Character Models (in `03_Compression/08_harmonic_models.jsfx-inc`)
- **Clean Digital**: Linear, no coloration
- **Tube models**: Even/odd/both harmonic emphasis
- **Tape Saturation**: Soft clipping, warmth
- **FET**: Aggressive even harmonics
- **VCA**: Clean, fast response
- **Optical**: Slow, smooth response
- Apply character-specific gain reduction modifications

#### Envelope (in `03_Compression/07_envelope.jsfx-inc`)
- Attack/release coefficients calculated in `@block`
- Curve shaping: S-curve (positive) or exponential (negative)
- Program-dependent release: Input-level, GR-level, or rate-of-change
- Transient detection can modify attack/release dynamically

#### Lookahead (in `03_Compression/09_audio_processing_chain.jsfx-inc`)
- Circular buffer for delay compensation
- Write current sample, read delayed sample
- Allows envelope follower to "see ahead" and react smoothly

#### Harmonics (in `03_Compression/08_harmonic_models.jsfx-inc`)
- Separate from character models (applied after gain reduction)
- Tube, tape, FET models add harmonic content
- Configurable drive, even/odd boost, and wet/dry mix

#### Limiter (in `03_Compression/09_audio_processing_chain.jsfx-inc`)
- Soft-clipping brickwall limiter
- Prevents output from exceeding ±1.0
- Uses smooth tanh-based saturation

### Performance Optimization Rules

#### Calculate in @slider or @block, Apply in @sample
```jsfx
// GOOD: Calculate coefficients in @block
@block
attack_coeff = exp(-1000 / (attack_ms * srate));
release_coeff = exp(-1000 / (release_ms * srate));

// Then apply in @sample
@sample
envelope = input_level > envelope ? 
  envelope + (input_level - envelope) * (1 - attack_coeff) :
  envelope + (input_level - envelope) * (1 - release_coeff);

// BAD: Calculate coefficients in @sample
@sample
attack_coeff = exp(-1000 / (attack_ms * srate));  // Recalculated every sample!
```

#### Cache Frequently-Used Values
```jsfx
// GOOD: Cache in @block
@block
srate_inv = 1.0 / srate;
attack_ms_srate = attack_ms * srate;
makeup_gain_linear = db_to_linear(makeup_gain_db);

@sample
// Use cached values
time_delta = samplesblock * srate_inv;

// BAD: Recalculate every sample
@sample
time_delta = samplesblock * (1.0 / srate);  // Division every sample!
```

#### Use Lookup Tables for Expensive Operations
```jsfx
// Compression curve lookup (in 03_Compression/04_graph_cache.jsfx-inc)
// Pre-calculate curve for all dB values
function rebuild_compression_lut() (
  i = 0;
  loop(COMP_LUT_SIZE,
    input_db = COMP_LUT_MIN_DB + i * COMP_LUT_GRANULARITY;
    output_db = evaluate_curve_at_db(input_db);
    compression_lut[i] = output_db;
    i += 1;
  );
);

// Then in @sample, just look up value
function calculate_gain_reduction(input_db) (
  // Fast lookup instead of curve calculation
  output_db = lookup_compression_lut(input_db);
  gr_db = output_db - input_db;
);
```

#### Minimize Conditional Logic in @sample
```jsfx
// GOOD: Use stage flags set in @block
stage_harmonics ? (
  spl0 = apply_harmonics(spl0);
  spl1 = apply_harmonics(spl1);
);

// BAD: Check multiple conditions per sample
(harmonic_type > 0 && harmonic_amount > 0 && stage_harmonics) ? (
  // Complex condition evaluated every sample
);
```

## UI and Graphics

### UI Module Organization
- **01_ui_constants.jsfx-inc**: Layout, colors, dimensions
- **02_ui_utils.jsfx-inc**: Utility functions (text, colors, coordinate conversion)
- **03_ui_threshold_lines.jsfx-inc**: Threshold visualization
- **04_ui_interaction.jsfx-inc**: Mouse handling, control interaction
- **05_ui_rendering.jsfx-inc**: Core rendering primitives
- **06_ui_controls.jsfx-inc**: Control definitions and layout
- **07-10**: Graph rendering (cache, curves, meters, display)
- **11_ui_orchestration.jsfx-inc**: Main UI rendering entry point

### Graphics Implementation

#### Rendering in @gfx Section
```jsfx
@gfx 2625 800  // Width x Height

// 1. Update mouse state
MOUSE_LEFT_BUTTON = mouse_cap & 1 ? 1 : 0;
MOUSE_CTRL_KEY = mouse_cap & 4 ? 1 : 0;

// 2. Update histograms
update_histogram_state(gr_db_for_histogram);

// 3. Render interface
render_complete_interface();

// 4. Render debug info
debug_render();
```

#### Layout Constants (from `04_UI/01_ui_constants.jsfx-inc`)
```jsfx
GFX_WIDTH = 2625;
GFX_HEIGHT = 338 + HEADER_TOTAL_HEIGHT;
GRAPH_X = 695;
GRAPH_Y = 77;
GRAPH_SIZE = 263;
```

#### Mouse Interaction (in `04_UI/04_ui_interaction.jsfx-inc`)
```jsfx
// Mouse state variables
mouse_x, mouse_y  // Position
mouse_cap         // Button/modifier bitfield

// Button masks
mouse_cap & 1   // Left button
mouse_cap & 2   // Right button
mouse_cap & 4   // Ctrl/Cmd
mouse_cap & 8   // Shift
mouse_cap & 16  // Alt
mouse_cap & 64  // Middle button
```

#### Color Definitions (RGB format, 0-1 range)
```jsfx
BACKGROUND_R = 0.12; BACKGROUND_G = 0.12; BACKGROUND_B = 0.13;
ACCENT_R = 0.3; ACCENT_G = 0.5; ACCENT_B = 0.9;
```

#### Rendering Order
1. Background
2. Header
3. UI Panel (controls)
4. Graph (grid, curve, points, meters)
5. Threshold lines
6. Interactive feedback (hover states, drag indicators)
7. Debug panel (if enabled)

### Coordinate Systems

#### Graph Coordinates
- **dB to graph Y**: `db_to_graph_y(db)` - converts dB (-80 to 20) to pixel Y (0 to GRAPH_SIZE)
- **Graph Y to dB**: `graph_y_to_db(y)` - converts pixel Y to dB value
- **Graph origin**: Top-left at (GRAPH_X, GRAPH_Y)
- **Y-axis**: Inverted (0 = top, GRAPH_SIZE = bottom)

#### Control Layout
- Controls defined in `control_defs[]` array (in `04_UI/06_ui_controls.jsfx-inc`)
- Each control: x, y, width, height, type, linked_slider
- Hit testing: `is_point_in_rect(mx, my, x, y, w, h)`

## Debug System

### Debug Logging Functions (in `01_Utils/03_debug_logging.jsfx-inc`)

**CRITICAL**: Each debug function has a FIXED number of parameters. Using the wrong number will cause "needs X parms" errors.

#### Available Debug Functions:
```jsfx
// 1 parameter: message string only
debug_log(message)

// Only debug_log() is available - use sprintf + debug_log for formatted messages

// Utility functions
debug_separator()     // 0 parameters
debug_clear()         // 0 parameters  
debug_get_message_count()  // 0 parameters
```

#### Parameter Requirements - EXACTLY:
- `debug_log()` - **EXACTLY 1 parameter**: message string only

#### Debug Usage Pattern:
```jsfx
// For simple messages
debug_log("Processing started");

// For formatted messages with variables, use sprintf + debug_log
sprintf(#debug_temp_str, "Value: %.2f", single_value);
debug_log(#debug_temp_str);

// For multiple values
sprintf(#debug_temp_str, "Values: %.2f, %.2f", val1, val2);
debug_log(#debug_temp_str);
```

#### Common Errors to Avoid:
```jsfx
// WRONG - debug_logf doesn't exist
debug_logf("Value: %.2f", single_value);  // ERROR: undefined function

// CORRECT - use sprintf + debug_log
sprintf(#debug_temp_str, "Value: %.2f", single_value);
debug_log(#debug_temp_str);
```

#### Usage Examples:
```jsfx
debug_log("Processing started");
sprintf(#debug_temp_str, "Attack time: %.1f ms", attack_ms);
debug_log(#debug_temp_str);
sprintf(#debug_temp_str, "Slider %d value: %.3f", slider_index, slider_value);
debug_log(#debug_temp_str);
sprintf(#debug_temp_str, "Point %d at (%.1f, %.1f)", point_index, x, y);
debug_log(#debug_temp_str);
debug_separator();
```

### Debug Rendering
- Automatically renders in @gfx if `menu_debug_enabled = 1`
- Shows message buffer, variable values, performance stats
- Located at bottom of UI
- Includes scrolling support with mouse wheel

## State Management

### State Variables (in `01_Utils/06_state.jsfx-inc`)
All processing state variables initialized in `init_state_variables()`:
- Envelope state (`envelope_state_L`, `envelope_state_R`)
- Filter state (coefficients and delay lines)
- RMS state (circular buffer pointers, accumulated values)
- Lookahead buffer state (write position)
- Histogram state (bins, decay)
- UI state (hover flags, drag state, selected point)

### Preserving State Across Reloads
```jsfx
@serialize
ext_noinit = 1.0;  // Prevent clearing variables/memory in @init

// Save/load custom state
file_var(0, num_points);
i = 0;
loop(num_points,
  file_var(0, graph_points[i*2]);
  file_var(0, graph_points[i*2 + 1]);
  i += 1;
);
```

## Plugin Delay Compensation (PDC)

### Setting PDC (in @slider section)
```jsfx
@slider
// Calculate lookahead delay in samples
pdc_delay = min(lookahead_ms * 0.001 * srate, max_lookahead_samples) | 0;

// Configure PDC for stereo
pdc_delay > 0 ? (
  pdc_bot_ch = 0;  // Bottom channel (left)
  pdc_top_ch = 2;  // Top channel + 1 (right)
);
```

### PDC Rules
- Must set in @slider (not @block or @sample)
- Must set unconditionally every time @slider executes
- `pdc_bot_ch` = first channel (0 for left)
- `pdc_top_ch` = last channel + 1 (2 for stereo)
- REAPER handles automatic delay compensation to align with other tracks

## Common Patterns

### Safe Division
```jsfx
result = numerator / (denominator + EPS);
```

### Circular Buffer
```jsfx
// Write
buffer[write_pos] = value;
write_pos = (write_pos + 1) % buffer_size;

// Read (with delay)
read_pos = (write_pos - delay + buffer_size) % buffer_size;
delayed_value = buffer[read_pos];
```

### Exponential Smoothing
```jsfx
smoothed = smoothed + (target - smoothed) * (1 - coeff);
// where coeff = exp(-1 / (time_constant * srate))
```

### Envelope Following
```jsfx
input_level > envelope ? (
  // Attack
  envelope += (input_level - envelope) * (1 - attack_coeff);
) : (
  // Release  
  envelope += (input_level - envelope) * (1 - release_coeff);
);
```

### Soft Clipping
```jsfx
function soft_clip(x) (
  x > 1 ? (1 + tanh(x - 1)) :
  x < -1 ? (-1 + tanh(x + 1)) :
  x
);
```

## Error Prevention

### Common Mistakes to Avoid
1. **Using PI instead of $pi** - Always use built-in `$pi`
2. **Calculating coefficients in @sample** - Calculate in @block
3. **Not calling freembuf()** - Always call after allocating memory
4. **Forgetting PDC in @slider** - Must set every time @slider runs
5. **Using slider1 instead of named variable** - Use `attack_ms`, not `slider1`
6. **Not clamping values** - Always clamp to valid ranges
7. **Division by zero** - Add EPS to denominators
8. **Circular dependencies** - Follow directory hierarchy
9. **Forgetting @serialize** - Add if you want state preserved
10. **Not checking stage flags** - Use to bypass disabled processing
11. **Wrong debug function usage** - Only `debug_log(msg)` exists, use `sprintf()` + `debug_log()` for formatted messages
