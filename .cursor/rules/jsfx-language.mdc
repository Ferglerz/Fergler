---
alwaysApply: true
---

# JSFX Language Syntax and Execution Model

## Language Fundamentals
- All variables are **case-insensitive floating point numbers** - no declaration needed
- Power operator is `^` (not `**`)
- Modulo operator is `%`
- Conditionals use ternary syntax: `condition ? true_expr : false_expr`
- Multi-statement blocks use parentheses: `(stmt1; stmt2; result)`
- Loop syntax: `loop(count, ...)` and `while(...)`
- Memory access via arrays: `buffer[index]`
- Comments: `//` for single line, `/* */` for multi-line

## Special Variables
- `spl0` and `spl1` - left/right audio samples in @sample section (range -1 to 1)
- `srate` - current sample rate
- `samplesblock` - block size in @block section (128-1024 samples)
- `slider1` through `slider64` - effect parameters
- `mouse_x`, `mouse_y`, `mouse_cap` - mouse interaction in @gfx
- `$pi` - built-in pi constant (**always use this, never define your own PI**)

## Execution Sections (in order)
1. **@init** - Executes once on plugin load
2. **@slider** - Executes on load and whenever parameters change
3. **@block** - Executes before each audio block (use instead of @sample when possible for performance)
4. **@sample** - Executes for every single sample (most CPU intensive)
5. **@serialize** - Handles preset save/load operations
6. **@gfx** - Graphics rendering for UI updates

## Slider Definitions
- Format: `slider1:variable_name<min,max,inc>Description`
- Named values: `slider1:0<0,2,1{off,on,value}>name`
- The variable name after the colon becomes the actual variable to use in code
- Example: `slider1:attack_ms<0.1,100,0.1>Attack Time (ms)` creates `attack_ms` variable

## Memory Constraints
- Each effect has 1,048,576 slots of local memory
- FFT/DSP operations must NOT cross 16,384 item boundaries
- Use `freembuf(top)` to manage memory efficiently# JSFX Language Syntax and Execution Model

## Language Fundamentals
- All variables are **case-insensitive floating point numbers** - no declaration needed
- Power operator is `^` (not `**`)
- Modulo operator is `%`
- Conditionals use ternary syntax: `condition ? true_expr : false_expr`
- Multi-statement blocks use parentheses: `(stmt1; stmt2; result)`
- Loop syntax: `loop(count, ...)` and `while(...)`
- Memory access via arrays: `buffer[index]`
- Comments: `//` for single line, `/* */` for multi-line

## Special Variables
- `spl0` and `spl1` - left/right audio samples in @sample section (range -1 to 1)
- `srate` - current sample rate
- `samplesblock` - block size in @block section (128-1024 samples)
- `slider1` through `slider64` - effect parameters
- `mouse_x`, `mouse_y`, `mouse_cap` - mouse interaction in @gfx
- `$pi` - built-in pi constant (**always use this, never define your own PI**)

## Execution Sections (in order)
1. **@init** - Executes once on plugin load
2. **@slider** - Executes on load and whenever parameters change
3. **@block** - Executes before each audio block (use instead of @sample when possible for performance)
4. **@sample** - Executes for every single sample (most CPU intensive)
5. **@serialize** - Handles preset save/load operations
6. **@gfx** - Graphics rendering for UI updates

## Slider Definitions
- Format: `slider1:variable_name<min,max,inc>Description`
- Named values: `slider1:0<0,2,1{off,on,value}>name`
- The variable name after the colon becomes the actual variable to use in code
- Example: `slider1:attack_ms<0.1,100,0.1>Attack Time (ms)` creates `attack_ms` variable

## Memory Constraints
- Each effect has 1,048,576 slots of local memory
- FFT/DSP operations must NOT cross 16,384 item boundaries
- Use `freembuf(top)` to manage memory efficiently