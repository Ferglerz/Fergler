// DSP Utilities Module
// Digital Signal Processing utility functions
// Depends on: 02a_math_utils.jsfx-inc, 02b_audio_utils.jsfx-inc

@init

//==============================================================================
// FILTER COEFFICIENT CALCULATIONS
//==============================================================================

function calc_biquad_hp(freq) (
  w = 2 * $pi * freq * SRATE_INV;
  cosw = cos(w);
  sinw = sin(w);
  alpha = sinw / sqrt(2);

  b0 = (1 + cosw) / 2;
  b1 = -(1 + cosw);
  b2 = (1 + cosw) / 2;
  a0 = 1 + alpha;
  a1 = -2 * cosw;
  a2 = 1 - alpha;

  a1 /= a0; a2 /= a0; b0 /= a0; b1 /= a0; b2 /= a0;
);

function calc_biquad_lp(freq) (
  w = 2 * $pi * freq * SRATE_INV;
  cosw = cos(w);
  sinw = sin(w);
  alpha = sinw / sqrt(2);

  b0 = (1 - cosw) / 2;
  b1 = 1 - cosw;
  b2 = (1 - cosw) / 2;
  a0 = 1 + alpha;
  a1 = -2 * cosw;
  a2 = 1 - alpha;

  a1 /= a0; a2 /= a0; b0 /= a0; b1 /= a0; b2 /= a0;
);


//==============================================================================
// ENVELOPE PROCESSING UTILITIES
//==============================================================================

// Calculate time constant from time in seconds
function time_to_coefficient(time_seconds) (
  time_seconds > 0 ? exp(-1 / (time_seconds * srate)) : 0
);

// Calculate time constant from time in milliseconds
function ms_to_coefficient(time_ms) (
  time_ms > 0 ? exp(-1000 / (time_ms * srate)) : 0
);

// Apply curve modification to time constant
function apply_curve_to_coefficient(coeff, curve) (
  curve != 0 ? pow(coeff, pow(2, curve)) : coeff
);

//==============================================================================
// LOOKAHEAD PROCESSING UTILITIES
//==============================================================================

// Calculate lookahead delay samples
function calculate_lookahead_samples(lookahead_ms) (
  clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples)
);

// Calculate RMS window samples
function calculate_rms_samples(rms_ms) (
  clamp(floor(rms_ms * 0.001 * srate), 1, max_rms_samples)
);

//==============================================================================
// SOFT CLIPPING AND LIMITING
//==============================================================================

function soft_clip_limiter(input, prev_sample) local(oversample1, oversample2, peak_detected, limited) (
  // 2x oversampling for inter-sample peak detection
  oversample1 = (input + prev_sample) * 0.5;
  oversample2 = input;

  // Detect peaks above threshold
  peak_detected = max(abs(oversample1), abs(oversample2)) > 0.95;

  peak_detected ? (
    // Soft clipping using tanh
    limited = tanh(input * 0.95) * (1.0 / tanh(0.95));
  ) : (
    limited = input;
  );

  limited
);
