// Harmonic Processing Models Module
// Harmonic generation algorithms, character-specific processing, and harmonic application
// Depends on: 00b_math_utils.jsfx-inc, 00c_audio_utils.jsfx-inc

@init

// Enhanced harmonic algorithms integrated into apply_harmonic_processing() function

//==============================================================================
// HARMONIC PROCESSING APPLICATION
//==============================================================================

function apply_harmonic_processing(input, gr_amount, envelope_amount, detector_level, type, amount, drive, mix, even_boost, odd_boost) (
  // No processing if harmonic type is off or amount is zero
  type == 0 || amount <= 0.0001 ? (
    input
  ) : (
    dry_signal = input;
    driven = input * drive;

    type == 1 ? ( // Tube Even (Simple)
      processed = tanh(abs(driven)) * (driven < 0 ? -1 : 1);
      even_proc = processed * (1 + even_boost);
      processed = even_proc;
    ) : type == 2 ? ( // Tube Odd (Simple)
      processed = tanh(driven);
      odd_proc = processed * (1 + odd_boost);
      processed = odd_proc;
    ) : type == 3 ? ( // Tube Both (Simple)
      even_proc = tanh(abs(driven)) * (driven < 0 ? -1 : 1) * (1 + even_boost);
      odd_proc = tanh(driven) * (1 + odd_boost);
      processed = 0.5 * (even_proc + odd_proc);
    ) : type == 4 ? ( // Tape Saturation
      asymL = driven * (driven > 0 ? 1.02 : 0.98);
      processed = atan(asymL) / ($pi/2);
      // Apply even/odd boost to tape saturation components
      processed = processed * (1 + 0.5 * (even_boost + odd_boost));
    ) : type == 5 ? ( // Enhanced Tube (Sophisticated)
      // Use envelope and GR information for dynamic saturation
      scaled_saturation = amount * (1 + abs(gr_amount) * 0.3) * (1 + envelope_amount * 0.2);
      x = driven * (1 + scaled_saturation * 0.3);
      x2 = x * x;
      x4 = x2 * x2;
      
      // Dynamic clipping threshold based on compression
      clip_threshold = 0.7 / (1 + scaled_saturation * 0.3);
      x > clip_threshold ? x = clip_threshold + (x - clip_threshold) / (1 + sqr((x - clip_threshold) * 4));
      x < -clip_threshold ? x = -clip_threshold + (x + clip_threshold) / (1 + sqr((x + clip_threshold) * 4));
      
      // Explicit harmonic generation with boost controls
      processed = x + x2 * scaled_saturation * 0.1 * (1 + even_boost) + 
                  x4 * scaled_saturation * 0.02 * (1 + even_boost * 0.5);
      
      // Add subtle odd harmonics if odd_boost is used
      odd_boost > 0 ? (
        x3 = x2 * x;
        processed += x3 * scaled_saturation * 0.05 * odd_boost;
      );
    ) : type == 6 ? ( // FET (Solid State)
      // FET harmonics respond to compression amount and detector level
      scaled_compression = amount * (1 + abs(gr_amount) * 0.4) * (1 + detector_level * 0.3);
      x = driven;
      x3 = x * x * x;
      x5 = x3 * x * x;
      
      // Hard clipping characteristic of FET circuits
      scaled_compression > 0.3 ? (
        clip_point = 0.8 / (1 + scaled_compression * 0.5);
        x > clip_point ? x = clip_point + (x - clip_point) * 0.1;
        x < -clip_point ? x = -clip_point + (x + clip_point) * 0.1;
      );
      
      // Odd harmonic generation with boost control
      processed = x + x3 * scaled_compression * 0.08 * (1 + odd_boost) + 
                  x5 * scaled_compression * 0.015 * (1 + odd_boost * 0.5);
      
      // Add subtle even harmonics if even_boost is used
      even_boost > 0 ? (
        x2 = x * x;
        processed += x2 * scaled_compression * 0.03 * even_boost;
      );
    ) : ( // Clean Drive (type == 7)
      // Clean processing with minimal harmonic generation
      // Responds to envelope for dynamic drive amount
      dynamic_drive = drive * (1 + envelope_amount * 0.1);
      processed = driven * (dynamic_drive / drive);
      
      // Very subtle saturation at high levels
      abs(processed) > 0.8 ? (
        processed = processed > 0 ? 
          0.8 + (processed - 0.8) * 0.1 : 
          -0.8 + (processed + 0.8) * 0.1;
      );
    );

    // Improved level management with proper drive compensation
    processed = processed / max(drive, 1);

    // Apply amount (intensity) - enhanced with envelope information
    base_intensity = amount * (1 + abs(gr_amount) * 0.5);
    envelope_modulation = envelope_amount * 0.2; // Subtle envelope modulation
    intensity = base_intensity * (1 + envelope_modulation);
    
    wet_signal = dry_signal + intensity * (processed - dry_signal);

    // Final dry/wet mix
    dry_signal * (1 - mix) + wet_signal * mix
  )
);

//==============================================================================
// HARMONIC UTILITIES
//==============================================================================

function get_harmonic_type_name(type) (
  type == 0 ? name = "Off" :
  type == 1 ? name = "Tube Even" :
  type == 2 ? name = "Tube Odd" :
  type == 3 ? name = "Tube Both" :
  type == 4 ? name = "Tape Saturation" :
  type == 5 ? name = "Enhanced Tube" :
  type == 6 ? name = "FET" :
  type == 7 ? name = "Clean Drive" :
  name = "Unknown";
  name;
);

function get_harmonic_type_count() (
  8; // 0-7 types available
);

function is_harmonic_processing_enabled() (
  harmonic_type > 0 && harmonic_amount > 0;
);
