// Harmonic Processing Models Module
// Harmonic generation algorithms, character-specific processing, and harmonic application
// Depends on: 02a_math_utils.jsfx-inc, 02b_audio_utils.jsfx-inc

@init

//==============================================================================
// HARMONIC GENERATION ALGORITHMS
//==============================================================================

function generate_tube_harmonics(input, saturation_amount, intensity_factor) (
  scaled_saturation = saturation_amount * intensity_factor;
  x = input * (1 + scaled_saturation * 0.3);
  x2 = x * x;

  clip_threshold = 0.7 / (1 + scaled_saturation * 0.3);
  x > clip_threshold ? x = clip_threshold + (x - clip_threshold) / (1 + sqr((x - clip_threshold) * 4 * intensity_factor));
  x < -clip_threshold ? x = -clip_threshold + (x + clip_threshold) / (1 + sqr((x + clip_threshold) * 4 * intensity_factor));

  harmonic_content = x + x2 * scaled_saturation * 0.1 + x2 * x2 * scaled_saturation * 0.02;
  harmonic_content
);

function generate_fet_harmonics(input, compression_amount, intensity_factor) (
  scaled_compression = compression_amount * intensity_factor;
  x = input;
  x3 = x * x * x;
  x5 = x3 * x * x;

  scaled_compression > 0.3 / intensity_factor ? (
    clipped = x;
    clip_point = 0.8 / (1 + scaled_compression * 0.5);
    clipped > clip_point ? clipped = clip_point + (clipped - clip_point) * (0.1 / intensity_factor);
    clipped < -clip_point ? clipped = -clip_point + (clipped + clip_point) * (0.1 / intensity_factor);
    x = clipped;
  );

  x + x3 * scaled_compression * 0.08 + x5 * scaled_compression * 0.015
);

//==============================================================================
// CHARACTER-SPECIFIC HARMONIC PROCESSING
//==============================================================================

function apply_tube_character_harmonics(input, drive_amount, even_boost, odd_boost) (
  driven = input * drive_amount;
  
  // Tube even harmonics
  even_proc = tanh(abs(driven)) * (driven < 0 ? -1 : 1);
  even_proc = even_proc * (1 + even_boost);
  
  // Tube odd harmonics
  odd_proc = tanh(driven);
  odd_proc = odd_proc * (1 + odd_boost);
  
  // Combine both
  processed = 0.5 * (even_proc + odd_proc);
  
  // Scale back by drive to maintain levels
  processed / max(drive_amount, 1);
);

function apply_tape_character_harmonics(input, drive_amount, even_boost, odd_boost) (
  driven = input * drive_amount;
  
  // Asymmetric saturation for tape character
  asymL = driven * (driven > 0 ? 1.02 : 0.98);
  processed = atan(asymL) / ($pi/2);
  
  // Apply even/odd boost to tape saturation components
  processed * (1 + 0.5 * (even_boost + odd_boost));
);

function apply_clean_harmonics(input, drive_amount) (
  // Clean processing - minimal harmonic generation
  input * drive_amount;
);

//==============================================================================
// HARMONIC PROCESSING APPLICATION
//==============================================================================

function apply_harmonic_processing(input, gr_amount, type, amount, drive, mix, even_boost, odd_boost) (
  // No processing if harmonic type is off or amount is zero
  type == 0 || amount <= 0.0001 ? (
    input
  ) : (
    dry_signal = input;
    driven = input * drive;

    type == 1 ? ( // Tube Even
      processed = tanh(abs(driven)) * (driven < 0 ? -1 : 1);
      even_proc = processed * (1 + even_boost);
      processed = even_proc;
    ) : type == 2 ? ( // Tube Odd
      processed = tanh(driven);
      odd_proc = processed * (1 + odd_boost);
      processed = odd_proc;
    ) : type == 3 ? ( // Tube Both
      even_proc = tanh(abs(driven)) * (driven < 0 ? -1 : 1) * (1 + even_boost);
      odd_proc = tanh(driven) * (1 + odd_boost);
      processed = 0.5 * (even_proc + odd_proc);
    ) : ( // Tape Saturation
      asymL = driven * (driven > 0 ? 1.02 : 0.98);
      processed = atan(asymL) / ($pi/2);
      // Apply even/odd boost to tape saturation components
      processed = processed * (1 + 0.5 * (even_boost + odd_boost));
    );

    // Scale back by drive to maintain levels
    processed = processed / max(drive, 1);

    // Apply amount (intensity) - this is driven by gain reduction amount
    intensity = amount * (1 + gr_amount * 0.5); // More harmonics with more GR
    wet_signal = dry_signal + intensity * (processed - dry_signal);

    // Final dry/wet mix
    dry_signal * (1 - mix) + wet_signal * mix
  )
);

//==============================================================================
// HARMONIC UTILITIES
//==============================================================================

function get_harmonic_type_name(type) (
  type == 0 ? name = "Off" :
  type == 1 ? name = "Tube Even" :
  type == 2 ? name = "Tube Odd" :
  type == 3 ? name = "Tube Both" :
  type == 4 ? name = "Tape Saturation" :
  name = "Unknown";
  name;
);

function get_harmonic_type_count() (
  5; // 0-4 types available
);

function is_harmonic_processing_enabled() (
  harmonic_type > 0 && harmonic_amount > 0;
);

function calculate_harmonic_intensity(gr_amount) (
  intensity = harmonic_amount * (1 + gr_amount * 0.5);
  intensity;
);

function get_harmonic_parameters() (
  type = harmonic_type;
  amount = harmonic_amount;
  drive = harmonic_drive;
  mix = harmonic_mix;
  even_boost = harmonic_even_boost;
  odd_boost = harmonic_odd_boost;
  // Return amount as representative since JSFX doesn't support multiple returns
  amount;
);
