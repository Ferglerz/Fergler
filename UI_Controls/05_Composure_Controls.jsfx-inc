// Composure-Specific Control Layout
// Defines the control layout for the Composure compressor plugin
// Dependencies: UI_Sliders/01_control_definitions.jsfx-inc

@init

//==============================================================================
// IMAGE SET OBJECTS (Namespace-based)
//==============================================================================
//
// Image set objects provide a convenient way to store all properties for an
// image set (e.g., parallax fader images) in one place, similar to Slider objects.
// This allows easy reuse and maintenance of image set configurations.
//

//------------------------------------------------------------------------------
// Constructor for an image set "object"
//------------------------------------------------------------------------------
// Fields populated:
//   this.image_top_index  - Image index for top layer
//   this.image_bot_index  - Image index for bottom layer
//   this.image_w          - Image width in pixels
//   this.image_h          - Image height in pixels
//   this.para_depth       - Parallax depth (affects top image travel distance)
//   this.y_offset         - Y offset to lower images (accounts for shadows)
//   this.x_offset         - Manual X offset for bottom image
//   this.image_scale      - Scale factor for images (1.0 = no scaling)
function construct_image_set(image_top_index, image_bot_index, image_w, image_h, para_depth, y_offset, x_offset, image_scale) instance(image_top_index image_bot_index image_w image_h para_depth y_offset x_offset image_scale)
(
  this.image_top_index = image_top_index;
  this.image_bot_index = image_bot_index;
  this.image_w = image_w;
  this.image_h = image_h;
  this.para_depth = para_depth;
  this.y_offset = y_offset;
  this.x_offset = x_offset;
  this.image_scale = image_scale;
);

//==============================================================================
// PARALLAX FADER CONSTANTS
//==============================================================================

// Hard-coded parallax depth (original value 10, minus 7 = 3)
PARALLAX_DEPTH = 3;

//==============================================================================
// IMAGE SET INITIALIZATION
//==============================================================================

// Initialize left parallax fader image set object
// Images: para_horz_fader_top (index 3), para_horz_fader_bot_left (index 4)
sm_fader_left.construct_image_set(3, 4, 36, 45, PARALLAX_DEPTH, 11, -PARALLAX_DEPTH+2, 1.0);

// Initialize right parallax fader image set object
// Images: para_horz_fader_top (index 3), para_horz_fader_bot_right (index 5)
sm_fader_rt.construct_image_set(3, 5, 36, 45, PARALLAX_DEPTH, 11, PARALLAX_DEPTH, 1.0);

//==============================================================================
// STEP-POINT ARRAYS FOR SLIDERS
//==============================================================================

// Step-point definitions as comma-separated strings
// Attack slider: 0.01ms to 5000ms (67 values)
#attack_step_points_str = "0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,2,3,4,5,6,7,8,9,10,15,20,25,30,35,40,45,50,60,70,80,90,100,125,150,175,200,225,250,300,350,400,450,500,600,700,800,900,1000,1250,1500,1750,2000,2500,3000,3500,4000,4500,5000";

// Release slider: same as attack (67 values)
#release_step_points_str = "0.01,0.02,0.03,0.04,0.05,0.06,0.07,0.08,0.09,0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1,2,3,4,5,6,7,8,9,10,15,20,25,30,35,40,45,50,60,70,80,90,100,125,150,175,200,225,250,300,350,400,450,500,600,700,800,900,1000,1250,1500,1750,2000,2500,3000,3500,4000,4500,5000";

// HP Filter: 0=Off, then 20Hz to 6kHz (28 values)
#hp_step_points_str = "0,20,30,40,60,80,100,120,150,200,250,300,350,400,500,600,750,1000,1250,1500,1750,2000,2500,3000,3500,4000,5000,6000";

// LP Filter: 20Hz to 14kHz, then 0=Off (32 values)
#lp_step_points_str = "20,30,40,60,80,100,120,150,200,250,300,350,400,500,600,750,1000,1250,1500,1750,2000,2500,3000,3500,4000,5000,6000,8000,10000,12000,14000,0";

// Lookahead: 0=Off first, then 1ms to 2000ms (39 values)
#lookahead_step_points_str = "0,1,2,3,4,5,6,7,8,9,10,15,20,25,30,40,50,60,70,80,90,100,150,200,250,300,400,500,600,700,800,900,1000,1250,1500,1750,2000";

// Array base addresses are defined in UI_General/02_ui_utils.jsfx-inc for early access
// Step-point counts will be set by parsing function below

// Helper function to parse comma-separated step-point string into array
// Returns the count of parsed values
function parse_step_points_string(step_points_str, step_points_base) local(
  str_len, opt_count, option_start, pos, current_char, len, temp_slot, numeric_value
) (
  str_len = strlen(step_points_str);
  opt_count = 0;
  option_start = 0;
  pos = 0;
  
  // Parse all values (comma-separated)
  while (pos <= str_len) (
    current_char = str_getchar(step_points_str, pos);
    (current_char == 44 || pos == str_len) ? (  // 44 = comma character
      len = pos - option_start;
      len > 0 ? (
        // Extract substring and convert to number
        temp_slot = 50;  // Use temp string slot
        strcpy_substr(temp_slot, step_points_str, option_start, len);
        numeric_value = string_to_number(temp_slot);
        // Store in array
        step_points_base[opt_count] = numeric_value;
        opt_count += 1;
        option_start = pos + 1;
      );
    );
    pos += 1;
  );
  opt_count;
);

// Initialize step-point arrays from strings
// Allocates memory inline using freemem and parses step points
// Maximum step count is 67 (attack/release), allocate 100 slots per array for future expansion
function init_step_points() (
  // Allocate step-point arrays inline
  attack_step_points_base = freemem; freemem += 100;
  release_step_points_base = freemem; freemem += 100;
  hp_step_points_base = freemem; freemem += 100;
  lp_step_points_base = freemem; freemem += 100;
  lookahead_step_points_base = freemem; freemem += 100;
  
  // Parse step points into allocated arrays
  attack_step_count = parse_step_points_string(#attack_step_points_str, attack_step_points_base);
  release_step_count = parse_step_points_string(#release_step_points_str, release_step_points_base);
  hp_step_count = parse_step_points_string(#hp_step_points_str, hp_step_points_base);
  lp_step_count = parse_step_points_string(#lp_step_points_str, lp_step_points_base);
  lookahead_step_count = parse_step_points_string(#lookahead_step_points_str, lookahead_step_points_base);
);
lookahead_step_count = parse_step_points_string(#lookahead_step_points_str, lookahead_step_points_base);

//==============================================================================
// COMPOSURE CONTROL LAYOUT
//==============================================================================
//
// This module defines the specific control layout for the Composure compressor.
// It uses the generic control definition functions from the Sliders library
// to create groups and controls specific to this plugin.
//
// GROUPS:
//   0: ENVELOPE - Attack, Attack Curve, Hold, Release, Release Curve, Prog Release
//   1: DETECTION - Time Unit, RMS Window, RMS Norm, Det. Mode, Lookahead
//   2: COMPRESSION - Strength, Offset
//   3: HARMONICS - Type, Drive, Mix, Even, Odd
//   4: SOURCE - Sidechain, Listen, Highpass, Lowpass
//

//==============================================================================
// MAIN CONTROL LAYOUT SETUP
//==============================================================================

function setup_control_layout() local(group_x, group_y, rel_x, rel_y, row, group_w, group_h, group_spacing, rel_x_slider, rel_x_button, rel_x_dropdown) (
  // Initialize group positioning
  group_x = UI_PANEL_X + 15;
  group_y = UI_PANEL_Y + 15;
  group_spacing = 15;  // Space between groups
  
  //==============================================================================
  // GROUP 0: ENVELOPE
  //==============================================================================
  group_w = 150;  // Increased from 125
  group_h = GRAPH_SIZE;  // Match graph height
  define_group(0, group_x, group_y, group_w, group_h, 1, "ENVELOPE");
  set_control_group(0);  // Associate following controls with group 0
  
  // Controls positioned relative to group (will add group position when rendering)
  // Center controls horizontally within group, shifted left by 11 pixels
  rel_x_slider = (group_w - SLIDER_W) / 2 ;
  rel_y = GROUP_TITLE_HEIGHT + GROUP_PADDING + 15;  // +15 pixels to make room for group header
  row = 0;
  
  // Attack slider (index 0, param 1) - ms suffix, stepped slider using parallax fader
  define_parallax_fader(0, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 1, S1.min, S1.max, S1.label, sm_fader_left.image_top_index, sm_fader_left.image_bot_index, sm_fader_left.image_w, sm_fader_left.image_h, sm_fader_left.para_depth, sm_fader_left.y_offset, sm_fader_left.x_offset, sm_fader_left.image_scale, " ms", FORMAT_NORMAL, 0, DISPLAY_NORMAL);
  row += 1;
  // Attack Curve: using parallax fader - uses sm_fader_left image set
  define_parallax_fader(1, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 2, S2.min, S2.max, S2.label, sm_fader_left.image_top_index, sm_fader_left.image_bot_index, sm_fader_left.image_w, sm_fader_left.image_h, sm_fader_left.para_depth, sm_fader_left.y_offset, sm_fader_left.x_offset, sm_fader_left.image_scale, "", FORMAT_NORMAL, 0, DISPLAY_HIDE_VALUE);
  row += 1;
  // Hold slider (index 2, param 3) - ms suffix, using parallax fader
  define_parallax_fader(2, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 3, S3.min, S3.max, S3.label, sm_fader_left.image_top_index, sm_fader_left.image_bot_index, sm_fader_left.image_w, sm_fader_left.image_h, sm_fader_left.para_depth, sm_fader_left.y_offset, sm_fader_left.x_offset, sm_fader_left.image_scale, " ms", FORMAT_NORMAL, 0, DISPLAY_NORMAL);
  row += 1;

  // Release slider (index 3, param 4) - ms suffix, stepped slider using parallax fader
  define_parallax_fader(3, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 4, S4.min, S4.max, S4.label, sm_fader_left.image_top_index, sm_fader_left.image_bot_index, sm_fader_left.image_w, sm_fader_left.image_h, sm_fader_left.para_depth, sm_fader_left.y_offset, sm_fader_left.x_offset, sm_fader_left.image_scale, " ms", FORMAT_NORMAL, 0, DISPLAY_NORMAL);
  row += 1;
  // Release Curve: using parallax fader
  define_parallax_fader(4, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 5, S5.min, S5.max, S5.label, sm_fader_left.image_top_index, sm_fader_left.image_bot_index, sm_fader_left.image_w, sm_fader_left.image_h, sm_fader_left.para_depth, sm_fader_left.y_offset, sm_fader_left.x_offset, sm_fader_left.image_scale, "", FORMAT_NORMAL, 0, DISPLAY_NORMAL);
  row += 1;
  
  // Progressive Release Type - center dropdown, shifted left by 11 pixels
  rel_x_dropdown = (group_w - DROPDOWN_W) / 2 ;
  define_dropdown(5, rel_x_dropdown, rel_y + row * CONTROL_SPACING_Y - 10, DROPDOWN_W, DROPDOWN_H, 6, S6.min, S6.max, S6.label);
  
  //==============================================================================
  // GROUP 1: DETECTION
  //==============================================================================
  group_x += group_w + group_spacing;
  group_w = 150;  // Increased from 125
  group_h = GRAPH_SIZE;  // Match graph height
  define_group(1, group_x, group_y, group_w, group_h, 1, "DETECTION");
  set_control_group(1);  // Associate following controls with group 1
  
  // Center controls horizontally within group
  rel_x_slider = (group_w - SLIDER_W) / 2;
  rel_x_button = (group_w - BUTTON_W) / 2;
  rel_x_dropdown = (group_w - DROPDOWN_W) / 2;
  rel_y = GROUP_TITLE_HEIGHT + GROUP_PADDING + 15;  // +15 pixels to make room for group header
  row = 0;
  
  // Time Unit selector (index 6, param 7) - using image toggle
  // Images: toggle_left (index 1), toggle_right (index 2)
  define_image_button(6, rel_x_button, rel_y + row * CONTROL_SPACING_Y, BUTTON_W, BUTTON_H, 7, S7.min, S7.max, S7.label, 1, 2, 1);
  row += 1;
  
  // RMS Window with ms suffix (index 7, param 8) - using parallax fader
  define_parallax_fader(7, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 8, S8.min, S8.max, S8.label, sm_fader_left.image_top_index, sm_fader_left.image_bot_index, sm_fader_left.image_w, sm_fader_left.image_h, sm_fader_left.para_depth, sm_fader_left.y_offset, sm_fader_left.x_offset, sm_fader_left.image_scale, " ms", FORMAT_NORMAL, 0, DISPLAY_NORMAL);
  row += 1;
  // RMS Normalization button (index 8, param 9) - using image toggle
  // Images: toggle_left (index 1), toggle_right (index 2)
  define_image_button(8, rel_x_button, rel_y + row * CONTROL_SPACING_Y, BUTTON_W, BUTTON_H, 9, S9.min, S9.max, S9.label, 1, 2, 1);
  row += 1;
  // Detection Mode dropdown (index 9, param 10) - using image toggle
  // Images: toggle_left (index 1), toggle_right (index 2)
  define_image_button(9, rel_x_button, rel_y + row * CONTROL_SPACING_Y, BUTTON_W, BUTTON_H, 10, S10.min, S10.max, S10.label, 1, 2, 1);
  // Lookahead moved to header (removed from here)
  
  //==============================================================================
  // GROUP 2: COMPRESSION
  //==============================================================================
  group_x += group_w + group_spacing;
  group_w = 150;  // Increased from 125
  group_h = 130;  // Shortened to fit just 2 controls (2 * CONTROL_SPACING_Y + padding)
  define_group(2, group_x, group_y, group_w, group_h, 1, "COMPRESSION");
  set_control_group(2);  // Associate following controls with group 2
  
  // Center controls horizontally within group, shifted left by 11 pixels
  rel_x = (group_w - SLIDER_W) / 2 ;
  rel_y = GROUP_TITLE_HEIGHT + GROUP_PADDING + 15;  // +15 pixels to make room for group header
  row = 0;
  
  // Strength with percent suffix (index 11, param 13) - using parallax fader
  define_parallax_fader(11, rel_x, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 13, S13.min, S13.max, S13.label, sm_fader_left.image_top_index, sm_fader_left.image_bot_index, sm_fader_left.image_w, sm_fader_left.image_h, sm_fader_left.para_depth, sm_fader_left.y_offset, sm_fader_left.x_offset, sm_fader_left.image_scale, " %", FORMAT_NONE, 0, DISPLAY_NORMAL);
  // Input Offset moved to header (removed from here)
  
  //==============================================================================
  // GROUP 4: SOURCE (below COMPRESSION)
  //==============================================================================
  define_group(4, group_x, group_y + group_h + group_spacing, group_w, GRAPH_SIZE - group_h - group_spacing, 1, "SOURCE");
  set_control_group(4);  // Associate following controls with group 4
  
  // Center controls horizontally within group
  rel_x_slider = (group_w - SLIDER_W) / 2;
  rel_x_button = (group_w - BUTTON_W) / 2;
  rel_y = GROUP_TITLE_HEIGHT + GROUP_PADDING + 15;  // +15 pixels to make room for group header
  row = 0;
  
  // Sidechain button (index 13, param 15) - using image toggle
  // Images: toggle_left1.png (index 1), toggle_right1.png (index 2)
  // Scale: calculated to fit button (19/333 ≈ 0.057 for height, 60/501 ≈ 0.12 for width)
  // Using 0.057 to fit button height (image will be ~28.6x19, centered in 60x19 button)
  define_image_button(13, rel_x_button, rel_y + row * CONTROL_SPACING_Y, BUTTON_W, BUTTON_H, 15, S15.min, S15.max, S15.label, 1, 2, 1);
  row += 1;
  
  // Listen button (index 14, param 16)
  define_button(14, rel_x_button, rel_y + row * CONTROL_SPACING_Y, BUTTON_W, BUTTON_H, 16, S16.min, S16.max, S16.label);
  row += 1;
  
  // HP Filter with Hz suffix and k formatting (left-to-right fill) (index 15, param 17)
  // Enumerated slider: min=0, max=28 (29 options)
  define_slider(15, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 17, S17.min, S17.max, S17.label, create_ui_control(ORIENTATION_HORIZONTAL, DISPLAY_NORMAL, FILL_LEFT_TO_RIGHT, FORMAT_K, 0, " Hz", 15));
  row += 1;
  
  // LP Filter with Hz suffix and k formatting (right-to-left fill) (index 16, param 18)
  // Enumerated slider: min=0, max=31 (32 options)
  define_slider(16, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 18, S18.min, S18.max, S18.label, create_ui_control(ORIENTATION_HORIZONTAL, DISPLAY_NORMAL, FILL_RIGHT_TO_LEFT, FORMAT_K, 0, " Hz", 16));
  
  //==============================================================================
  // GROUP 3: HARMONICS (positioned to the right of graph and meter)
  //==============================================================================
  // Calculate position: graph right edge + meter width + indicator + spacing
  // Indicator radius is 5, with 1px border = 6px total from center
  group_x = GRAPH_X + GRAPH_SIZE + 15 + 23 + 8 + 6 + 15;  // graph + meter + indicator + spacing
  group_w = 150;  // Increased from 125
  group_h = GRAPH_SIZE;  // Match graph height
  define_group(3, group_x, group_y, group_w, group_h, 1, "HARMONICS");
  set_control_group(3);  // Associate following controls with group 3
  
  // Center controls horizontally within group
  rel_x_slider = (group_w - SLIDER_W) / 2;
  rel_x_dropdown = (group_w - DROPDOWN_W) / 2;
  rel_y = GROUP_TITLE_HEIGHT + GROUP_PADDING + 15;  // +15 pixels to make room for group header
  row = 0;
  
  // Type dropdown (index 17, param 19) - using image toggle
  // Images: toggle_left (index 1), toggle_right (index 2)
  // Note: 0=Off (left), 1-2=Tape/Tube (right)
  define_image_button(17, rel_x_button, rel_y + row * CONTROL_SPACING_Y, BUTTON_W, BUTTON_H, 19, S19.min, S19.max, S19.label, 1, 2, 1);
  row += 1;
  // Drive (index 18, param 20) - using parallax fader with right image set
  define_parallax_fader(18, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 20, S20.min, S20.max, S20.label, sm_fader_rt.image_top_index, sm_fader_rt.image_bot_index, sm_fader_rt.image_w, sm_fader_rt.image_h, sm_fader_rt.para_depth, sm_fader_rt.y_offset, sm_fader_rt.x_offset, sm_fader_rt.image_scale, "", FORMAT_NORMAL, 0, DISPLAY_NORMAL);
  row += 1;
  // Mix with percent suffix (index 19, param 21) - using parallax fader
  // Uses sm_fader_rt image set object for all image properties
  define_parallax_fader(19, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 21, S21.min, S21.max, S21.label, sm_fader_rt.image_top_index, sm_fader_rt.image_bot_index, sm_fader_rt.image_w, sm_fader_rt.image_h, sm_fader_rt.para_depth, sm_fader_rt.y_offset, sm_fader_rt.x_offset, sm_fader_rt.image_scale, " %", FORMAT_NONE, 0, DISPLAY_NORMAL);
  row += 1;
  // Even with percent suffix (index 20, param 22) - using parallax fader
  define_parallax_fader(20, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 22, S22.min, S22.max, S22.label, sm_fader_rt.image_top_index, sm_fader_rt.image_bot_index, sm_fader_rt.image_w, sm_fader_rt.image_h, sm_fader_rt.para_depth, sm_fader_rt.y_offset, sm_fader_rt.x_offset, sm_fader_rt.image_scale, " %", FORMAT_NONE, 0, DISPLAY_NORMAL);
  row += 1;
  // Odd with percent suffix (index 21, param 23) - using parallax fader
  define_parallax_fader(21, rel_x_slider, rel_y + row * CONTROL_SPACING_Y, SLIDER_W, SLIDER_H, 23, S23.min, S23.max, S23.label, sm_fader_rt.image_top_index, sm_fader_rt.image_bot_index, sm_fader_rt.image_w, sm_fader_rt.image_h, sm_fader_rt.para_depth, sm_fader_rt.y_offset, sm_fader_rt.x_offset, sm_fader_rt.image_scale, " %", FORMAT_NONE, 0, DISPLAY_NORMAL);
  
  // Compressor Type moved to header (will be defined in setup_header_controls)
);

//==============================================================================
// HEADER CONTROLS
//==============================================================================

function setup_header_controls() (
  // This must be called in @gfx when gfx_w is valid
  gfx_w > 0 ? (
    // Header controls are not in a group (absolute positioning)
    set_control_group(-1);
    
    // Calculate header slider Y position (centered vertically)
    header_slider_y = (HEADER_HEIGHT - SLIDER_H) / 2;
    
    // Lookahead slider (index 10, param 11) - just to the right of menu button
    // Menu button right edge: MENU_BUTTON_X + MENU_BUTTON_SIZE = 8 + 15 = 23
    // Add 5px spacing: 23 + 5 = 28
    lookahead_slider_x = MENU_BUTTON_X + MENU_BUTTON_SIZE + 5;
    define_slider(10, lookahead_slider_x, header_slider_y, SLIDER_W, SLIDER_H, 11, S11.min, S11.max, S11.label, create_ui_control(ORIENTATION_HORIZONTAL, DISPLAY_NORMAL, FILL_LEFT_TO_RIGHT, FORMAT_NORMAL, OPTION_HIDE_LABEL, " ms", 10));
    
    // Input Offset slider (index 12, param 14) - to the left of Makeup Gain
    // Makeup Gain is at: gfx_w - 5 - SLIDER_W
    // Input Offset should be: makeup_gain_x - SLIDER_W - 5 (5px spacing)
    makeup_gain_x = gfx_w - 5 - SLIDER_W;
    input_offset_x = makeup_gain_x - SLIDER_W - 5;
    define_slider(12, input_offset_x, header_slider_y, SLIDER_W, SLIDER_H, 14, S14.min, S14.max, S14.label, create_ui_control(ORIENTATION_HORIZONTAL, DISPLAY_NORMAL, FILL_LEFT_TO_RIGHT, FORMAT_NORMAL, OPTION_HIDE_LABEL, " dB", 12));
    
    // Makeup Gain slider (index 22, param 25) - update to hide label
    define_slider(22, makeup_gain_x, header_slider_y, SLIDER_W, SLIDER_H, 25, S25.min, S25.max, S25.label, create_ui_control(ORIENTATION_HORIZONTAL, DISPLAY_NORMAL, FILL_LEFT_TO_RIGHT, FORMAT_NORMAL, OPTION_BIDIRECTIONAL | OPTION_HIDE_LABEL, " dB", 22));
  );
);

//==============================================================================
// CONTROL RENDERING
//==============================================================================

function render_all_controls() (
  i = 0;
  while (i < control_count) (
    render_control(i);
    i += 1;
  );
);

