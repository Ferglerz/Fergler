// Detection Processing Module
// RMS detection, level processing, gain reduction calculation, and transient detection
// Depends on: 00b_math_utils.jsfx-inc, 00c_audio_utils.jsfx-inc, 00d_dsp_utils.jsfx-inc

@init

//==============================================================================
// RMS AND LEVEL DETECTION
//==============================================================================

function process_rms_detection(detect_l, detect_r) (
  // Debug: Log detection inputs occasionally
  DEBUG_ENABLED && (rms_pos % 4800 == 0) ? (
    debug_logf("RMS Detection: L=%.3f", detect_l);
    debug_logf("RMS Detection: R=%.3f", detect_r);
    debug_logf("RMS samples=%d", rms_samples);
  );
  
  // RMS calculation with optional normalization
  detect_squared = (detect_l * detect_l + detect_r * detect_r) * 0.5;
  rms_sum -= rms_buffer[rms_pos];
  rms_buffer[rms_pos] = detect_squared;
  rms_sum += detect_squared;
  rms_pos = (rms_pos + 1) % rms_samples;

  rms_level = sqrt(rms_sum / rms_samples);
  
  // Update display RMS level
  display_rms_level = rms_level;
  
  // Debug: Also store some debug values for display
  debug_detect_l = detect_l;
  debug_detect_r = detect_r;
  debug_rms_sum = rms_sum;

  // Apply RMS normalization if enabled
  rms_normalization > 0.5 ? (
    // Track running maximum for normalization
    rms_level > rms_max ? (rms_max = rms_level) : (rms_max = rms_max * 0.9999); // slow decay

    // Normalize RMS to 0..1 relative to running max
    normalized_rms = rms_level / (rms_max + eps);

    // Use peak detection for final level but shape with normalized RMS
    peak_level = max(abs(detect_l), abs(detect_r));
    detector_level = normalized_rms * peak_level;
  ) : (
    // Standard RMS or peak detection
    rms_size_ms > 0 ? (
      detector_level = rms_level;
    ) : (
      detector_level = max(abs(detect_l), abs(detect_r)); // peak mode when RMS window = 0
    );
  );

  detector_level
);

//==============================================================================
// LEVEL CALCULATION AND CURVE APPLICATION
//==============================================================================

//==============================================================================
// TRANSIENT DETECTION (1176-style)
//==============================================================================
// Detects rapid level increases and temporarily reduces gain reduction to let
// transients punch through. This is fundamentally different from attack time -
// it's dynamic attack that responds to transient content.
//
// How it works:
// - Monitors rate of level increase (dB per sample)
// - If level rises above threshold dB â†’ transient detected
// - Temporarily reduces GR by proportional amount
// - Creates "aggressive" compression that lets fast transients through
//==============================================================================

function detect_transients(current_level_db) (
  transient_detected = 0;
  transient_gr_reduction = 0;
  
  // Check if transient detection is enabled (slider value > 0)
  transient_detection > 0 ? (
    // Calculate rate of level increase
    level_delta = current_level_db - transient_detector_prev_db;
    
    // Check if level is rising above threshold
    level_delta > 0 && current_level_db > transient_threshold_db ? (
      // Transient detected! Calculate GR reduction
      // Slider: 0-100 maps to 0-12dB of GR reduction
      max_reduction = (transient_detection / 100.0) * 12.0;
      
      // Scale reduction by how far above threshold we are
      threshold_excess = current_level_db - transient_threshold_db;
      transient_gr_reduction = min(threshold_excess * 0.6, max_reduction);
      
      transient_detected = 1;
    );
    
    // Update previous level for next sample
    transient_detector_prev_db = current_level_db;
  ) : (
    // Transient detection off - just update tracker
    transient_detector_prev_db = current_level_db;
  );
  
  transient_gr_reduction
);

function calculate_gain_reduction(input_level_linear) (
  // Convert input level to dB for curve lookup
  input_level_db = linear_to_db(max(input_level_linear, MIN_DETECTOR_LEVEL));
  
  // Debug: Log gain reduction calculation occasionally
  DEBUG_ENABLED && (rms_pos % 4800 == 0) ? (
    debug_logf("GR Calc: input_linear=%.3f", input_level_linear);
    debug_logf("GR Calc: input_db=%.1f", input_level_db);
  );
  
  // Update display level for visualization
  current_input_db = input_level_db;
  
  // Apply compression curve - global offset should only shift the curve vertically
  target_output_db = interpolate_compression_curve(input_level_db) + global_offset_db;
  target_gr_db = target_output_db - input_level_db;

  // Apply strength and curves
  target_gr_db *= strength;

  strength_curve != 0 ? (
    gr_factor = abs(target_gr_db) / abs(max_gr_db);
    curve_factor = pow(gr_factor, pow(2, strength_curve));
    target_gr_db *= curve_factor;
  );

  target_gr_db = max(max_gr_db, target_gr_db);  // Use max, not min
  
  // Apply transient detection: reduce GR if transient detected
  transient_reduction = detect_transients(input_level_db);
  target_gr_db += transient_reduction;  // Add (reduces compression since GR is negative)

  // Update display GR for visualization
  current_gr_db = target_gr_db;

  target_gr_db
);

//==============================================================================
// DETECTION UTILITIES
//==============================================================================

function get_detector_level() (
  detector_level;
);
