// Detection Processing Module
// RMS detection, level processing, gain reduction calculation, and transient detection
// Depends on: 02a_math_utils.jsfx-inc, 02b_audio_utils.jsfx-inc, 02c_dsp_utils.jsfx-inc

@init

//==============================================================================
// RMS AND LEVEL DETECTION
//==============================================================================

function process_rms_detection(detect_l, detect_r) (
  // RMS calculation with optional normalization
  detect_squared = (detect_l * detect_l + detect_r * detect_r) * 0.5;
  rms_sum -= rms_buffer[rms_pos];
  rms_buffer[rms_pos] = detect_squared;
  rms_sum += detect_squared;
  rms_pos = (rms_pos + 1) % rms_samples;

  rms_level = sqrt(rms_sum / rms_samples);

  // Apply RMS normalization if enabled
  rms_normalization > 0.5 ? (
    // Track running maximum for normalization
    rms_level > rms_max ? (rms_max = rms_level) : (rms_max = rms_max * 0.9999); // slow decay

    // Normalize RMS to 0..1 relative to running max
    normalized_rms = rms_level / (rms_max + eps);

    // Use peak detection for final level but shape with normalized RMS
    peak_level = max(abs(detect_l), abs(detect_r));
    detector_level = normalized_rms * peak_level;
  ) : (
    // Standard RMS or peak detection
    rms_size_ms > 0 ? (
      detector_level = rms_level;
    ) : (
      detector_level = max(abs(detect_l), abs(detect_r)); // peak mode when RMS window = 0
    );
  );

  detector_level
);

//==============================================================================
// LEVEL CALCULATION AND CURVE APPLICATION
//==============================================================================

//==============================================================================
// TRANSIENT DETECTION (1176-style)
//==============================================================================
// Detects rapid level increases and temporarily reduces gain reduction to let
// transients punch through. This is fundamentally different from attack time -
// it's dynamic attack that responds to transient content.
//
// How it works:
// - Monitors rate of level increase (dB per sample)
// - If level rises above threshold dB â†’ transient detected
// - Temporarily reduces GR by proportional amount
// - Creates "aggressive" compression that lets fast transients through
//==============================================================================

function detect_transients(current_level_db) (
  transient_detected = 0;
  transient_gr_reduction = 0;
  
  // Check if transient detection is enabled (slider value > 0)
  transient_detection > 0 ? (
    // Calculate rate of level increase
    level_delta = current_level_db - transient_detector_prev_db;
    
    // Check if level is rising above threshold
    level_delta > 0 && current_level_db > transient_threshold_db ? (
      // Transient detected! Calculate GR reduction
      // Slider: 0-100 maps to 0-12dB of GR reduction
      max_reduction = (transient_detection / 100.0) * 12.0;
      
      // Scale reduction by how far above threshold we are
      threshold_excess = current_level_db - transient_threshold_db;
      transient_gr_reduction = min(threshold_excess * 0.6, max_reduction);
      
      transient_detected = 1;
    );
    
    // Update previous level for next sample
    transient_detector_prev_db = current_level_db;
  ) : (
    // Transient detection off - just update tracker
    transient_detector_prev_db = current_level_db;
  );
  
  transient_gr_reduction
);

function calculate_gain_reduction(input_level_db) (
  // Apply compression curve with global offset
  adjusted_input_db = input_level_db - global_offset_db;
  target_output_db = interpolate_compression_curve(adjusted_input_db);
  target_output_db += global_offset_db;  // Add offset back to output
  target_gr_db = target_output_db - input_level_db;

  // Apply strength and curves
  target_gr_db *= strength;

  strength_curve != 0 ? (
    gr_factor = abs(target_gr_db) / abs(max_gr_db);
    curve_factor = pow(gr_factor, pow(2, strength_curve));
    target_gr_db *= curve_factor;
  );

  target_gr_db = max(max_gr_db, target_gr_db);  // Use max, not min
  
  // Apply transient detection: reduce GR if transient detected
  transient_reduction = detect_transients(input_level_db);
  target_gr_db += transient_reduction;  // Add (reduces compression since GR is negative)

  target_gr_db
);

//==============================================================================
// DETECTION UTILITIES
//==============================================================================

function reset_detection_state() (
  rms_sum = 0;
  rms_pos = 0;
  rms_max = 0.0001;
  detector_level = 0;
);

function get_detector_level() (
  detector_level;
);

function get_rms_level() (
  rms_samples > 0 ? (
    rms_level = sqrt(rms_sum / rms_samples);
    rms_level;
  ) : (
    0;
  );
);

function is_rms_normalization_enabled() (
  rms_normalization > 0.5;
);

function get_rms_max() (
  rms_max;
);

function set_rms_max(new_max) (
  rms_max = new_max;
);

function update_rms_samples() (
  rms_samples = calculate_rms_samples(rms_size_ms);
);
