// Envelope Processing Module
// Envelope following and program-dependent release algorithms
// Depends on: 00b_math_utils.jsfx-inc, 00d_dsp_utils.jsfx-inc

@init

//==============================================================================
// MULTI-STAGE CASCADED RELEASE
//==============================================================================
// Multi-stage release creates smooth, musical compression release characteristics
// by cascading multiple envelope followers with different time constants.
//
// Implementation: 3 stages with hardcoded multipliers (can be made configurable later)
// - Stage 1: 1x base release time (fast)
// - Stage 2: 3x base release time (medium) 
// - Stage 3: 10x base release time (slow)
//
// Examples of hardware equivalents:
// - LA-2A Optical: 2 stages (120ms/900ms ≈ 1x/7x ratio)
// - Fairchild 670: 3 stages (60ms/200ms/800ms ≈ 1x/3x/13x ratio)
//
// Future enhancement options:
// - Make stage multipliers user-adjustable
// - Add stage blend/mix controls
// - Support 2-5 stages instead of fixed 3
// - Add per-stage curve controls
//==============================================================================

function calculate_multi_stage_release(target_gr_db, base_release_ms) (
  // Calculate time constants for 3 stages (hardcoded multipliers for now)
  stage_1_coef = exp(-1/(max(0.0001, base_release_ms * 1.0 * 0.001) * srate));  // 1x
  stage_2_coef = exp(-1/(max(0.0001, base_release_ms * 3.0 * 0.001) * srate));  // 3x
  stage_3_coef = exp(-1/(max(0.0001, base_release_ms * 10.0 * 0.001) * srate)); // 10x
  
  // Attack uses fast time constant
  attack_coef = exp(-1/(max(0.0001, attack_ms * 0.001) * srate));
  
  // Update each stage independently
  target_gr_db < release_stage_1_env ?
    (release_stage_1_env = attack_coef * release_stage_1_env + (1 - attack_coef) * target_gr_db) :
    (release_stage_1_env = stage_1_coef * release_stage_1_env + (1 - stage_1_coef) * target_gr_db);
  
  target_gr_db < release_stage_2_env ?
    (release_stage_2_env = attack_coef * release_stage_2_env + (1 - attack_coef) * target_gr_db) :
    (release_stage_2_env = stage_2_coef * release_stage_2_env + (1 - stage_2_coef) * target_gr_db);
  
  target_gr_db < release_stage_3_env ?
    (release_stage_3_env = attack_coef * release_stage_3_env + (1 - attack_coef) * target_gr_db) :
    (release_stage_3_env = stage_3_coef * release_stage_3_env + (1 - stage_3_coef) * target_gr_db);
  
  // Cascade the stages: stage3 follows stage2 follows stage1
  // This creates a smooth, natural release curve
  cascaded_result = stage_3_coef * (stage_2_coef * release_stage_1_env + (1 - stage_2_coef) * release_stage_2_env) 
                    + (1 - stage_3_coef) * release_stage_3_env;
  
  cascaded_result
);

//==============================================================================
// ENVELOPE FOLLOWING AND PROGRAM RELEASE
//==============================================================================

function process_envelope_following(target_gr_db, detector_level) (
  // Check if multi-stage release is enabled
  multi_stage_release > 0.5 ? (
    // Use multi-stage cascaded release
    global_smoothed_gain_db = calculate_multi_stage_release(target_gr_db, release_ms);
  ) : (
    // Original single-stage envelope following
    global_attack_coef = exp(-1/(max(0.0001, attack_ms*0.001)*srate));

    // Attack always uses global attack coefficient
    target_gr_db < global_smoothed_gain_db ? (
      global_smoothed_gain_db = global_attack_coef * global_smoothed_gain_db + (1 - global_attack_coef) * target_gr_db;
    ) : (
      // Release path: check if program-dependent mode is enabled
      prog_release_mode > 0.5 ? (
        // Program-dependent release: use release slider as multiplier (0..2000ms -> 0.5x..2.0x)
        rel_mult = 0.5 + (release_ms / 2000.0) * 1.5;

        // Base release coefficients adjusted by multiplier
        rel_fast = exp(-1/(base_fast_s * rel_mult * srate));
        rel_med = exp(-1/(base_med_s * rel_mult * srate));
        rel_slow = exp(-1/(base_slow_s * rel_mult * srate));

        gr_amount = abs(target_gr_db);
        det_delta = prev_detector_db - linear_to_db(detector_level);
        input_level_db = linear_to_db(detector_level);

        // Select release coefficient based on program release type
        rel_coef_use = rel_med;
        prog_release_type == 0 ? (
          // Level-dependent: deeper GR -> slower release (uses gr_blend_threshold_db)
          blend_fast = clamp(1 - gr_amount / gr_blend_threshold_db, 0, 1);
          blend_slow = clamp(gr_amount / gr_blend_threshold_db, 0, 1);
          sum = blend_fast + blend_slow + eps;
          rel_coef_use = (blend_fast * rel_fast + blend_slow * rel_slow) / sum;
        ) : prog_release_type == 1 ? (
          // Rate-of-change: fast release if level drops rapidly
          rel_coef_use = det_delta > 3 ? rel_fast : rel_slow;
        ) : prog_release_type == 2 ? (
          // Hybrid: combine level base then bias by rate-of-change
          blend_fast = clamp(1 - gr_amount / gr_blend_threshold_db, 0, 1);
          blend_slow = clamp(gr_amount / gr_blend_threshold_db, 0, 1);
          base = (blend_fast * rel_fast + blend_slow * rel_slow) / max(blend_fast + blend_slow, eps);
          rel_coef_use = det_delta > 3 ? min(base, rel_fast) : max(base, rel_slow);
        ) : (
          // Type 3: Input-level dependent (uses input_level_threshold_db)
          // Release speed based on input level relative to threshold
          level_above_threshold = input_level_db - input_level_threshold_db;
          blend_fast = clamp(1 - level_above_threshold / 20, 0, 1); // 20dB range
          blend_slow = clamp(level_above_threshold / 20, 0, 1);
          sum = blend_fast + blend_slow + eps;
          rel_coef_use = (blend_fast * rel_fast + blend_slow * rel_slow) / sum;
        );

        global_smoothed_gain_db = rel_coef_use * global_smoothed_gain_db + (1 - rel_coef_use) * target_gr_db;
      ) : (
        // Fixed release mode: use release slider as direct time
        fixed_rel_coef = exp(-1/(max(0.0001, release_ms*0.001) * srate));
        global_smoothed_gain_db = fixed_rel_coef * global_smoothed_gain_db + (1 - fixed_rel_coef) * target_gr_db;
      );
    );
  );

  global_smoothed_gain_db
);

