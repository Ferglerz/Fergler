//==============================================================================
// AUDIO PROCESSING CHAIN FUNCTIONS
//==============================================================================
// Modular audio processing functions for the compressor
// Must be imported after utilities but before main processing

@init

//==============================================================================
// INPUT STAGE
//==============================================================================

function process_input_stage() (
  // Cache original input signals for potential use in other stages
  input_l_orig = spl0;
  input_r_orig = spl1;

  // Update display values 4x per second (every srate/4 samples)
  display_update_counter += 1;
  display_update_counter >= (srate * 0.25) ? (
    display_update_counter = 0;
    display_input_sample = max(abs(spl0), abs(spl1)); // Peak input level
  );

  // Pre-calculate channel availability flags
  has_stereo = (num_ch >= 2);
  has_sidechain_l = (use_sidechain && num_ch >= 3);
  has_sidechain_r = (use_sidechain && num_ch >= 4);

  // Set detection signals based on mode (will be overridden by detection source selection)
  detect_l = spl0;
  detect_r = spl1;
);

//==============================================================================
// DETECTION SOURCE SELECTION
//==============================================================================

function process_detection_source_selection() (
  stage_detection_source > 0.5 ? (
    // Feedforward mode: use input signal directly (or sidechain if available)
    detection_mode > 0.5 ? (
      detect_l = has_sidechain_l ? spl2 : spl0;
      detect_r = has_sidechain_r ? spl3 : (has_stereo ? spl1 : spl0);
    ) : (
      // Feedback mode: use sidechain if available, otherwise post-compression signal
      detect_l = has_sidechain_l ? spl2 : final_l;
      detect_r = has_sidechain_r ? spl3 : final_r;
    );
  );
);

//==============================================================================
// DETECTION FILTERING
//==============================================================================

function process_detection_filtering() (
  stage_filtering > 0.5 ? (
    // Apply filters to active detection signal (sidechain or regular)
    apply_detection_filters(detect_l, detect_r);
    // Update detection signals with filtered versions
    detect_l = filtered_l;
    detect_r = filtered_r;
  );
);

//==============================================================================
// DETECTION AND ANALYSIS
//==============================================================================

function process_detection_and_analysis() (
  stage_detection_analysis > 0.5 ? (
    // Process RMS detection on detection signal (already filtered if filtering enabled)
    process_rms_detection(detect_l, detect_r);

    // Calculate gain reduction based on current detector level
    calculate_gain_reduction(get_detector_level());
  );
);

//==============================================================================
// ENVELOPE FOLLOWING
//==============================================================================

function process_envelope_following_stage() (
  stage_envelope > 0.5 ? (
    // Apply envelope following with program-dependent release
    process_envelope_following(target_gr_db, get_detector_level());
  );
);

//==============================================================================
// LOOKAHEAD
//==============================================================================

function process_lookahead_stage() (
  stage_lookahead > 0.5 ? (
    // Process lookahead for zero-latency peak detection
    process_lookahead(input_l_orig, input_r_orig);
  );
);

//==============================================================================
// GAIN REDUCTION APPLICATION
//==============================================================================

function process_gain_reduction_application() (
  stage_gain_reduction > 0.5 ? (
    // Apply gain reduction to input signal
    gain_reduction_linear = db_to_linear(target_gr_db);

    processed_l = input_l_orig * gain_reduction_linear;
    processed_r = input_r_orig * gain_reduction_linear;
  ) : (
    // Bypass gain reduction
    processed_l = input_l_orig;
    processed_r = input_r_orig;
  );
  
  // Update display post-graph level
  display_post_graph = max(abs(processed_l), abs(processed_r));
);

//==============================================================================
// HARMONIC PROCESSING
//==============================================================================

function process_harmonic_processing_stage() (
  stage_harmonics > 0.5 ? (
    // Get envelope and detector information for dynamic harmonic processing
    envelope_amount = abs(global_smoothed_gain_db) / 30.0; // Normalize to 0-1 range
    current_detector_level = get_detector_level();
    
    // Apply harmonic processing to gain-reduced signal (both channels)
    processed_l = apply_harmonic_processing(processed_l, target_gr_db, envelope_amount, current_detector_level,
                                           harmonic_type, harmonic_amount, harmonic_drive, harmonic_mix, 
                                           harmonic_even_boost, harmonic_odd_boost);
    processed_r = apply_harmonic_processing(processed_r, target_gr_db, envelope_amount, current_detector_level,
                                           harmonic_type, harmonic_amount, harmonic_drive, harmonic_mix, 
                                           harmonic_even_boost, harmonic_odd_boost);
  );
);

//==============================================================================
// FINAL MIX
//==============================================================================

function process_final_mix() (
  stage_final_mix > 0.5 ? (
    // Apply makeup gain (inlined from apply_final_mix)
    final_l = processed_l * makeup_gain_linear;
    final_r = processed_r * makeup_gain_linear;
    
    // Update display post-makeup level
    display_post_makeup = max(abs(final_l), abs(final_r));

    // Return final signals via global variables
    final_out_l = final_l;
    final_out_r = final_r;
  );
);

//==============================================================================
// BRICKWALL LIMITER
//==============================================================================

function process_brickwall_limiter() (
  // Apply brickwall limiting to prevent inter-sample peaks if enabled
  stage_limiter > 0.5 && brickwall_limiter > 0.5 ? (
    // Apply soft-clip limiter with previous sample tracking
    final_l = soft_clip_limiter(final_l, limiter_prev_l);
    final_r = soft_clip_limiter(final_r, limiter_prev_r);
    
    // Update previous samples for next iteration
    limiter_prev_l = final_l;
    limiter_prev_r = final_r;
  );
);

//==============================================================================
// OUTPUT STAGE
//==============================================================================

function process_output_stage() (
  // Output final processed signals
  spl0 = final_l;
  spl1 = final_r;
);

//==============================================================================
// LISTEN MODE
//==============================================================================

function process_listen_mode() (
  // Check if listen mode is enabled
  should_listen = listen_to_sidechain && stage_detection_source > 0.5;
  should_listen ? (
    spl0 = detect_l;
    has_stereo ? spl1 = detect_r;
  ) : (
    0; // Continue processing
  );
  !should_listen; // Return whether to continue processing
);

//==============================================================================
// COMPLETE AUDIO PROCESSING CHAIN
//==============================================================================

function process_complete_audio_chain() (
  // === MAIN AUDIO PROCESSING CHAIN ===

  // Always process input stage (essential for signal flow)
  process_input_stage();

  // Initialize processing continuation flag
  continue_processing = 1;

  // === DETECTION SOURCE SELECTION ===
  process_detection_source_selection();

  // === DETECTION FILTERING ===
  process_detection_filtering();

  // === LISTEN MODE (early exit) ===
  continue_processing = process_listen_mode();

  continue_processing ? (
    // === DETECTION AND ANALYSIS ===
    process_detection_and_analysis();

    // === ENVELOPE FOLLOWING ===
    process_envelope_following_stage();

    // === LOOKAHEAD ===
    process_lookahead_stage();

    // === GAIN REDUCTION APPLICATION ===
    process_gain_reduction_application();

    // === HARMONIC PROCESSING ===
    process_harmonic_processing_stage();

    // === FINAL MIX ===
    process_final_mix();

    // === BRICKWALL LIMITER ===
    process_brickwall_limiter();

    // === OUTPUT STAGE ===
    process_output_stage();
  );
);
