// User Interactions - Controls Module
// UI controls and knobs interaction handling
// Dependencies: 01_Utils/02_math_utils.jsfx-inc, 01_Utils/08_ui_utils.jsfx-inc, 06_UI_UserInteractions/01_control_definitions.jsfx-inc

@init

//==============================================================================
// INTERACTION STATE
//==============================================================================

// Control States
ui_drag_control = -1;  // -1 = no control, -2 = clicked but not draggable, >= 0 = dragging control index

// Mouse position tracking for delta calculations
ui_prev_mouse_x = 0;
ui_prev_mouse_y = 0;

// Fine drag accumulator for discrete sliders (freq_list_slider)
ui_fine_drag_accum = 0;

// Double-click detection
ui_last_click_time = 0;
ui_last_clicked_control = -1;
ui_double_click_threshold = 0.3; // 300ms for double click


//==============================================================================
// HELPER FUNCTIONS
//==============================================================================

// Update PDC delay for lookahead slider (slider5)
function update_pdc_delay_if_needed(param_index) (
  param_index == 5 ? (
    pdc_delay = min(slider(5) * 0.001 * srate, max_lookahead_samples) | 0;
    pdc_delay > 0 ? (
      pdc_bot_ch = 0;
      pdc_top_ch = 2;
    );
  );
);

//==============================================================================
// HELPER FUNCTIONS
//==============================================================================

// Reset control to default value
function reset_control_to_default(control_index) (
  param_index = get_control_param(control_index);
  min_val = get_control_min(control_index);
  max_val = get_control_max(control_index);
  control_type = get_control_type(control_index);
  
  // Calculate default value (middle for most, 0 for buttons)
  control_type == 1 ? (
    // Button - default to off
    slider(param_index) = 0;
  ) : control_type == 2 ? (
    // Dropdown - default to first option
    slider(param_index) = 0;
  ) : (
    // Slider/knob - default to middle
    slider(param_index) = (min_val + max_val) / 2;
  );
  
  sliderchange(1 << (param_index - 1));
  update_pdc_delay_if_needed(param_index);
);

// Check if this is a double-click
function is_double_click_control(control_index) local(current_time, is_double) (
  current_time = time_precise();
  is_double = (control_index == ui_last_clicked_control && 
               (current_time - ui_last_click_time) < ui_double_click_threshold);
  ui_last_clicked_control = control_index;
  ui_last_click_time = current_time;
  is_double;
);

// Handle control click based on control type
function handle_control_click(control_index) (
  control_type = get_control_type(control_index);
  param_index = get_control_param(control_index);
  current_value = slider(param_index);
  
  // Debug logging removed per user request
  
  // Check for double-click or alt-click to reset (but not for dropdowns)
  (is_double_click_control(control_index) || MOUSE_ALT_KEY) && control_type != 2 ? (
    reset_control_to_default(control_index);
    ui_drag_control = -2; // Prevent drag
  ) : (
    // Normal click behavior
    control_type == 0 ? (
      // Slider - start drag
      ui_drag_control = control_index;
      slider(param_index) = update_slider_value(control_index, mouse_x, mouse_y);
      sliderchange(1 << (param_index - 1));
      update_pdc_delay_if_needed(param_index);
    ) : control_type == 4 ? (
      // Freq list slider - discrete value slider (snaps to enumerated frequency values)
      ui_drag_control = control_index;
      // update_slider_value already returns the correct discrete value from enumerated list
      slider(param_index) = update_slider_value(control_index, mouse_x, mouse_y);
      sliderchange(1 << (param_index - 1));
    ) : control_type == 3 ? (
      // Small knob (control type 3) - start drag
      ui_drag_control = control_index;
      // Don't update on first click - just lock the control
    ) : control_type == 1 ? (
      // Button - toggle (don't start drag for buttons)
      slider(param_index) = current_value > 0.5 ? 0 : 1;
      sliderchange(1 << (param_index - 1));
      ui_drag_control = -2; // Special value to prevent further checks
    ) : control_type == 2 ? (
      // Dropdown - cycle (don't start drag for dropdowns)
      max_options = get_dropdown_option_count(param_index);
      max_options > 0 ? (
        slider(param_index) = (current_value + 1) % max_options;
        sliderchange(1 << (param_index - 1));
      );
      ui_drag_control = -2; // Special value to prevent further checks
    );
  );
);

// Handle drag continuation for different control types
function handle_drag_continuation() local(fine_drag_mult, slider_config, slider_style, format_options) (
  // Apply fine drag multiplier when ctrl/cmd is held
  fine_drag_mult = MOUSE_CTRL_KEY ? 0.2 : 1.0;
  
  ui_drag_control >= 0 ? (
    // Update dragged control
    param_index = get_control_param(ui_drag_control);
    control_type = get_control_type(ui_drag_control);
    
    control_type == 0 ? ( // Slider - unified system
      slider_config = get_control_slider_type(ui_drag_control);
      slider_style = slider_config & 0xFF;
      format_options = (slider_config >> 24) & 0xFF;
      
      min_val = get_control_min(ui_drag_control);
      max_val = get_control_max(ui_drag_control);
      current_value = slider(param_index);
      
      // Check if this slider supports bidirectional drag (knob-style)
      format_options & FORMAT_OPTION_BIDIRECTIONAL ? (
        // Bidirectional drag - use both X and Y movement
        mouse_dx = (mouse_x - ui_prev_mouse_x) * fine_drag_mult;
        mouse_dy = (mouse_y - ui_prev_mouse_y) * fine_drag_mult;
        
        // Combine X and Y movement for knob-style interaction
        mouse_delta = mouse_dx - mouse_dy; // Y movement is inverted for intuitive knob behavior
        
        slider_w = get_control_w(ui_drag_control);
        value_range = max_val - min_val;
        delta = (mouse_delta / slider_w) * value_range;
        new_value = clamp(current_value + delta, min_val, max_val);
        slider(param_index) = new_value;
      ) : (
        // Standard slider - use position-based or delta-based depending on fine mode
        MOUSE_CTRL_KEY ? (
          // Fine drag mode - use delta approach
          mouse_dx = (mouse_x - ui_prev_mouse_x) * fine_drag_mult;
          slider_w = get_control_w(ui_drag_control);
          value_range = max_val - min_val;
          delta = (mouse_dx / slider_w) * value_range;
          new_value = clamp(current_value + delta, min_val, max_val);
          slider(param_index) = new_value;
        ) : (
          // Normal drag mode - use position
          slider(param_index) = update_slider_value(ui_drag_control, mouse_x, mouse_y);
        );
      );
      
      sliderchange(1 << (param_index - 1));
      update_pdc_delay_if_needed(param_index);
    ) : (
      // Other control types - no drag handling needed
      0; // Empty statement to satisfy JSFX syntax
    );
  ) : (
    // No drag operation in progress - no action needed
    0; // Empty statement to satisfy JSFX syntax
  );
);

//==============================================================================
// UI CONTROL MOUSE INPUT
//==============================================================================

function handle_ui_mouse_input() (
  MOUSE_LEFT_BUTTON ? (
    ui_drag_control == -1 ? ( // Start of click - no control selected yet
      // Initialize previous mouse position on first click
      ui_prev_mouse_x = mouse_x;
      ui_prev_mouse_y = mouse_y;
      ui_fine_drag_accum = 0; // Reset accumulator
      
      is_menu_button_clicked() ? (
          handle_menu_button_click();
          ui_drag_control = -2; // Special value to prevent further checks
        ) : is_menu_visible() ? (
          // Check menu items if menu is visible
          hovered_item = get_hovered_menu_item();
          hovered_item >= 0 ? (
            handle_menu_item_click(hovered_item);
            ui_drag_control = -2; // Special value to prevent further checks
          ) : (
            // Clicked outside menu - close it
            menu_visible = 0;
            menu_hovered_item = -1;
          );
        ) : (
        // Check controls until we find one under the mouse
        i = 0;
        while (i < NUM_CONTROLS && ui_drag_control == -1) (
          is_point_in_control(mouse_x, mouse_y, i) ? (
            handle_control_click(i);
          );
          i += 1;
        );
      );
    ) : ( // Continue drag
      handle_drag_continuation();
    );
  ) : (
    // Mouse released - reset drag state
    ui_drag_control = -1;
    ui_fine_drag_accum = 0; // Reset accumulator
  );
  
  // Update previous mouse position for next frame's delta calculation
  ui_prev_mouse_x = mouse_x;
  ui_prev_mouse_y = mouse_y;
);

