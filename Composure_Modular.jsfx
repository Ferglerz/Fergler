// Advanced Multi-Model Compressor JSFX - Modular Version
// Professional multi-algorithm compressor with interactive graph
// Features: multiple characters, feedforward/feedback, RMS normalization,
// program-dependent release, dedicated harmonic stage, soft-clipping limiter
// Author: Custom JSFX Generator
// Version: 3.0 - Advanced multi-model implementation (Modular)

desc:Advanced Multi-Model Compressor (Modular)

//==============================================================================
// SLIDER DEFINITIONS
//==============================================================================

// Time-related parameters (1-6)
slider1:attack_ms=10<0.1,100,0.1>-Attack (ms)
slider2:attack_curve=0<-2,2,0.01>-Attack Curve
slider3:release_ms=100<10,1000,1>-Release (ms)
slider4:release_curve=0<-2,2,0.01>-Release Curve
slider5:lookahead_ms=0<0,10,0.1>-Lookahead (ms)
slider6:hold_ms=0<0,50,0.1>-Hold Time (ms)

// RMS & Detection parameters (7-10)
slider7:rms_size_ms=10<1,100,0.1>-RMS Window (ms)
slider8:rms_normalization=0<0,1,1{Off,On}>-RMS Normalization
slider9:detection_mode=1<0,1,1{Feedback,Feedforward}>-Detection Mode
slider10:max_gr_db=-10<-30,0,1>-Max GR (dB)

// Filtering parameters (11-12)
slider11:hp_freq=20<20,200,1>-HP Filter (Hz)
slider12:lp_freq=20000<1000,20000,10>-LP Filter (Hz)

// Character & Harmonics parameters (13-20)
slider13:over_the_top=100<0,200,1>-Over The Top % (Analog Character Intensity)
slider14:harmonic_type=0<0,4,1{Off,Tube Even,Tube Odd,Tube Both,Tape Saturation}>-Harmonic Type
slider15:harmonic_amount=0<0,1,0.01>-Harmonic Amount
slider16:harmonic_drive=1<0.5,10,0.1>-Harmonic Drive
slider17:harmonic_mix=0<0,1,0.01>-Harmonic Mix
slider18:harmonic_even_boost=0<0,2,0.01>-Even Harmonic Boost
slider19:harmonic_odd_boost=0<0,2,0.01>-Odd Harmonic Boost
slider20:prog_release_mode=0<0,1,1{Fixed Release,Program-Dependent Release}>-Program Release Mode

// Global parameters (21-30)
slider21:strength=1<0.5,10,0.1>-Strength
slider22:global_offset_db=0<-30,30,0.1>-Global Offset (dB) - Traditional Threshold Control
slider23:strength_curve=0<-2,2,0.01>-Strength Curve (exp)
slider24:makeup_gain_db=0<-20,20,0.1>-Makeup Gain (dB)
slider25:mix_wet=100<0,100,1>-Mix %
slider26:compressor_type=0<0,6,1{Clean Digital,Varimu,Bridged Diode,VCA,PWM/Fairchild,FET,Optical}>-Compressor Type
slider27:use_sidechain=0<0,1,1{No,Yes}>-Use Sidechain
slider28:listen_to_sidechain=0<0,1,1{No,Yes}>-Listen to Detection Signal
slider29:prog_release_type=0<0,2,1{Level-Dependent,Rate-Of-Change,Hybrid}>-Program Release Type
slider30:brickwall_limiter=1<0,1,1{Off,On}>-Brickwall Limiter



//==============================================================================
// INCLUDE MODULES
//==============================================================================

// For Claude: These are import, not @import or include or @include
import 01_initialization.jsfx-inc
import 02_shared_utilities.jsfx-inc
import 03_compression_algorithms.jsfx-inc
import 04_audio_processing.jsfx-inc
import 07_ui_core.jsfx-inc
import 08_ui_controls.jsfx-inc
import 09_ui_rendering.jsfx-inc
import 10_ui_interaction.jsfx-inc
import 05_graph_management.jsfx-inc
import 06_graphics_ui.jsfx-inc

@serialize
// Prevent memory/variables from being cleared on @init by having a non-empty @serialize section
ext_noinit = 1.0; // need this to not clear on bringing up the UI or alt+tabbing

@init

// Set up graph points memory location (must be done first)
!graph_points ? graph_points = 10000;

// Initialize all constants, memory, and state variables
perform_complete_initialization();

// Initialize UI constants after all modules are loaded
init_ui_constants();

// Set up control layout after UI constants are initialized
setup_control_layout();

// Initialize graph points if not already done
!graph_initialized ? (
  num_points = 6;  // Ensure correct point count
  init_graph_points();
  graph_initialized = 1;
);

//==============================================================================
// MAIN SECTIONS
//==============================================================================

@slider

// Update filter coefficients
calc_biquad_hp(hp_freq);
hp_b0 = b0; hp_b1 = b1; hp_b2 = b2; hp_a1 = a1; hp_a2 = a2;

calc_biquad_lp(lp_freq);
lp_b0 = b0; lp_b1 = b1; lp_b2 = b2; lp_a1 = a1; lp_a2 = a2;

// Calculate time constants
rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);
hold_samples = floor(hold_ms * 0.001 * srate);

attack_coeff = attack_ms > 0 ? exp(-1000 / (attack_ms * srate)) : 0;
release_coeff = release_ms > 0 ? exp(-1000 / (release_ms * srate)) : 0;

attack_curve != 0 ? attack_coeff = pow(attack_coeff, pow(2, attack_curve));
release_curve != 0 ? release_coeff = pow(release_coeff, pow(2, release_curve));

makeup_gain_linear = db_to_linear(makeup_gain_db);
over_the_top_factor = over_the_top * 0.01;

// Set plugin delay compensation
lookahead_samples > 0 ? (
  pdc_delay = lookahead_samples;
  pdc_bot_ch = 0;
  pdc_top_ch = num_ch;
) : (
  pdc_delay = 0;
);

@gfx 3500 450

render_complete_interface();

@sample

// Store original signals
input_l_orig = spl0;
input_r_orig = num_ch >= 2 ? spl1 : spl0;

// Select detection source - feedforward vs feedback
detection_mode > 0.5 ? (
  // Feedforward mode: detect from current input
  detect_l = use_sidechain && num_ch >= 3 ? spl2 : spl0;
  detect_r = use_sidechain && num_ch >= 4 ? spl3 : (num_ch >= 2 ? spl1 : spl0);
) : (
  // Feedback mode: detect from previous output (stored in feedback_l/feedback_r)
  detect_l = use_sidechain && num_ch >= 3 ? spl2 : (feedback_l_prev ? feedback_l_prev : spl0);
  detect_r = use_sidechain && num_ch >= 4 ? spl3 : (feedback_r_prev ? feedback_r_prev : (num_ch >= 2 ? spl1 : spl0));
);

// Apply filters
apply_sidechain_filters(detect_l, detect_r);
detect_l = filtered_l;
detect_r = filtered_r;

// Listen mode bypass
listen_to_sidechain ? (
  spl0 = detect_l;
  num_ch >= 2 ? spl1 = detect_r;
) : (

// Process RMS detection
detector_level = process_rms_detection(detect_l, detect_r);
input_level_db = linear_to_db(detector_level);
current_input_db = input_level_db;

// Calculate gain reduction
target_gr_db = calculate_gain_reduction(input_level_db);

// Apply compressor character
dt = SRATE_INV;
average_input_level = average_input_level * 0.999 + detector_level * 0.001;
target_gr_db = apply_compressor_character(target_gr_db, compressor_type, detector_level, dt, over_the_top_factor);

// Process envelope following
final_gain_db = process_envelope_following(target_gr_db, detector_level);

// Update previous detector level for next sample
prev_detector_db = linear_to_db(detector_level);

// Convert final gain reduction to linear for application
envelope_out = db_to_linear(final_gain_db);
current_gr_db = final_gain_db;

// Lookahead processing
process_lookahead(input_l_orig, input_r_orig);
processed_l = lookahead_out_l;
processed_r = lookahead_out_r;

// Apply gain reduction
processed_l *= envelope_out * makeup_gain_linear;
processed_r *= envelope_out * makeup_gain_linear;

// Dedicated harmonic processing stage (driven by gain reduction amount)
gr_amount_normalized = abs(current_gr_db) / 30.0; // Normalize GR to 0..1 range
processed_l = apply_harmonic_processing(processed_l, gr_amount_normalized, harmonic_type, harmonic_amount, harmonic_drive, harmonic_mix, harmonic_even_boost, harmonic_odd_boost);
processed_r = apply_harmonic_processing(processed_r, gr_amount_normalized, harmonic_type, harmonic_amount, harmonic_drive, harmonic_mix, harmonic_even_boost, harmonic_odd_boost);

// Final mix
apply_final_mix(processed_l, processed_r, input_l_orig, input_r_orig);
final_l = final_out_l;
final_r = final_out_r;

// Out-of-bounds calculation (after all processing is complete)
// Calculate effective attack/release times including all modifications
effective_attack_time = attack_ms;
effective_release_time = prog_release_mode > 0.5 ? (base_med_s * 1000) : release_ms; // Approximate calculation for display

oob_attack = (effective_attack_time < 0.2);
oob_release = (effective_release_time < 30);
oob_depth = (abs(current_gr_db) > 20);

// Apply soft-clipping brickwall limiter if enabled
brickwall_limiter > 0.5 ? (
  final_l = soft_clip_limiter(final_l, limiter_prev_l);
  final_r = soft_clip_limiter(final_r, limiter_prev_r);
  limiter_prev_l = final_l;
  limiter_prev_r = final_r;
);

// Output final results
spl0 = final_l;
num_ch >= 2 ? spl1 = final_r;

// Store feedback signals for next sample (for feedback detection mode)
feedback_l_prev = final_l;
feedback_r_prev = final_r;

); 