// Advanced Multi-Model Compressor JSFX - Modular Version
// Professional multi-algorithm compressor with interactive graph
// Features: multiple characters, feedforward/feedback, RMS normalization,
// program-dependent release, dedicated harmonic stage, soft-clipping limiter
// Author: Custom JSFX Generator
// Version: 3.0 - Advanced multi-model implementation (Modular)

desc:Advanced Multi-Model Compressor (Modular)


//==============================================================================
// SLIDER DEFINITIONS
//==============================================================================

// Time-related parameters (1-6)
slider1:attack_ms=10<0.1,100,0.1>-Attack (ms)
slider2:attack_curve=0<-2,2,0.01>-Attack Curve
slider3:release_ms=100<10,1000,1>-Release (ms)
slider4:release_curve=0<-2,2,0.01>-Release Curve
slider5:lookahead_ms=0<0,10,0.1>-Lookahead (ms)
slider6:hold_ms=0<0,50,0.1>-Hold Time (ms)

// RMS & Detection parameters (7-10)
slider7:rms_size_ms=10<1,100,0.1>-RMS Window (ms)
slider8:rms_normalization=0<0,1,1{Off,On}>-RMS Normalization
slider9:detection_mode=1<0,1,1{Feedback,Feedforward}>-Detection Mode
slider10:max_gr_db=-10<-30,0,1>-Max GR (dB)

// Filtering parameters (11-12)
slider11:hp_freq=20<20,200,1>-HP Filter (Hz)
slider12:lp_freq=20000<1000,20000,10>-LP Filter (Hz)

// Character & Harmonics parameters (13-20)
slider13:over_the_top=100<0,200,1>-Over The Top
slider14:harmonic_type=0<0,4,1{Off,Tube Even,Tube Odd,Tube Both,Tape Saturation}>-Harmonic Type
slider15:harmonic_amount=0<0,1,0.01>-Harmonic Amount
slider16:harmonic_drive=1<0.5,10,0.1>-Harmonic Drive
slider17:harmonic_mix=0<0,1,0.01>-Harmonic Mix
slider18:harmonic_even_boost=0<0,2,0.01>-Even Harmonic Boost
slider19:harmonic_odd_boost=0<0,2,0.01>-Odd Harmonic Boost
slider20:prog_release_mode=0<0,1,1{Fixed Release,Program-Dependent Release}>-Program Release Mode

// Global parameters (21-30)
slider21:strength=1<0.5,10,0.1>-Strength
slider22:global_offset_db=0<-30,30,0.1>-Global Offset (dB)
slider23:strength_curve=0<-2,2,0.01>-Strength Curve (exp)
slider24:makeup_gain_db=0<-20,20,0.1>-Makeup Gain (dB)
slider25:compressor_type=0<0,6,1{Clean Digital,Varimu,Bridged Diode,VCA,PWM/Fairchild,FET,Optical}>-Compressor Type
slider26:use_sidechain=0<0,1,1{No,Yes}>-Use Sidechain
slider27:listen_to_sidechain=0<0,1,1{No,Yes}>-Listen to Detection Signal
slider28:prog_release_type=0<0,2,1{Level-Dependent,Rate-Of-Change,Hybrid}>-Program Release Type
slider29:brickwall_limiter=1<0,1,1{Off,On}>-Brickwall Limiter

// SEARCH STOP

//==============================================================================
// INCLUDE MODULES
//==============================================================================

// For Claude: These are import, not @import or include or @include

// Core foundation modules
import 01a_memory.jsfx-inc
import 01b_state.jsfx-inc
import 01c_initialization.jsfx-inc
import 01e_ui_config.jsfx-inc

// Utility modules
import 02a_math_utils.jsfx-inc
import 02b_audio_utils.jsfx-inc
import 02c_dsp_utils.jsfx-inc
import 02d_ui_utils.jsfx-inc

// UI interaction (depends on utilities)
import 01d_ui_interaction.jsfx-inc

// Graph data modules
import 03a_graph_data.jsfx-inc
import 03b_graph_interaction.jsfx-inc

// Audio processing modules
import 04a_compression_core.jsfx-inc
import 04b_harmonic_models.jsfx-inc
import 04c_filters.jsfx-inc
import 04d_detection.jsfx-inc
import 04e_envelope.jsfx-inc
import 04f_effects.jsfx-inc

// UI modules
import 05a_ui_core.jsfx-inc
import 05b_ui_controls.jsfx-inc
import 05c_ui_rendering.jsfx-inc
import 05e_ui_graph.jsfx-inc


//==============================================================================
// SERIALIZE
//==============================================================================

@serialize
// Prevent memory/variables from being cleared on @init by having a non-empty @serialize section
ext_noinit = 1.0; // need this to not clear on bringing up the UI or alt+tabbing

// Serialize graph points data for persistence across plugin duplication and project saves
// Format: [version][num_points][point1_x][point1_y][point2_x][point2_y]...[curve1][curve2]...
// Version 1: Basic graph points serialization
// Version 2: Added curve data serialization
// This ensures graph points and curves are preserved when:
// - Duplicating the plugin instance
// - Copying/pasting the track
// - Saving and reopening the project
// - Restarting REAPER
file_var(0, graph_serialization_version);
file_var(0, num_points);

// Save all graph points
i = 0;
while (i < num_points) (
  file_var(0, graph_points[i*2]);     // input_db
  file_var(0, graph_points[i*2 + 1]); // output_db
  i += 1;
);

// Save curve data (Version 2+)
graph_serialization_version >= 2 ? (
  i = 0;
  while (i < num_points) (
    file_var(0, get_curve_amount(i));
    i += 1;
  );
);

@init

//==============================================================================
// FILE READING VARIABLES
//==============================================================================

// File reading variables
file_loaded = 0;

// Slider name parsing variables
slider_names_count = 0;
slider_names_loaded = 0;

// Define base address for slider name string storage (use slots 0-1023)
// Starting at 100 to leave room for other temporary strings (0-99)
// Allocating slots 100-199 for up to 100 slider names
SLIDER_NAMES_BASE = 100;

// Define base address for dropdown options storage (use slots 200-799)
// Each slider can have up to 20 options, 30 sliders max = 600 slots
DROPDOWN_OPTIONS_BASE = 200;
dropdown_option_counts_base = 10000; // Memory array for option counts per slider

//==============================================================================
// FILE READING FUNCTIONS
//==============================================================================

function extract_slider_name(line, array_index)
(
  line_len = strlen(line);
  found_greater = 0;
  found_dash = 0;
  name_start = 0;
  
  // Find the > symbol position manually
  i = 0;
  while(i < line_len && !found_greater) (
    char = str_getchar(line, i);
    (char == 62) ? ( // 62 is '>' character
      found_greater = 1;
      name_start = i + 1;
    );
    i += 1;
  );
  
  (found_greater) ? (
    // Check if there's a dash right after the > symbol
    (name_start < line_len) ? (
      char = str_getchar(line, name_start);
      (char == 45) ? ( // 45 is '-' character
        found_dash = 1;
        name_start += 1;
      );
    );
    
    // Extract the name directly to the string slot (using fixed slots 0-1023)
    name_len = line_len - name_start;
    strcpy_substr(SLIDER_NAMES_BASE + array_index, line, name_start, name_len);
    
    // Debug: save extracted names for first 5 sliders
    (array_index == 0) ? strcpy(#debug_extracted_0, SLIDER_NAMES_BASE + 0);
    (array_index == 1) ? strcpy(#debug_extracted_1, SLIDER_NAMES_BASE + 1);
    (array_index == 2) ? strcpy(#debug_extracted_2, SLIDER_NAMES_BASE + 2);
    (array_index == 3) ? strcpy(#debug_extracted_3, SLIDER_NAMES_BASE + 3);
    (array_index == 4) ? strcpy(#debug_extracted_4, SLIDER_NAMES_BASE + 4);
  );
  
  slider_name;
);

function extract_dropdown_options(line, slider_index)
local(line_len, i, char, found_open_brace, found_close_brace, brace_start, brace_end,
      options_str, option_count, option_start, in_option, opt_idx, base_slot)
(
  line_len = strlen(line);
  found_open_brace = 0;
  found_close_brace = 0;
  option_count = 0;
  
  // Find the { symbol position
  i = 0;
  while(i < line_len && !found_open_brace) (
    char = str_getchar(line, i);
    (char == 123) ? ( // 123 is '{' character
      found_open_brace = 1;
      brace_start = i + 1;
    );
    i += 1;
  );
  
  // Find the } symbol position
  (found_open_brace) ? (
    while(i < line_len && !found_close_brace) (
      char = str_getchar(line, i);
      (char == 125) ? ( // 125 is '}' character
        found_close_brace = 1;
        brace_end = i;
      );
      i += 1;
    );
  );
  
  // Extract dropdown options if both braces found
  (found_open_brace && found_close_brace) ? (
    // Base slot for this slider's options (20 options per slider max)
    base_slot = DROPDOWN_OPTIONS_BASE + (slider_index * 20);
    
    // Extract the options string (content between { and })
    strcpy_substr(#options_temp, line, brace_start, brace_end - brace_start);
    
    // Parse comma-separated options
    option_start = 0;
    opt_idx = 0;
    i = 0;
    while(i <= strlen(#options_temp)) (
      char = str_getchar(#options_temp, i);
      
      // Found comma or end of string
      (char == 44 || i == strlen(#options_temp)) ? ( // 44 is ','
        // Extract this option
        strcpy_substr(base_slot + opt_idx, #options_temp, option_start, i - option_start);
        opt_idx += 1;
        option_start = i + 1;
      );
      
      i += 1;
    );
    
    // Store the number of options for this slider
    dropdown_option_counts_base[slider_index] = opt_idx;
    option_count = opt_idx;
  ) : (
    // No dropdown options found
    dropdown_option_counts_base[slider_index] = 0;
  );
  
  option_count;
);

function parse_slider_definitions()
(
  // Try to open the Composure_Modular.jsfx file
  handle = file_open("Composure_Modular.jsfx");
  
  (handle != -1) ? (
    line_count = 0;
    found_stop = 0;
    slider_names_count = 0;
    
    // Read file line by line until we hit // SEARCH STOP
    while(file_avail(handle) > 0 && !found_stop) (
      str = #;
      file_string(handle, str);
      line_count += 1;
      
      // Check if this is the stop line (look for "// SEARCH STOP")
      (strlen(str) >= 14) ? (
        (str_getchar(str, 0) == 47 && str_getchar(str, 1) == 47 && 
         str_getchar(str, 2) == 32 && str_getchar(str, 3) == 83 && 
         str_getchar(str, 4) == 69 && str_getchar(str, 5) == 65 && 
         str_getchar(str, 6) == 82 && str_getchar(str, 7) == 67 && 
         str_getchar(str, 8) == 72 && str_getchar(str, 9) == 32 && 
         str_getchar(str, 10) == 83 && str_getchar(str, 11) == 84 && 
         str_getchar(str, 12) == 79 && str_getchar(str, 13) == 80) ? (
          found_stop = 1;
        ) : (
          // Check if line starts with "slider" (6 characters)
          (strlen(str) >= 6) ? (
            (str_getchar(str, 0) == 115 && str_getchar(str, 1) == 108 && 
             str_getchar(str, 2) == 105 && str_getchar(str, 3) == 100 && 
             str_getchar(str, 4) == 101 && str_getchar(str, 5) == 114) ? (
              // Extract slider name and store it
              extract_slider_name(str, slider_names_count);
              // Extract dropdown options if they exist
              extract_dropdown_options(str, slider_names_count);
              slider_names_count += 1;
            );
          );
        );
      );
    );
    
    file_close(handle);
    file_loaded = 1;
    slider_names_loaded = 1;
  ) : (
    file_loaded = 0;
    slider_names_loaded = 0;
    strcpy(#file_first_line, "File not found");
  );
  
  file_loaded;
);

function read_composure_file()
(
  parse_slider_definitions();
);

// Call the file reading function during initialization
read_composure_file();

// Initialize all constants, memory, and state variables
perform_complete_initialization();


// Initialize curve data
init_curve_data();

// Set up control layout after UI constants are initialized
setup_control_layout();

// Initialize graph points if not already done
!graph_initialized ? (
  // Try to restore graph points from serialized data
  restore_graph_points_from_serialization();
  
  // If restoration failed or no data exists, initialize with default points
  !graph_initialized ? (
    num_points = 6;  // Ensure correct point count
    init_graph_points();
    graph_initialized = 1;
  );
);

//==============================================================================
// ON SLIDER UPDATES
//==============================================================================

@slider

// Update filter coefficients
update_filter_coefficients();

// Calculate time constants
rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);
hold_samples = floor(hold_ms * 0.001 * srate);

attack_coeff = attack_ms > 0 ? exp(-1000 / (attack_ms * srate)) : 0;
release_coeff = release_ms > 0 ? exp(-1000 / (release_ms * srate)) : 0;

attack_curve != 0 ? attack_coeff = pow(attack_coeff, pow(2, attack_curve));
release_curve != 0 ? release_coeff = pow(release_coeff, pow(2, release_curve));

makeup_gain_linear = db_to_linear(makeup_gain_db);
over_the_top_factor = over_the_top * 0.01;

// Set plugin delay compensation
lookahead_samples > 0 ? (
  pdc_delay = lookahead_samples;
  pdc_bot_ch = 0;
  pdc_top_ch = num_ch;
) : (
  pdc_delay = 0;
);

//==============================================================================
// GFX RUNTIME
//==============================================================================

@gfx 3500 450

// Render the main interface first
render_complete_interface();

    // Debug slider name extraction
    (slider_names_loaded) ? (
      gfx_set(1, 1, 1, 0.8);
      gfx_x = 10;
      gfx_y = 450;
      gfx_printf("=== DEBUG: Slider Names ===");
      gfx_y += 20;
      
      gfx_x = 10;
      gfx_printf("Total sliders found: %d", slider_names_count);
      gfx_y += 25;

      // Show what was extracted during parsing
      gfx_x = 10;
      gfx_printf("EXTRACTED (during parsing):");
      gfx_y += 20;
      gfx_x = 10;
      gfx_printf("0: '%s'", #debug_extracted_0);
      gfx_y += 15;
      gfx_x = 10;
      gfx_printf("1: '%s'", #debug_extracted_1);
      gfx_y += 15;
      gfx_x = 10;
      gfx_printf("2: '%s'", #debug_extracted_2);
      gfx_y += 15;
      gfx_x = 10;
      gfx_printf("3: '%s'", #debug_extracted_3);
      gfx_y += 15;
      gfx_x = 10;
      gfx_printf("4: '%s'", #debug_extracted_4);
      gfx_y += 25;
      
      // Show what's actually in the array (using fixed string slots)
      gfx_x = 10;
      gfx_printf("STORED (in array):");
      gfx_y += 20;
      gfx_x = 10;
      slot_idx = SLIDER_NAMES_BASE + 0;
      gfx_printf("0: '%s'", slot_idx);
      gfx_y += 15;
      gfx_x = 10;
      slot_idx = SLIDER_NAMES_BASE + 1;
      gfx_printf("1: '%s'", slot_idx);
      gfx_y += 15;
      gfx_x = 10;
      slot_idx = SLIDER_NAMES_BASE + 2;
      gfx_printf("2: '%s'", slot_idx);
      gfx_y += 15;
      gfx_x = 10;
      slot_idx = SLIDER_NAMES_BASE + 3;
      gfx_printf("3: '%s'", slot_idx);
      gfx_y += 15;
      gfx_x = 10;
      slot_idx = SLIDER_NAMES_BASE + 4;
      gfx_printf("4: '%s'", slot_idx);
      gfx_y += 25;
      
      // Show what get_parsed_slider_name returns
      gfx_x = 10;
      gfx_printf("RETRIEVED (via function):");
      gfx_y += 20;
      debug_i = 1;
      while(debug_i <= min(5, slider_names_count)) (
        gfx_x = 10;
        gfx_printf("%d: '%s'", debug_i, get_parsed_slider_name(debug_i));
        gfx_y += 15;
        debug_i += 1;
      );
      
      // Debug dropdown options extraction
      gfx_y += 10;
      gfx_x = 10;
      gfx_printf("=== DEBUG: Dropdown Options ===");
      gfx_y += 20;
      
      // Show dropdown options for slider 14 (Harmonic Type)
      gfx_x = 10;
      gfx_printf("Slider 14 (Harmonic Type) - %d options:", get_dropdown_option_count(14));
      gfx_y += 15;
      debug_opt_i = 0;
      while(debug_opt_i < get_dropdown_option_count(14)) (
        gfx_x = 20;
        gfx_printf("  %d: '%s'", debug_opt_i, get_dropdown_option(14, debug_opt_i));
        gfx_y += 12;
        debug_opt_i += 1;
      );
      
      gfx_y += 8;
      // Show dropdown options for slider 25 (Compressor Type)
      gfx_x = 10;
      gfx_printf("Slider 25 (Compressor Type) - %d options:", get_dropdown_option_count(25));
      gfx_y += 15;
      debug_opt_i = 0;
      while(debug_opt_i < get_dropdown_option_count(25)) (
        gfx_x = 20;
        gfx_printf("  %d: '%s'", debug_opt_i, get_dropdown_option(25, debug_opt_i));
        gfx_y += 12;
        debug_opt_i += 1;
      );
      
      gfx_y += 8;
      // Show dropdown options for slider 28 (Program Release Type)
      gfx_x = 10;
      gfx_printf("Slider 28 (Program Release Type) - %d options:", get_dropdown_option_count(28));
      gfx_y += 15;
      debug_opt_i = 0;
      while(debug_opt_i < get_dropdown_option_count(28)) (
        gfx_x = 20;
        gfx_printf("  %d: '%s'", debug_opt_i, get_dropdown_option(28, debug_opt_i));
        gfx_y += 12;
        debug_opt_i += 1;
      );
    );
// Render the contents of the sliders file (filename:0) in the UI


//==============================================================================
// ON SAMPLE 
//==============================================================================

@sample

// Store original signals
input_l_orig = spl0;
input_r_orig = num_ch >= 2 ? spl1 : spl0;

// Select detection source - feedforward vs feedback
detection_mode > 0.5 ? (
  // Feedforward mode: detect from current input
  detect_l = use_sidechain && num_ch >= 3 ? spl2 : spl0;
  detect_r = use_sidechain && num_ch >= 4 ? spl3 : (num_ch >= 2 ? spl1 : spl0);
) : (
  // Feedback mode: detect from previous output (stored in feedback_l/feedback_r)
  // Use feedback values only if they exist (not zero), otherwise use current input
  detect_l = use_sidechain && num_ch >= 3 ? spl2 : (abs(feedback_l_prev) > eps ? feedback_l_prev : spl0);
  detect_r = use_sidechain && num_ch >= 4 ? spl3 : (abs(feedback_r_prev) > eps ? feedback_r_prev : (num_ch >= 2 ? spl1 : spl0));
);

// Apply filters
apply_sidechain_filters(detect_l, detect_r);
detect_l = filtered_l;
detect_r = filtered_r;

// Listen mode bypass
listen_to_sidechain ? (
  spl0 = detect_l;
  num_ch >= 2 ? spl1 = detect_r;
) : (

// Process RMS detection
detector_level = process_rms_detection(detect_l, detect_r);
input_level_db = linear_to_db(detector_level);
current_input_db = input_level_db;

// Calculate gain reduction
target_gr_db = calculate_gain_reduction(input_level_db);

// Apply compressor character
dt = SRATE_INV;
average_input_level = average_input_level * 0.999 + detector_level * 0.001;
// Prevent denormalization
abs(average_input_level) < eps ? average_input_level = 0;
target_gr_db = apply_compressor_character(target_gr_db, compressor_type, detector_level, dt, over_the_top_factor);

// Process envelope following
final_gain_db = process_envelope_following(target_gr_db, detector_level);

// Update previous detector level for next sample
prev_detector_db = linear_to_db(detector_level);

// Convert final gain reduction to linear for application
envelope_out = db_to_linear(final_gain_db);
current_gr_db = final_gain_db;

// Lookahead processing
process_lookahead(input_l_orig, input_r_orig);
processed_l = lookahead_out_l;
processed_r = lookahead_out_r;

// Apply gain reduction
processed_l *= envelope_out * makeup_gain_linear;
processed_r *= envelope_out * makeup_gain_linear;

// Dedicated harmonic processing stage (driven by gain reduction amount)
gr_amount_normalized = abs(current_gr_db) / 30.0; // Normalize GR to 0..1 range
processed_l = apply_harmonic_processing(processed_l, gr_amount_normalized, harmonic_type, harmonic_amount, harmonic_drive, harmonic_mix, harmonic_even_boost, harmonic_odd_boost);
processed_r = apply_harmonic_processing(processed_r, gr_amount_normalized, harmonic_type, harmonic_amount, harmonic_drive, harmonic_mix, harmonic_even_boost, harmonic_odd_boost);

// Final mix
apply_final_mix(processed_l, processed_r, input_l_orig, input_r_orig);
final_l = final_out_l;
final_r = final_out_r;

// Out-of-bounds calculation (after all processing is complete)
// Calculate effective attack/release times including all modifications
effective_attack_time = attack_ms;
effective_release_time = prog_release_mode > 0.5 ? (base_med_s * 1000) : release_ms; // Approximate calculation for display

oob_attack = (effective_attack_time < 0.2);
oob_release = (effective_release_time < 30);
oob_depth = (abs(current_gr_db) > 20);

// Apply soft-clipping brickwall limiter if enabled
brickwall_limiter > 0.5 ? (
  final_l = soft_clip_limiter(final_l, limiter_prev_l);
  final_r = soft_clip_limiter(final_r, limiter_prev_r);
  limiter_prev_l = final_l;
  limiter_prev_r = final_r;
);

// Output final results
spl0 = final_l;
num_ch >= 2 ? spl1 = final_r;

// Store feedback signals for next sample (for feedback detection mode)
feedback_l_prev = final_l;
feedback_r_prev = final_r;

); 