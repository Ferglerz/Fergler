// Advanced Multi-Model Compressor JSFX - Modular Version
// Professional multi-algorithm compressor with interactive graph
// Features: multiple characters, feedforward/feedback, RMS normalization,
// program-dependent release, dedicated harmonic stage, soft-clipping limiter
// Author: Custom JSFX Generator
// Version: 3.0 - Advanced multi-model implementation (Modular)

desc:Advanced Multi-Model Compressor (Modular)


//==============================================================================
// SLIDER DEFINITIONS
//==============================================================================

// Time-related parameters (1-6)
slider1:attack_ms=10<0.1,100,0.1>-Attack (ms)
slider2:attack_curve=0<-2,2,0.01>-Attack Curve
slider3:release_ms=100<10,1000,1>-Release (ms)
slider4:release_curve=0<-2,2,0.01>-Release Curve
slider5:lookahead_ms=0<0,10,0.1>-Lookahead (ms)
slider6:hold_ms=0<0,50,0.1>-Hold Time (ms)

// RMS & Detection parameters (7-10)
slider7:rms_size_ms=10<1,100,0.1>-RMS Window (ms)
slider8:rms_normalization=0<0,1,1{Off,On}>-RMS Normalization
slider9:detection_mode=1<0,1,1{Feedback,Feedforward}>-Detection Mode
slider10:max_gr_db=-10<-30,0,1>-Max GR (dB)

// Filtering parameters (11-12)
slider11:hp_freq=20<20,200,1>-HP Filter (Hz)
slider12:lp_freq=20000<1000,20000,10>-LP Filter (Hz)

// Character & Harmonics parameters (13-20)
slider13:over_the_top=100<0,200,1>-Over The Top
slider14:harmonic_type=0<0,4,1{Off,Tube Even,Tube Odd,Tube Both,Tape Saturation}>-Harmonic Type
slider15:harmonic_amount=0<0,1,0.01>-Harmonic Amount
slider16:harmonic_drive=1<0.5,10,0.1>-Harmonic Drive
slider17:harmonic_mix=0<0,1,0.01>-Harmonic Mix
slider18:harmonic_even_boost=0<0,2,0.01>-Even Harmonic Boost
slider19:harmonic_odd_boost=0<0,2,0.01>-Odd Harmonic Boost
slider20:prog_release_mode=0<0,1,1{Fixed Release,Program-Dependent Release}>-Program Release Mode

// Global parameters (21-30)
slider21:strength=1<0.5,10,0.1>-Strength
slider22:global_offset_db=0<-30,30,0.1>-Global Offset (dB)
slider23:strength_curve=0<-2,2,0.01>-Strength Curve (exp)
slider24:makeup_gain_db=0<-20,20,0.1>-Makeup Gain (dB)
slider25:compressor_type=0<0,6,1{Clean Digital,Varimu,Bridged Diode,VCA,PWM/Fairchild,FET,Optical}>-Compressor Type
slider26:use_sidechain=0<0,1,1{No,Yes}>-Use Sidechain
slider27:listen_to_sidechain=0<0,1,1{No,Yes}>-Listen to Detection Signal
slider28:prog_release_type=0<0,2,1{Level-Dependent,Rate-Of-Change,Hybrid}>-Program Release Type
slider29:brickwall_limiter=1<0,1,1{Off,On}>-Brickwall Limiter

// SEARCH STOP

//==============================================================================
// INCLUDE MODULES
//==============================================================================

// For Claude: These are import, not @import or include or @include

// Constants and debug (must be first)
import 00a_constants.jsfx-inc
import 01f_debug_logging.jsfx-inc

// Core foundation modules
import 01a_memory.jsfx-inc
import 01b_state.jsfx-inc
import 01c_initialization.jsfx-inc
import 01e_ui_config.jsfx-inc
import 01g_file_reading.jsfx-inc

// Utility modules
import 02a_math_utils.jsfx-inc
import 02b_audio_utils.jsfx-inc
import 02c_dsp_utils.jsfx-inc
import 02d_ui_utils.jsfx-inc

// UI interaction (depends on utilities)
import 01d_ui_interaction.jsfx-inc

// Graph data modules
import 03a_graph_data.jsfx-inc
import 03b_graph_interaction.jsfx-inc

// Audio processing modules
import 04a_compression_core.jsfx-inc
import 04b_harmonic_models.jsfx-inc
import 04c_filters.jsfx-inc
import 04d_detection.jsfx-inc
import 04e_envelope.jsfx-inc
import 04f_effects.jsfx-inc

// UI modules
import 05a_ui_core.jsfx-inc
import 05b_ui_controls.jsfx-inc
import 05c_ui_rendering.jsfx-inc
import 05e_ui_graph.jsfx-inc


//==============================================================================
// SERIALIZE
//==============================================================================

@serialize
// Prevent memory/variables from being cleared on @init
ext_noinit = 1.0;

debug_log("");
debug_log("=== SERIALIZATION ===");
debug_logf("Version: %d", graph_serialization_version);
debug_logf("Points: %d", num_points);

// Serialize graph points data for persistence across plugin duplication and project saves
// Format: [version][num_points][point1_x][point1_y][point2_x][point2_y]...[curve1][curve2]...
// Version 1: Basic graph points serialization
// Version 2: Added curve data serialization
// This ensures graph points and curves are preserved when:
// - Duplicating the plugin instance
// - Copying/pasting the track
// - Saving and reopening the project
// - Restarting REAPER
file_var(0, graph_serialization_version);
file_var(0, num_points);

// Save all graph points
i = 0;
while (i < num_points) (
  file_var(0, graph_points[i*2]);     // input_db
  file_var(0, graph_points[i*2 + 1]); // output_db
  i += 1;
);

// Save curve data (Version 2+)
graph_serialization_version >= 2 ? (
  i = 0;
  while (i < num_points) (
    file_var(0, curve_amounts[i]);
    i += 1;
  );
);

@init

//==============================================================================
// INITIALIZATION SEQUENCE
//==============================================================================

// Clear and start debug logging
debug_clear();
debug_log("");
debug_log("=== PLUGIN INITIALIZATION ===");

// 1. Initialize all constants, memory, and state variables
debug_log("Allocating memory...");
perform_complete_initialization();
debug_logf("Memory allocated: %d bytes", get_memory_usage());

// 2. Read slider definitions from file
debug_log("Reading slider definitions...");
read_slider_definitions();

slider_names_loaded ? (
  debug_logf("Loaded %d slider definitions", slider_names_count);
) : (
  debug_log("ERROR: Failed to load slider definitions");
);

// 3. Initialize curve data
debug_log("Initializing curve data...");
init_curve_data();

// 4. Set up control layout
debug_log("Setting up control layout...");
setup_control_layout();
debug_logf("Configured %d controls", num_controls);

// 5. Initialize or restore graph points
debug_log("Initializing graph...");
!graph_initialized ? (
  // Try to restore from serialized data
  restore_graph_points_from_serialization() ? (
    debug_log("Restored graph from saved data");
  ) : (
    // Initialize with defaults
    num_points = 6;
    init_graph_points();
    debug_log("Initialized default graph points");
  );
  graph_initialized = 1;
);
debug_logf("Graph ready with %d points", num_points);

// 6. Initialization complete
debug_separator();
debug_log("INITIALIZATION COMPLETE");
debug_logf("Total debug messages: %d", debug_get_message_count());

//==============================================================================
// ON SLIDER UPDATES
//==============================================================================

@slider

// Track which parameters actually changed
param_changed = 0;

// --- Filter Parameters (11-12) ---
(slider11 != hp_freq_prev || slider12 != lp_freq_prev) ? (
  update_filter_coefficients();
  param_changed = 1;
  hp_freq_prev = slider11;
  lp_freq_prev = slider12;
);

// --- Timing Parameters (1-6) ---
(slider1 != attack_ms_prev || slider3 != release_ms_prev || 
 slider5 != lookahead_ms_prev || slider6 != hold_ms_prev ||
 slider7 != rms_size_ms_prev) ? (
  
  // Calculate sample counts
  rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
  lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);
  hold_samples = floor(hold_ms * 0.001 * srate);

  // Calculate time coefficients
  attack_coeff = attack_ms > 0 ? exp(-1000 / (attack_ms * srate)) : 0;
  release_coeff = release_ms > 0 ? exp(-1000 / (release_ms * srate)) : 0;

  // Apply curves if set
  attack_curve != 0 ? attack_coeff = pow(attack_coeff, pow(2, attack_curve));
  release_curve != 0 ? release_coeff = pow(release_coeff, pow(2, release_curve));
  
  param_changed = 1;
  
  // Store for next comparison
  attack_ms_prev = slider1;
  release_ms_prev = slider3;
  lookahead_ms_prev = slider5;
  hold_ms_prev = slider6;
  rms_size_ms_prev = slider7;
);

// --- Makeup Gain (24) ---
slider24 != makeup_gain_db_prev ? (
  makeup_gain_linear = db_to_linear(makeup_gain_db);
  makeup_gain_db_prev = slider24;
  param_changed = 1;
);

// --- Over The Top (13) ---
slider13 != over_the_top_prev ? (
  over_the_top_factor = over_the_top * 0.01;
  over_the_top_prev = slider13;
  param_changed = 1;
);

// --- Plugin Delay Compensation ---
slider5 != lookahead_ms_pdc_prev ? (
  lookahead_samples > 0 ? (
    pdc_delay = lookahead_samples;
    pdc_bot_ch = 0;
    pdc_top_ch = num_ch;
  ) : (
    pdc_delay = 0;
  );
  lookahead_ms_pdc_prev = slider5;
);

// --- Curve-affecting parameters ---
(slider21 != strength_prev || slider22 != global_offset_db_prev ||
 slider23 != strength_curve_prev) ? (
  strength_prev = slider21;
  global_offset_db_prev = slider22;
  strength_curve_prev = slider23;
  param_changed = 1;
);

// Debug parameter changes
param_changed ? (
  debug_logf("Parameters updated (count: %d)", param_changed);
);

//==============================================================================
// ON BLOCK
//==============================================================================

@block

//==============================================================================
// GFX RUNTIME
//==============================================================================

@gfx 3500 450

// Render main interface
render_complete_interface();

// Render debug information (controlled by DEBUG_ENABLED in 01f_debug_logging.jsfx-inc)
debug_render();


//==============================================================================
// ON SAMPLE 
//==============================================================================

@sample

// === INPUT STAGE ===
// Cache original signals (avoid multiple memory accesses)
input_l_orig = spl0;
input_r_orig = spl1;

// Pre-calculate channel availability flags
has_stereo = (num_ch >= 2);
has_sidechain_l = (use_sidechain && num_ch >= 3);
has_sidechain_r = (use_sidechain && num_ch >= 4);

// === DETECTION SOURCE SELECTION ===
// Feedforward: use current input or sidechain
// Feedback: use previous output (stored values)
detection_mode > 0.5 ? (
  // Feedforward mode
  detect_l = has_sidechain_l ? spl2 : spl0;
  detect_r = has_sidechain_r ? spl3 : (has_stereo ? spl1 : spl0);
) : (
  // Feedback mode with fallback
  detect_l = has_sidechain_l ? spl2 : (abs(feedback_l_prev) > 0.000000000000000000000000000001 ? feedback_l_prev : spl0);
  detect_r = has_sidechain_r ? spl3 : (abs(feedback_r_prev) > 0.000000000000000000000000000001 ? feedback_r_prev : (has_stereo ? spl1 : spl0));
);

// === SIDECHAIN FILTERING ===
apply_sidechain_filters(detect_l, detect_r);
detect_l = filtered_l;
detect_r = filtered_r;

// === LISTEN MODE (early exit) ===
listen_to_sidechain ? (
  spl0 = detect_l;
  has_stereo ? spl1 = detect_r;
) : (
  // === MAIN PROCESSING PATH ===
  
  // RMS Detection
  detector_level = process_rms_detection(detect_l, detect_r);
  input_level_db = linear_to_db(detector_level);
  current_input_db = input_level_db;

  // Gain Reduction Calculation
  target_gr_db = calculate_gain_reduction(input_level_db);

  // Character Application
  dt = 1 / srate;
  average_input_level = average_input_level * 0.999 + detector_level * 0.001;
  // Prevent denormalization
  abs(average_input_level) < 0.000000000000000000000000000001 ? average_input_level = 0;
  target_gr_db = apply_compressor_character(target_gr_db, compressor_type, detector_level, dt, over_the_top_factor);

  // Envelope Following
  final_gain_db = process_envelope_following(target_gr_db, detector_level);
  prev_detector_db = linear_to_db(detector_level);

  // Convert to linear and store for display
  envelope_out = db_to_linear(final_gain_db);
  current_gr_db = final_gain_db;

  // Lookahead Processing
  process_lookahead(input_l_orig, input_r_orig);
  processed_l = lookahead_out_l;
  processed_r = lookahead_out_r;

  // Apply gain reduction
  processed_l *= envelope_out * makeup_gain_linear;
  processed_r *= envelope_out * makeup_gain_linear;

  // Dedicated harmonic processing stage (driven by gain reduction amount)
  gr_amount_normalized = abs(current_gr_db) / 30.0; // Normalize GR to 0..1 range
  processed_l = apply_harmonic_processing(processed_l, gr_amount_normalized, harmonic_type, harmonic_amount, harmonic_drive, harmonic_mix, harmonic_even_boost, harmonic_odd_boost);
  processed_r = apply_harmonic_processing(processed_r, gr_amount_normalized, harmonic_type, harmonic_amount, harmonic_drive, harmonic_mix, harmonic_even_boost, harmonic_odd_boost);

  // Final Mix (no wrapper needed)
  final_l = processed_l;
  final_r = processed_r;

  // Brickwall Limiter (conditional)
  brickwall_limiter > 0.5 ? (
    final_l = soft_clip_limiter(final_l, limiter_prev_l);
    final_r = soft_clip_limiter(final_r, limiter_prev_r);
    limiter_prev_l = final_l;
    limiter_prev_r = final_r;
  );

  // === OUTPUT STAGE ===
  spl0 = final_l;
  has_stereo ? spl1 = final_r;

  // Store for feedback mode
  feedback_l_prev = final_l;
  feedback_r_prev = final_r;
); 