// File Reading Module  
// Simplified slider definition parsing with robust string handling
// Depends on: 00e_debug_logging.jsfx-inc

@init

//==============================================================================
// FILE READING CONFIGURATION
//==============================================================================

// String slot allocation (JSFX limit: slots 0-63)
// Slots 0-49: Debug messages (see 00e_debug_logging.jsfx-inc)
// Slots 50-63: Reserved for temporary #variables and system use
// Note: Slider names and dropdown options must use non-string memory or be limited

SLIDER_NAMES_BASE = 100; // This will need to be changed to use non-string memory
DROPDOWN_OPTIONS_BASE = 200; // This will need to be changed to use non-string memory
MAX_OPTIONS_PER_SLIDER = 20;

// Non-string memory for option counts (array of integers)
dropdown_option_counts_base = 10000;

// Slider parameter storage (default, min, max, increment)
// Each slider has 4 values: [default, min, max, inc]
slider_params_base = 11000;

// File reading state
slider_names_count = 0;
slider_names_loaded = 0;

//==============================================================================
// CHARACTER SCANNING UTILITIES
//==============================================================================

function scan_for_char(str, char, start_pos) (
  len = strlen(str);
  pos = -1;
  i = start_pos;
  
  while (i < len && pos < 0) (
    str_getchar(str, i) == char ? pos = i;
    i += 1;
  );
  pos;
);

function is_slider_line(str) (
  strlen(str) >= 6 && strncmp(str, "slider", 6) == 0;
);

function is_stop_line(str) (
  strcmp(str, "// SEARCH STOP") == 0;
);

// Extract slider number from slider line (e.g., "slider36:..." -> 36)
function extract_slider_number(str) (
  len = strlen(str);
  slider_num = 0;
  i = 6; // Start after "slider"
  
  // Read digits until we hit ':' or non-digit
  while (i < len) (
    c = str_getchar(str, i);
    // Check if character is a digit (ASCII 48-57 for '0'-'9')
    c >= 48 && c <= 57 ? (
      slider_num = slider_num * 10 + (c - 48);
      i += 1;
    ) : (
      i = len; // Break
    );
  );
  
  slider_num;
);

//==============================================================================
// STRING TO NUMBER CONVERSION
//==============================================================================

function string_to_number(str_slot) (
  len = strlen(str_slot);
  result = 0;
  sign = 1;
  decimal_place = 0;
  i = 0;
  
  // Handle sign
  i < len && str_getchar(str_slot, i) == 45 ? (
    sign = -1;
    i += 1;
  );
  
  // Parse integer part
  while (i < len) (
    c = str_getchar(str_slot, i);
    c == 46 ? (
      // Found decimal point
      decimal_place = 1;
      i += 1;
    ) : c >= 48 && c <= 57 ? (
      // Found digit
      digit = c - 48;
      decimal_place > 0 ? (
        result = result + digit * pow(10, -decimal_place);
        decimal_place += 1;
      ) : (
        result = result * 10 + digit;
      );
      i += 1;
    ) : (
      // Invalid character, stop parsing
      i = len;
    );
  );
  
  result * sign;
);

//==============================================================================
// SLIDER PARAMETER EXTRACTION
//==============================================================================

function extract_slider_params(line, slider_index) (
  len = strlen(line);
  
  // Find '=' character (ASCII 61)
  pos_equals = scan_for_char(line, 61, 0);
  
  pos_equals >= 0 ? (
    // Find '<' character (ASCII 60)
    pos_less = scan_for_char(line, 60, pos_equals);
    
    pos_less > pos_equals ? (
      // Extract default value (between '=' and '<')
      default_start = pos_equals + 1;
      default_len = pos_less - default_start;
      default_str_start = 50; // Use a temporary string slot under 100
      strcpy_substr(default_str_start, line, default_start, default_len);
      
      // Find '>' character (ASCII 62)
      pos_greater = scan_for_char(line, 62, pos_less);
      
      pos_greater > pos_less ? (
        // Extract min,max,inc values (between '<' and '>')
        params_start = pos_less + 1;
        params_len = pos_greater - params_start;
        params_str_start = 2001; // Use another temporary string slot
        
        debug_logf("pos_less: %d", pos_less);
        debug_logf("pos_greater: %d", pos_greater);
        debug_logf("params_start: %d", params_start);
        debug_logf("params_len: %d", params_len);
        
        // Try direct character-by-character parsing instead of substring extraction
        debug_log("Trying direct parsing...");
        
        // Parse min,max,inc directly from the line
        min_val = 0;
        max_val = 1;
        inc_val = 0.01;
        
        // Find commas in the original line
        comma1_in_line = scan_for_char(line, 44, params_start); // ASCII 44 = ','
        comma2_in_line = scan_for_char(line, 44, comma1_in_line + 1);
        
        debug_logf("Comma1 in line at: %d", comma1_in_line);
        debug_logf("Comma2 in line at: %d", comma2_in_line);
        
        // Extract min value (between params_start and comma1_in_line)
        comma1_in_line > params_start ? (
          min_len = comma1_in_line - params_start;
          strcpy_substr(51, line, params_start, min_len);
          min_val = string_to_number(51);
          debug_logf("Min string length: %d", min_len);
        );
        
        // Extract max value (between comma1_in_line and comma2_in_line)  
        comma2_in_line > comma1_in_line ? (
          max_len = comma2_in_line - comma1_in_line - 1;
          strcpy_substr(52, line, comma1_in_line + 1, max_len);
          max_val = string_to_number(52);
          debug_logf("Max string length: %d", max_len);
        );
        
        // Extract inc value (between comma2_in_line and pos_greater)
        pos_greater > comma2_in_line ? (
          inc_len = pos_greater - comma2_in_line - 1;
          strcpy_substr(53, line, comma2_in_line + 1, inc_len);
          inc_val = string_to_number(53);
          debug_logf("Inc string length: %d", inc_len);
        );
        
        // Parse default value
        default_val = string_to_number(default_str_start);
        
        // Store parameters in memory
        base_offset = slider_index * 4;
        slider_params_base[base_offset + 0] = default_val;
        slider_params_base[base_offset + 1] = min_val;
        slider_params_base[base_offset + 2] = max_val;
        slider_params_base[base_offset + 3] = inc_val;
        
        debug_log2f("Slider %d default: %.3f", slider_index + 1, default_val);
        debug_log2f("Slider %d min: %.3f", slider_index + 1, min_val);
        debug_log2f("Slider %d max: %.3f", slider_index + 1, max_val);
        debug_log2f("Slider %d inc: %.3f", slider_index + 1, inc_val);
        
        // Debug: Show what strings we're trying to parse
        debug_log("Parsing strings:");
        debug_logf("Default str: %s", default_str_start);
        debug_logf("Min str: %s", 51);
        debug_logf("Max str: %s", 52);
        debug_logf("Inc str: %s", 53);
        
        1; // Success
      ) : (
        debug_logf("WARNING: No '>' found in slider params for index %d", slider_index);
        0;
      );
    ) : (
      debug_logf("WARNING: No '<' found in slider params for index %d", slider_index);
      0;
    );
  ) : (
    debug_logf("WARNING: No '=' found in slider line %d", slider_index + 1);
    0;
  );
);

//==============================================================================
// SLIDER NAME EXTRACTION
//==============================================================================

function extract_slider_name(line, index) (
  len = strlen(line);
  
  // Find '>' character (ASCII 62)
  pos_greater = scan_for_char(line, 62, 0);
  
  pos_greater >= 0 ? (
    name_start = pos_greater + 1;
    
    // Check for optional '-' after '>' (ASCII 45)
    name_start < len && str_getchar(line, name_start) == 45 ? (
      name_start += 1;
    );
    
    // Extract name to dedicated string slot
    name_len = len - name_start;
    name_len > 0 ? (
      target_slot = SLIDER_NAMES_BASE + index;
      strcpy_substr(target_slot, line, name_start, name_len);
      debug_log3f("Slider %d -> slot %d: %s", index + 1, target_slot, target_slot);
      1; // Success
    ) : (
      debug_logf("WARNING: Empty slider name for index %d", index);
      0;
    );
  ) : (
    debug_logf("WARNING: No '>' found in slider line %d", index + 1);
    0;
  );
);

//==============================================================================
// DROPDOWN OPTIONS EXTRACTION  
//==============================================================================

function extract_dropdown_options(line, slider_index) (
  // Find '{' (ASCII 123) and '}' (ASCII 125)
  pos_open = scan_for_char(line, 123, 0);
  
  pos_open >= 0 ? (
    pos_close = scan_for_char(line, 125, pos_open);
    
    pos_close > pos_open ? (
      // Extract options substring to temporary string
      strcpy_substr(#dropdown_temp, line, pos_open + 1, pos_close - pos_open - 1);
      temp_len = strlen(#dropdown_temp);
      
      // Parse comma-separated options
      base_slot = DROPDOWN_OPTIONS_BASE + (slider_index * MAX_OPTIONS_PER_SLIDER);
      opt_count = 0;
      option_start = 0;
      i = 0;
      
      while (i <= temp_len && opt_count < MAX_OPTIONS_PER_SLIDER) (
        char = str_getchar(#dropdown_temp, i);
        
        // Found comma (ASCII 44) or end of string
        (char == 44 || i == temp_len) ? (
          i > option_start ? (
            strcpy_substr(base_slot + opt_count, #dropdown_temp, option_start, i - option_start);
            debug_log3f("  Option %d (slot %d): %s", 
              opt_count, base_slot + opt_count, base_slot + opt_count);
            opt_count += 1;
          );
          option_start = i + 1;
        );
        i += 1;
      );
      
      dropdown_option_counts_base[slider_index] = opt_count;
      debug_log2f("  Total %d options for slider %d", opt_count, slider_index + 1);
      opt_count;
    ) : (
      debug_logf("WARNING: Malformed dropdown (no closing brace) in slider %d", slider_index + 1);
      dropdown_option_counts_base[slider_index] = 0;
      0;
    );
  ) : (
    // No dropdown options (normal case)
    dropdown_option_counts_base[slider_index] = 0;
    0;
  );
);

//==============================================================================
// MAIN FILE READING FUNCTION
//==============================================================================

function read_slider_definitions() (
  debug_log("Reading slider definitions...");
  debug_log("");
  debug_log("=== SLIDER DEFINITION PARSING ===");
  debug_log("Opening Composure.jsfx...");
  
  handle = file_open("Composure.jsfx");
  
  handle != -1 ? (
    max_slider_num = 0;
    found_stop = 0;
    line_count = 0;
    
    while (file_avail(handle) > 0 && !found_stop) (
      file_string(handle, #line);
      line_count += 1;
      
      is_stop_line(#line) ? (
        found_stop = 1;
        debug_logf("Found stop marker at line %d", line_count);
      ) : is_slider_line(#line) ? (
        // Extract the actual slider number from the line
        slider_num = extract_slider_number(#line);
        
        slider_num > 0 && slider_num <= 64 ? (
          // Use actual slider number as index (slider_num - 1)
          slider_index = slider_num - 1;
          extract_slider_params(#line, slider_index);
          extract_slider_name(#line, slider_index);
          extract_dropdown_options(#line, slider_index);
          
          // Track highest slider number seen
          slider_num > max_slider_num ? max_slider_num = slider_num;
        ) : (
          debug_log2f("WARNING: Invalid slider number %d at line %d", slider_num, line_count);
        );
      );
    );
    
    file_close(handle);
    
    slider_names_count = max_slider_num;
    slider_names_loaded = 1;
    
    debug_separator();
    debug_logf("SUCCESS: Loaded slider definitions (highest: slider%d)", max_slider_num);
    1; // Success
  ) : (
    debug_log("ERROR: Could not open Composure.jsfx");
    debug_log("Check that file exists in same directory as plugin");
    
    slider_names_count = 0;
    slider_names_loaded = 0;
    0; // Failed
  );
);

//==============================================================================
// ACCESSOR FUNCTIONS (for 02d_ui_utils.jsfx-inc)
//==============================================================================

function get_slider_name(slider_num) (
  slider_names_loaded && slider_num > 0 && slider_num <= slider_names_count ? (
    array_index = slider_num - 1;
    SLIDER_NAMES_BASE + array_index; // Return string slot number
  ) : (
    debug_logf("WARNING: Invalid slider number %d requested", slider_num);
    #empty_str = "";
    #empty_str;
  );
);

function get_dropdown_option_count(slider_num) (
  array_index = slider_num - 1;
  array_index >= 0 && array_index < slider_names_count ? (
    dropdown_option_counts_base[array_index]
  ) : 0;
);

function get_dropdown_option(slider_num, option_index) (
  array_index = slider_num - 1;
  array_index >= 0 && option_index >= 0 && 
  option_index < get_dropdown_option_count(slider_num) ? (
    base_slot = DROPDOWN_OPTIONS_BASE + (array_index * MAX_OPTIONS_PER_SLIDER);
    base_slot + option_index; // Return string slot number
  ) : (
    #empty_str = "";
    #empty_str;
  );
);

//==============================================================================
// SLIDER PARAMETER ACCESSOR FUNCTIONS
//==============================================================================

function get_slider_default(slider_num) (
  array_index = slider_num - 1;
  array_index >= 0 && array_index < slider_names_count ? (
    slider_params_base[array_index * 4 + 0]
  ) : 0
);

function get_slider_min(slider_num) (
  array_index = slider_num - 1;
  array_index >= 0 && array_index < slider_names_count ? (
    slider_params_base[array_index * 4 + 1]
  ) : 0
);

function get_slider_max(slider_num) (
  array_index = slider_num - 1;
  array_index >= 0 && array_index < slider_names_count ? (
    slider_params_base[array_index * 4 + 2]
  ) : 1
);

function get_slider_increment(slider_num) (
  array_index = slider_num - 1;
  array_index >= 0 && array_index < slider_names_count ? (
    slider_params_base[array_index * 4 + 3]
  ) : 0.01
);




