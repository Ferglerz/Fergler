// UI Utilities Module
// Pure UI utility functions and coordinate conversions
// Contains control accessor functions and basic UI utilities
//
// Dependencies:
// - 01_Utils/01_constants.jsfx-inc (for GRAPH_* and UI constants)
// - 01_Utils/04_file_reading.jsfx-inc (for get_slider_name function)
// - 01_Utils/05_memory.jsfx-inc (for control_defs array)

@init


// Get slider property for a control
function get_slider_property(control_index, property_index) (
  array_index = control_index * 4 + property_index;
  array_index >= 0 && array_index < NUM_CONTROLS * 4 ? (
    slider_properties_base[array_index]
  ) : 0;
);

// Slider property accessor functions
function get_slider_increment(control_index) (
  get_slider_property(control_index, 0);
);

function get_slider_fill_direction(control_index) (
  get_slider_property(control_index, 1);
);

function get_slider_format_as_frequency(control_index) (
  get_slider_property(control_index, 2) > 0;
);


//==============================================================================
// BASIC UI UTILITIES
//==============================================================================

function is_point_in_control(x, y, control_index) local(group_idx) (
  ctrl_x = control_defs[control_index*11 + 1];
  ctrl_y = control_defs[control_index*11 + 2];
  ctrl_w = control_defs[control_index*11 + 3];
  ctrl_h = control_defs[control_index*11 + 4];
  group_idx = control_defs[control_index*11 + 10];

  // Add group offset if control is in a group
  group_idx >= 0 ? (
    ctrl_x += group_defs[group_idx*6 + 0];
    ctrl_y += group_defs[group_idx*6 + 1];
  );
  
  x >= ctrl_x && x <= ctrl_x + ctrl_w && y >= ctrl_y && y <= ctrl_y + ctrl_h;
);

function is_point_in_knob(x, y, knob_index) local(group_idx) (
  knob_x = knob_defs[knob_index*10 + 0];
  knob_y = knob_defs[knob_index*10 + 1];
  knob_size = knob_defs[knob_index*10 + 6] == 1 ? LARGE_KNOB_SIZE : KNOB_SIZE;
  group_idx = knob_defs[knob_index*10 + 9];

  // Add group offset if knob is in a group
  group_idx >= 0 ? (
    knob_x += group_defs[group_idx*6 + 0];
    knob_y += group_defs[group_idx*6 + 1];
  );
  
  x >= knob_x && x <= knob_x + knob_size && y >= knob_y && y <= knob_y + knob_size;
);

function update_slider_value(control_index, mouse_x, mouse_y) local(group_idx, control_type, param_index, option_count, option_index, i, opt_value, reverse_mode, ctrl_x_rel, ctrl_x_abs, group_x_val, slider_orientation, format_options) (
  slider_config = control_defs[control_index*11 + 8];
  slider_orientation = slider_config & 0xFF;  // Extract slider orientation from config
  format_options = (slider_config >> 32) & 0xFF;  // Extract format options
  min_val = control_defs[control_index*11 + 6];
  max_val = control_defs[control_index*11 + 7];
  group_idx = control_defs[control_index*11 + 10];
  control_type = control_defs[control_index*11 + 0];
  param_index = control_defs[control_index*11 + 5];

  slider_orientation == ORIENTATION_VERTICAL ? ( // Vertical slider
    ctrl_y = control_defs[control_index*11 + 2];
    ctrl_h = control_defs[control_index*11 + 4];

    // Add group offset if control is in a group
    group_idx >= 0 ? (
      ctrl_y += group_defs[group_idx*6 + 1];
    );

    normalized_pos = (mouse_y - ctrl_y) / ctrl_h;
    normalized_pos = max(0, min(1, normalized_pos));
    // Invert for vertical slider (0 at top, 1 at bottom)
    normalized_pos = 1 - normalized_pos;
  ) : ( // Horizontal slider (normal or reverse)
    ctrl_x_rel = control_defs[control_index*11 + 1];
    ctrl_w = control_defs[control_index*11 + 3];

    // Add group offset if control is in a group
    group_idx >= 0 ? (
      group_x_val = group_defs[group_idx*6 + 0];
      ctrl_x = ctrl_x_rel + group_x_val;
    ) : (
      ctrl_x = ctrl_x_rel;
    );
    
    normalized_pos = (mouse_x - ctrl_x) / ctrl_w;
    normalized_pos = max(0, min(1, normalized_pos));
    
    // Handle reverse sliders - invert the normalized position
    format_options & OPTION_REVERSE ? (
      normalized_pos = 1.0 - normalized_pos;
    );
  );
  
  // For freq_list_slider (type 4), map position to enumerated values
  control_type == 4 ? (
    // Get the number of enumerated options
    option_count = get_dropdown_option_count(param_index);
    
    option_count > 0 ? (
      // Check if this is a reverse slider
      reverse_mode = (format_options & OPTION_REVERSE);
      
      // Map normalized position (0.0 to 1.0) to option index (0 to option_count-1)
      // Use (option_count - 1) to ensure even distribution across all options
      reverse_mode ? (
        // For reverse sliders, left = last option, right = first option
        option_index = floor((1 - normalized_pos) * (option_count - 1) + 0.5);
      ) : (
        // For normal sliders, left = first option, right = last option
        option_index = floor(normalized_pos * (option_count - 1) + 0.5);
      );
      
      // Clamp to valid range (safety check)
      option_index = max(0, min(option_count - 1, option_index));
      
      // Get the pre-parsed numeric value at this index (fast, no string conversion)
      // This returns ONLY values from our cached enumerated list
      get_dropdown_option_value(param_index, option_index);
    ) : (
      // Fallback: no enumerated options, use continuous range
      min_val + normalized_pos * (max_val - min_val);
    );
  ) : (
    // For normal sliders, use continuous range with increment snapping
    raw_value = min_val + normalized_pos * (max_val - min_val);
    increment = get_slider_increment(param_index);
    increment > 0 ? (
      // Snap to nearest increment step
      floor(raw_value / increment + 0.5) * increment
    ) : (
      raw_value
    );
  );
);

// Shared function to update value from mouse delta
function update_value_from_mouse_delta(current_value, min_val, max_val, mouse_dy, sensitivity, param_index) (
  // Vertical mouse movement controls value (down = increase, up = decrease)
  value_range = max_val - min_val;
  delta = -mouse_dy * sensitivity * value_range / 100; // Negative because down = increase
  
  new_value = current_value + delta;
  new_value = max(min_val, min(max_val, new_value));
  
  // Apply increment snapping
  increment = get_slider_increment(param_index);
  increment > 0 ? (
    // Snap to nearest increment step
    floor(new_value / increment + 0.5) * increment
  ) : (
    new_value
  );
);

//==============================================================================
// SLIDER PROPERTIES SYSTEM
//==============================================================================

// Set slider property for a control
function set_slider_property(control_index, property_index, value) (
  array_index = control_index * 4 + property_index;
  array_index >= 0 && array_index < NUM_CONTROLS * 4 ? (
    slider_properties_base[array_index] = value;
  );
);

// Convenience functions for common properties
function set_slider_increment(control_index, increment) (
  set_slider_property(control_index, 0, increment);
);

function set_slider_fill_direction(control_index, direction) (
  set_slider_property(control_index, 1, direction);
);

function set_slider_format_as_frequency(control_index, format_freq) (
  set_slider_property(control_index, 2, format_freq ? 1 : 0);
);

// Format value for display based on slider properties
function format_slider_value(control_index, value) local(increment, format_freq, rounded_value) (
  increment = get_slider_increment(control_index);
  format_freq = get_slider_format_as_frequency(control_index);
  
  // Apply rounding if increment is specified
  increment > 0 ? (
    rounded_value = floor(value / increment + 0.5) * increment;
  ) : (
    rounded_value = value;
  );
  
  // Check for special "Off" values
  rounded_value == 0 || rounded_value >= 16000 ? (
    sprintf(#formatted_str, "Off");
  ) : format_freq ? (
    // Format as frequency (show "k" suffix if > 999)
    rounded_value > 999 ? (
      freq_khz = rounded_value / 1000;
      freq_khz == floor(freq_khz) ? (
        sprintf(#formatted_str, "%.0fk", freq_khz);
      ) : (
        sprintf(#formatted_str, "%.1fk", freq_khz);
      );
    ) : (
      sprintf(#formatted_str, "%.0f", rounded_value);
    );
  ) : (
    // Standard numeric formatting
    sprintf(#formatted_str, "%.2f", rounded_value);
  );
  
  #formatted_str;
);

function update_knob_value_from_mouse(knob_index, mouse_x, mouse_y) (
  param_index = knob_defs[knob_index*10 + 2];
  min_val = knob_defs[knob_index*10 + 3];
  max_val = knob_defs[knob_index*10 + 4];
  knob_size = knob_defs[knob_index*10 + 6];
  
  // Get current value
  current_value = slider(param_index);
  
  // Calculate mouse delta from previous position
  mouse_dy = mouse_y - ui_prev_mouse_y;
  
  // Get sensitivity based on knob size (large knobs = finer control)
  sensitivity = knob_size == 1 ? LARGE_KNOB_SENSITIVITY : KNOB_SENSITIVITY;
  
  // Update value based on mouse movement
  new_value = update_value_from_mouse_delta(current_value, min_val, max_val, mouse_dy, sensitivity, param_index);
  
  // Update knob value and slider
  knob_defs[knob_index*9 + 8] = new_value;
  slider(param_index) = new_value;
  sliderchange(1 << (param_index - 1));
  
  new_value;
);

function update_knob_value_from_mouse_with_mult(knob_index, mouse_x, mouse_y, multiplier) (
  param_index = knob_defs[knob_index*10 + 2];
  min_val = knob_defs[knob_index*10 + 3];
  max_val = knob_defs[knob_index*10 + 4];
  knob_size = knob_defs[knob_index*10 + 6];
  
  // Get current value
  current_value = slider(param_index);
  
  // Calculate mouse delta from previous position with multiplier
  mouse_dy = (mouse_y - ui_prev_mouse_y) * multiplier;
  
  // Get sensitivity based on knob size (large knobs = finer control)
  sensitivity = knob_size == 1 ? LARGE_KNOB_SENSITIVITY : KNOB_SENSITIVITY;
  
  // Update value based on mouse movement
  new_value = update_value_from_mouse_delta(current_value, min_val, max_val, mouse_dy, sensitivity, param_index);
  
  // Update knob value and slider
  knob_defs[knob_index*9 + 8] = new_value;
  slider(param_index) = new_value;
  sliderchange(1 << (param_index - 1));
  
  new_value;
);


//==============================================================================
// COORDINATE CLAMPING HELPERS
//==============================================================================

// Note: Graph coordinate conversion functions (db_to_graph_x, db_to_graph_y, etc.)
// are now defined in 03_Compression/02_graph_data_core.jsfx-inc where they belong


function clamp_x_to_graph(x) (
  max(GRAPH_X, min(GRAPH_X + GRAPH_SIZE, x))
);

function clamp_y_to_graph(y) (
  max(GRAPH_Y, min(GRAPH_Y + GRAPH_SIZE, y))
);

//==============================================================================
// DRAWING HELPERS
//==============================================================================

function draw_indicator_circle(x, y, radius, r, g, b, alpha, filled) (
  gfx_set(r, g, b, alpha);
  gfx_circle(x, y, radius, filled, 1); 
);


function draw_curve_segment(end_x, end_y, is_first_point) (
  is_first_point ? (
    gfx_x = end_x;
    gfx_y = end_y;
  ) : (
    gfx_lineto(end_x, end_y, 1); 
  );
);

//==============================================================================
// DISPLAY FORMATTING FUNCTIONS
//==============================================================================

// Calculate decimal places based on increment
function get_decimal_places(increment) (
  increment <= 0 ? 2 : (
    increment >= 1 ? 0 : (
      increment >= 0.1 ? 1 : (
        increment >= 0.01 ? 2 : 3
      )
    )
  )
);

// Format value with appropriate decimal places and suffix
function format_value_with_suffix(value, increment, display_mode) local(decimal_places, format_str) (
  decimal_places = get_decimal_places(increment);
  
  display_mode == DISPLAY_PERCENT ? (
    sprintf(#temp_display_str, "%%.%df %%", decimal_places, value);
  ) : display_mode == DISPLAY_DB ? (
    sprintf(#temp_display_str, "%%.%df dB", decimal_places, value);
  ) : display_mode == DISPLAY_MS ? (
    sprintf(#temp_display_str, "%%.%df ms", decimal_places, value);
  ) : (
    sprintf(#temp_display_str, "%%.%df", decimal_places, value);
  );
  
  temp_display_str;
);
