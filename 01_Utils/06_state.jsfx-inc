// State Management Module
// State variable initialization and management
// Depends on: 00a_constants.jsfx-inc, 00b_math_utils.jsfx-inc

@init


//==============================================================================
// STATE VARIABLES INITIALIZATION
//==============================================================================

// Function to clear RMS buffer state when window size changes
function clear_rms_state() (
  // Stereo RMS sums (separate L/R tracking)
  rms_sum_l = 0;
  rms_sum_r = 0;
  rms_pos = 0;
  
  // Clear stereo interleaved RMS buffer [L, R, L, R, ...] up to max size
  i = 0;
  while (i < max_rms_samples * 2) ( // *2 for stereo
    rms_buffer[i] = 0;
    i += 1;
  );
);

function init_state_variables() (
  // Audio processing state
  clear_rms_state();
  lookahead_pos = 0;

  // Filter states
  hp_x1_l=hp_x2_l=hp_y1_l=hp_y2_l=0;
  hp_x1_r=hp_x2_r=hp_y1_r=hp_y2_r=0;
  lp_x1_l=lp_x2_l=lp_y1_l=lp_y2_l=0;
  lp_x1_r=lp_x2_r=lp_y1_r=lp_y2_r=0;

  // Filter coefficients
  hp_b0=hp_b1=hp_b2=hp_a1=hp_a2=0;
  lp_b0=lp_b1=lp_b2=lp_a1=lp_a2=0;

  // Compressor character state (kept for potential future use)
  compression_history = 0;
  program_release_timer = 0;

  // RMS normalization state
  rms_max = 0.5;  // Start at mid-level to avoid initial over-normalization
  
  // Exponential smoothing state (for non-buffer RMS mode)
  rms_smoothed_squared = 0;

  // Program release state
  base_fast_s = 0.05;  // 50ms
  base_med_s = 0.3;    // 300ms
  base_slow_s = 1.0;   // 1000ms
  global_smoothed_gain_db = 0;
  
  // Min() envelope mode state variables
  min_env_yR = 0;  // Release filter state
  min_env_yA = 0;  // Attack filter state

  // Limiter state variables
  limiter_prev_l = 0;
  limiter_prev_r = 0;

  // Feedback detection state (stores previous sample output for feedback mode)
  final_l_prev = 0;
  final_r_prev = 0;

  // Display state
  current_input_db = GRAPH_MIN_DB;
  current_gr_db = 0;
  
  // Block-level histogram max tracking (linear values, converted to dB in @block)
  detector_level_block_max = MIN_DETECTOR_LEVEL;  // Linear detector level max
  gr_db_block_max = 0;  // Track max absolute GR during block
  gr_processing_skipped = 0;  // Flag when GR calculation was skipped for optimization
  
  // Transient detection state (used in audio processing)
  transient_detector_prev_db = GRAPH_MIN_DB;
  transient_gr_reduction = 0;
  
  // Curve tracking variables
  attack_curve_prev = -999;
  release_curve_prev = -999;
  
  // RMS tracking variables
  rms_size_ms_prev = -999;
  
  // Threshold line interaction state (persistent across @init)
  !threshold_lines_initialized ? (
    threshold_lines_initialized = 1;
    // Default positions already set by sliders
  );
  
  // Initialize RMS samples calculation (must be done after srate is available)
  rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
  lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);

  // Histogram state
  histogram_buffer = 0; // Will be allocated in memory
  histogram_max_samples = 0; // Calculated based on window seconds
  histogram_pos = 0; // Current position in circular buffer
  histogram_initialized = 0; // Flag to track initialization
  histogram_frame_counter = 0; // Frame counter for update rate control

  // Initialize histogram if enabled
  HISTOGRAM_ENABLED ? (
    histogram_max_samples = ceil(HISTOGRAM_WINDOW_SECONDS * 60); // 60 Hz GFX rate
    histogram_buffer = freemem;
    freemem += histogram_max_samples;
    
    // Clear histogram buffer
    i = 0;
    while (i < histogram_max_samples) (
      histogram_buffer[i] = 0;
      i += 1;
    );
    
    histogram_pos = 0;
    histogram_initialized = 1;
  );
  
  // Per-pixel histogram buffer state (for histogram buffer mode)
  histogram_pixel_buffer = 0; // Will be allocated in memory
  histogram_pixel_samples_per_pixel = 0; // Calculated based on srate and graph width
  histogram_pixel_pos = 0; // Current sample position within current pixel
  histogram_pixel_idx = 0; // Current pixel index
  histogram_pixel_initialized = 0; // Flag to track initialization
  
  // Initialize per-pixel histogram buffer if enabled
  HISTOGRAM_ENABLED ? (
    // Allocate buffer for GRAPH_SIZE pixels (300 pixels)
    histogram_pixel_buffer = freemem;
    freemem += GRAPH_SIZE;
    
    // Clear per-pixel histogram buffer
    i = 0;
    while (i < GRAPH_SIZE) (
      histogram_pixel_buffer[i] = 0;  // Initialize to 0 (no GR)
      i += 1;
    );
    
    // Calculate samples per pixel for histogram window
    // HISTOGRAM_WINDOW_SECONDS worth of samples divided by GRAPH_SIZE pixels
    histogram_pixel_samples_per_pixel = ceil((HISTOGRAM_WINDOW_SECONDS * srate) / GRAPH_SIZE);
    histogram_pixel_pos = 0;
    histogram_pixel_idx = 0;
    histogram_pixel_initialized = 1;
  );

  // Input histogram state
  input_histogram_buffer = 0; // Will be allocated in memory
  input_histogram_max_samples = 0; // Calculated based on window seconds
  input_histogram_pos = 0; // Current position in circular buffer
  input_histogram_initialized = 0; // Flag to track initialization
  input_histogram_frame_counter = 0; // Frame counter for update rate control
  input_histogram_prev_level = 0; // Previous level value for smoothing

  // Initialize input histogram if enabled
  INPUT_HISTOGRAM_ENABLED ? (
    input_histogram_max_samples = ceil(HISTOGRAM_WINDOW_SECONDS * 60); // 60 Hz GFX rate, same as GR histogram
    input_histogram_buffer = freemem;
    freemem += input_histogram_max_samples;
    
    // Clear input histogram buffer
    i = 0;
    while (i < input_histogram_max_samples) (
      input_histogram_buffer[i] = GRAPH_MIN_DB;  // Initialize to minimum dB
      i += 1;
    );
    
    input_histogram_pos = 0;
    input_histogram_initialized = 1;
  );

  // Per-pixel input histogram buffer state (for histogram buffer mode)
  input_histogram_pixel_buffer = 0; // Will be allocated in memory
  input_histogram_pixel_samples_per_pixel = 0; // Calculated based on srate and graph width
  input_histogram_pixel_pos = 0; // Current sample position within current pixel
  input_histogram_pixel_idx = 0; // Current pixel index
  input_histogram_pixel_initialized = 0; // Flag to track initialization

  // Initialize per-pixel input histogram buffer if enabled
  INPUT_HISTOGRAM_ENABLED ? (
    // Allocate buffer for GRAPH_SIZE pixels (300 pixels)
    input_histogram_pixel_buffer = freemem;
    freemem += GRAPH_SIZE;
    
    // Clear per-pixel input histogram buffer
    i = 0;
    while (i < GRAPH_SIZE) (
      input_histogram_pixel_buffer[i] = GRAPH_MIN_DB;  // Initialize to minimum dB
      i += 1;
    );
    
    // Calculate samples per pixel for histogram window
    // HISTOGRAM_WINDOW_SECONDS worth of samples divided by GRAPH_SIZE pixels
    input_histogram_pixel_samples_per_pixel = ceil((HISTOGRAM_WINDOW_SECONDS * srate) / GRAPH_SIZE);
    input_histogram_pixel_pos = 0;
    input_histogram_pixel_idx = 0;
    input_histogram_pixel_initialized = 1;
  );

  // Menu toggle states (persistent across @init)
  !menu_toggles_initialized ? (
    menu_toggles_initialized = 1;
    menu_debug_enabled = 1;  // Default to enabled
    menu_histogram_enabled = 1;  // Default to enabled
    menu_gr_meter_enabled = 1;   // Default to enabled
    menu_brickwall_limiter_enabled = 1;  // Default to enabled
    menu_true_rms_enabled = 0;  // Default to exponential smoothing (off)
    menu_histogram_buffer_mode = 1;  // Default to per-pixel buffer mode (on)
  );

  // Custom menu state
  menu_visible = 0;
  menu_hovered_item = -1;
  
  // Debug performance counters - individual functions (always active during development)
  // Audio processing functions
  debug_counter_audio_chain = 0;              // process_complete_audio_chain()
  debug_counter_gain_reduction = 0;           // calculate_gain_reduction()
  debug_counter_envelope = 0;                 // process_envelope_following()
  debug_counter_min_envelope = 0;             // process_min_envelope()
  debug_counter_lookahead = 0;                // process_lookahead_audio()
  debug_counter_harmonics = 0;                // apply_harmonic_processing()
  debug_counter_limiter = 0;                  // soft_clip_limiter()
  debug_counter_curve_interp = 0;             // interpolate_compression_curve()
  debug_counter_lut_lookup = 0;               // lookup_compression_lut()
  
  // Math conversion functions
  debug_counter_db_to_linear = 0;             // db_to_linear()
  debug_counter_linear_to_db = 0;             // linear_to_db()
  debug_counter_clamp = 0;                    // clamp()
  
  // Program-dependent release functions
  debug_counter_prog_release = 0;             // select_program_release_coef()
  debug_counter_single_envelope = 0;          // process_single_stage_envelope()
  
  // UI functions
  debug_counter_ui_curves = 0;                // draw_mixed_curves()
  debug_counter_ui_histogram = 0;             // update_histogram_state()
  debug_counter_graph_bg = 0;                 // draw_graph_background()
  debug_counter_grid = 0;                     // draw_grid()
  
  // Display values (updated every second with call rates)
  // Audio processing functions
  debug_display_audio_chain = 0;
  debug_display_gain_reduction = 0;
  debug_display_envelope = 0;
  debug_display_min_envelope = 0;
  debug_display_lookahead = 0;
  debug_display_harmonics = 0;
  debug_display_limiter = 0;
  debug_display_curve_interp = 0;
  debug_display_lut_lookup = 0;
  
  // Math conversion functions
  debug_display_db_to_linear = 0;
  debug_display_linear_to_db = 0;
  debug_display_clamp = 0;
  
  // Program-dependent release functions
  debug_display_prog_release = 0;
  debug_display_single_envelope = 0;
  
  // UI functions
  debug_display_ui_curves = 0;
  debug_display_ui_histogram = 0;
  debug_display_graph_bg = 0;
  debug_display_grid = 0;
  
  // Reset time for counters (reset every second for readable rates)
  debug_counter_reset_interval = srate;
  debug_counter_samples = 0;
  
  // Dot trail state
  trail_buffer = 0; // Will be allocated in memory
  // trail_max_dots is set in allocate_memory() and should not be reset here
  trail_count = 0; // Current number of active trail dots
  trail_write_pos = 0; // Position in circular buffer
  trail_last_creation_time = 0; // Last time a trail dot was created (in samples)
  trail_initialized = 0; // Flag to track initialization
  trail_interval_ms_prev = -1; // Previous trail interval for change detection
  trail_fade_duration_ms_prev = -1; // Previous trail fade duration for change detection
  
  // Initialize trail buffer if enabled
  trail_max_dots > 0 ? (
    // Clear trail buffer
    i = 0;
    while (i < trail_max_dots * 4) (
      trail_buffer[i] = 0;
      i += 1;
    );
    
    trail_count = 0;
    trail_write_pos = 0;
    trail_last_creation_time = 0;
    trail_initialized = 1;
  ) : (
    trail_initialized = 0;
  );
);

//==============================================================================
// HISTOGRAM FUNCTIONS
//==============================================================================

function update_histogram_state(gr_value) (
  // Early exit optimization: Skip histogram updates when GR processing was skipped
  gr_processing_skipped ? (
    // GR processing was skipped - no need to update histogram
    // This saves CPU when signal is below compression threshold
    0  // Return 0 (no-op)
  ) : (
    menu_histogram_buffer_mode > 0.5 ? (
      // PER-PIXEL BUFFER MODE: Accumulate max GR per pixel for scalability
      // Each pixel accumulates the max absolute GR value across multiple samples
      histogram_pixel_initialized ? (
        // Accumulate max GR for current pixel (using absolute value for comparison)
        abs(gr_value) > abs(histogram_pixel_buffer[histogram_pixel_idx]) ? (
          histogram_pixel_buffer[histogram_pixel_idx] = gr_value;
        );
        
        // Advance sample counter
        histogram_pixel_pos += 1;
        
        // When we've accumulated enough samples for this pixel, move to next
        histogram_pixel_pos >= histogram_pixel_samples_per_pixel ? (
          histogram_pixel_pos = 0;
          histogram_pixel_idx = (histogram_pixel_idx + 1) % GRAPH_SIZE;
          // Reset next pixel's accumulator
          histogram_pixel_buffer[histogram_pixel_idx] = 0;
        );
      );
    ) : (
      // ORIGINAL MODE: Store block-level max GR value in circular buffer with rate control
      // Note: smoothing removed - block-level max already provides smooth values
      histogram_initialized ? (
        // Frame rate control - only update every N frames
        histogram_frame_counter += 1;
        (histogram_frame_counter >= HISTOGRAM_UPDATE_RATE) ? (
          histogram_frame_counter = 0;
          
          // Optimization: only increment debug counter when actual GR occurs
          abs(gr_value) > 0.0001 ? (
            debug_counter_ui_histogram += 1;
          );
          
          // Store block-level max directly (no smoothing needed)
          histogram_buffer[histogram_pos] = gr_value;
          
          // Always advance buffer position to keep histogram rolling
          histogram_pos = (histogram_pos + 1) % histogram_max_samples;
        );
      );
    );
  );
);

function update_input_histogram_state(input_level_db) (
  // Store current input level in dB (post-filter, post-RMS) with rate control and smoothing
  input_histogram_initialized ? (
    menu_histogram_buffer_mode > 0.5 ? (
      // PER-PIXEL BUFFER MODE: Accumulate max input level per pixel for scalability
      // Each pixel accumulates the max input level across multiple samples
      input_histogram_pixel_initialized ? (
        // Accumulate max input level for current pixel
        input_level_db > input_histogram_pixel_buffer[input_histogram_pixel_idx] ? (
          input_histogram_pixel_buffer[input_histogram_pixel_idx] = input_level_db;
        );
        
        // Advance sample counter
        input_histogram_pixel_pos += 1;
        
        // When we've accumulated enough samples for this pixel, move to next
        input_histogram_pixel_pos >= input_histogram_pixel_samples_per_pixel ? (
          input_histogram_pixel_pos = 0;
          input_histogram_pixel_idx = (input_histogram_pixel_idx + 1) % GRAPH_SIZE;
          // Reset next pixel's accumulator to minimum
          input_histogram_pixel_buffer[input_histogram_pixel_idx] = GRAPH_MIN_DB;
        );
      );
    ) : (
      // CIRCULAR BUFFER MODE: Store input level in circular buffer with rate control and smoothing
      // Frame rate control - only update every N frames
      input_histogram_frame_counter += 1;
      (input_histogram_frame_counter >= HISTOGRAM_UPDATE_RATE) ? (
        input_histogram_frame_counter = 0;
        
        // Apply smoothing if enabled
        smoothed_level = HISTOGRAM_SMOOTHING ? (
          // Simple exponential smoothing: 70% new value, 30% previous
          0.7 * input_level_db + 0.3 * input_histogram_prev_level
        ) : (
          input_level_db
        );
        
        input_histogram_buffer[input_histogram_pos] = smoothed_level;
        input_histogram_pos = (input_histogram_pos + 1) % input_histogram_max_samples;
        input_histogram_prev_level = smoothed_level;
      );
    );
  );
);

//==============================================================================
// LARGE KNOB ACCESSOR FUNCTIONS
//==============================================================================


function set_large_knob_value(index, value) (
  large_knob_defs[index*8 + 7] = value;
);
