// User Interactions - Controls Module
// UI controls interaction handling
// Dependencies: 01_Utils/02_math_utils.jsfx-inc, UI_General/02_ui_utils.jsfx-inc, UI_Sliders/00_slider_constants.jsfx-inc, UI_Sliders/01_control_definitions.jsfx-inc

@init

//==============================================================================
// INTERACTION STATE
//==============================================================================

// Control States
ui_drag_control = -1;  // -1 = no control, -2 = clicked but not draggable, >= 0 = dragging control index

// Mouse position tracking for delta calculations
ui_prev_mouse_x = 0;
ui_prev_mouse_y = 0;

// Fine drag accumulator for discrete sliders
ui_fine_drag_accum = 0;

// Double-click detection
ui_last_click_time = 0;
ui_last_clicked_control = -1;
ui_double_click_threshold = 0.3; // 300ms for double click


//==============================================================================
// HELPER FUNCTIONS
//==============================================================================

// Update PDC delay for lookahead slider (param_index 11 = lookahead_ms)
function update_pdc_delay_if_needed(param_index) (
  param_index == 11 ? (
    pdc_delay = min(lookahead_ms * 0.001 * srate, max_lookahead_samples) | 0;
    pdc_delay > 0 ? (
      pdc_bot_ch = 0;
      pdc_top_ch = 2;
    );
  );
);

//==============================================================================
// HELPER FUNCTIONS
//==============================================================================

// Reset control to default value
function reset_control_to_default(control_index) (
  param_index = control_defs[control_index*11 + 5];
  control_type = control_defs[control_index*11 + 0];
  
  // Get default value from stored slider parameters (read from file)
  default_val = get_slider_default(param_index);
  slider(param_index) = default_val;
  
  sliderchange(1 << (param_index - 1));
  update_pdc_delay_if_needed(param_index);
);

// Check if this is a double-click
function is_double_click_control(control_index) local(current_time, is_double) (
  current_time = time_precise();
  is_double = (control_index == ui_last_clicked_control && 
               (current_time - ui_last_click_time) < ui_double_click_threshold);
  ui_last_clicked_control = control_index;
  ui_last_click_time = current_time;
  is_double;
);

// Handle control click based on control type
function handle_control_click(control_index) (
  control_type = control_defs[control_index*11 + 0];
  param_index = control_defs[control_index*11 + 5];
  current_value = slider(param_index);
  
  // Debug logging removed per user request
  
  // Check for double-click or alt-click to reset (but not for dropdowns or buttons)
  (is_double_click_control(control_index) || MOUSE_ALT_KEY) && control_type != 2 && control_type != 1 ? (
    reset_control_to_default(control_index);
    ui_drag_control = -2; // Prevent drag
  ) : (
    // Normal click behavior
    control_type == 0 ? (
      // Slider - start drag (handles both continuous and enumerated sliders)
      ui_drag_control = control_index;
      slider(param_index) = update_slider_value(control_index, mouse_x, mouse_y);
      sliderchange(1 << (param_index - 1));
      update_pdc_delay_if_needed(param_index);
    ) : control_type == 1 ? (
      // Button - toggle (don't start drag for buttons)
      slider(param_index) = current_value > 0.5 ? 0 : 1;
      sliderchange(1 << (param_index - 1));
      ui_drag_control = -2; // Special value to prevent further checks
    ) : control_type == 2 ? (
      // Dropdown - cycle (don't start drag for dropdowns)
      max_options = get_dropdown_option_count(param_index);
      max_options > 0 ? (
        slider(param_index) = (current_value + 1) % max_options;
        sliderchange(1 << (param_index - 1));
      );
      ui_drag_control = -2; // Special value to prevent further checks
    );
  );
);

// Handle drag continuation for different control types
function handle_drag_continuation() local(fine_drag_mult, slider_config, slider_style, format_options, snapped_value) (
  // Apply fine drag multiplier when ctrl/cmd is held
  fine_drag_mult = MOUSE_CTRL_KEY ? 0.2 : 1.0;
  
  ui_drag_control >= 0 ? (
    // Update dragged control
    param_index = control_defs[ui_drag_control*11 + 5];
    control_type = control_defs[ui_drag_control*11 + 0];

    control_type == 0 ? ( // Slider - unified system
      slider_config = control_defs[ui_drag_control*11 + 8];
      slider_style = slider_config & 0xFF;
      format_options = (slider_config >> 32) & 0xFF;

      min_val = control_defs[ui_drag_control*11 + 6];
      max_val = control_defs[ui_drag_control*11 + 7];
      current_value = slider(param_index);
      
      // Check if this slider has enumerated options or step-points
      option_count = get_dropdown_option_count(param_index);
      step_count = get_step_point_count(param_index);
      
      (option_count > 0 || step_count > 0) ? (
        // Stepped slider (enumerated or step-points): divide slider width by number of options
        // Each option gets (slider_width / option_count) pixels
        total_options = option_count > 0 ? option_count : step_count;
        slider_w = control_defs[ui_drag_control*11 + 3];
        pixels_per_option = slider_w / total_options;
        
        // Get mouse position relative to slider
        group_idx = control_defs[ui_drag_control*11 + 10];
        ctrl_x_rel = control_defs[ui_drag_control*11 + 1];
        group_idx >= 0 ? (
          ctrl_x = ctrl_x_rel + group_defs[group_idx*6 + 0];
        ) : (
          ctrl_x = ctrl_x_rel;
        );
        
        mouse_pos_in_slider = mouse_x - ctrl_x;
        option_index = floor(mouse_pos_in_slider / pixels_per_option);
        option_index = max(0, min(total_options - 1, option_index));
        
        // Set slider value based on type
        option_count > 0 ? (
          // Enumerated slider: value is the index
          slider(param_index) = option_index;
        ) : (
          // Step-point slider: value is the step-point value at that index
          step_points_base = get_step_points_base(param_index);
          slider(param_index) = step_points_base[option_index];
        );
      ) : (
        // Continuous slider - check if this slider supports bidirectional drag
        format_options & OPTION_BIDIRECTIONAL ? (
          // Bidirectional drag - use both X and Y movement
          mouse_dx = (mouse_x - ui_prev_mouse_x) * fine_drag_mult;
          mouse_dy = (mouse_y - ui_prev_mouse_y) * fine_drag_mult;
          
          // Combine X and Y movement for bidirectional interaction
          mouse_delta = mouse_dx - mouse_dy; // Y movement is inverted for intuitive behavior
          
          slider_w = control_defs[ui_drag_control*11 + 3];
          value_range = max_val - min_val;
          delta = (mouse_delta / slider_w) * value_range;
          new_value = clamp(current_value + delta, min_val, max_val);
          // Check if this slider has step-points and snap if so
          step_count = get_step_point_count(param_index);
          step_count > 0 ? (
            step_points_base = get_step_points_base(param_index);
            snapped_value = find_closest_step_point(new_value, step_points_base, step_count);
            slider(param_index) = snapped_value;
          ) : (
            slider(param_index) = new_value;
          );
        ) : (
          // Continuous slider - use position-based or delta-based depending on fine mode
          MOUSE_CTRL_KEY ? (
            // Fine drag mode - use delta approach
            mouse_dx = (mouse_x - ui_prev_mouse_x) * fine_drag_mult;
            slider_w = control_defs[ui_drag_control*11 + 3];
            value_range = max_val - min_val;
            delta = (mouse_dx / slider_w) * value_range;
            new_value = clamp(current_value + delta, min_val, max_val);
            // Check if this slider has step-points and snap if so
            step_count = get_step_point_count(param_index);
            step_count > 0 ? (
              step_points_base = get_step_points_base(param_index);
              snapped_value = find_closest_step_point(new_value, step_points_base, step_count);
              slider(param_index) = snapped_value;
            ) : (
              slider(param_index) = new_value;
            );
          ) : (
            // Normal drag mode - use position
            new_value = update_slider_value(ui_drag_control, mouse_x, mouse_y);
            // Check if this slider has step-points and snap if so
            step_count = get_step_point_count(param_index);
            step_count > 0 ? (
              step_points_base = get_step_points_base(param_index);
              snapped_value = find_closest_step_point(new_value, step_points_base, step_count);
              slider(param_index) = snapped_value;
            ) : (
              slider(param_index) = new_value;
            );
          );
        );
      );
      
      sliderchange(1 << (param_index - 1));
      update_pdc_delay_if_needed(param_index);
    ) : (
      // Other control types - no drag handling needed
      0; // Empty statement to satisfy JSFX syntax
    );
  ) : (
    // No drag operation in progress - no action needed
    0; // Empty statement to satisfy JSFX syntax
  );
);

//==============================================================================
// UI CONTROL MOUSE INPUT
//==============================================================================

function handle_ui_mouse_input() (
  MOUSE_LEFT_BUTTON ? (
    ui_drag_control == -1 ? ( // Start of click - no control selected yet
      // Initialize previous mouse position on first click
      ui_prev_mouse_x = mouse_x;
      ui_prev_mouse_y = mouse_y;
      ui_fine_drag_accum = 0; // Reset accumulator
      
      is_menu_button_clicked() ? (
          handle_menu_button_click();
          ui_drag_control = -2; // Special value to prevent further checks
        ) : menu_visible ? (
          // Check menu items if menu is visible
          hovered_item = get_hovered_menu_item();
          hovered_item >= 0 ? (
            handle_menu_item_click(hovered_item);
            ui_drag_control = -2; // Special value to prevent further checks
          ) : (
            // Clicked outside menu - close it
            menu_visible = 0;
            menu_hovered_item = -1;
          );
        ) : (
        // Check controls until we find one under the mouse
        i = 0;
        while (i < NUM_CONTROLS && ui_drag_control == -1) (
          is_point_in_control(mouse_x, mouse_y, i) ? (
            handle_control_click(i);
          );
          i += 1;
        );
      );
    ) : ( // Continue drag
      handle_drag_continuation();
    );
  ) : (
    // Mouse released - reset drag state
    ui_drag_control = -1;
    ui_fine_drag_accum = 0; // Reset accumulator
  );
  
  // Update previous mouse position for next frame's delta calculation
  ui_prev_mouse_x = mouse_x;
  ui_prev_mouse_y = mouse_y;
);

