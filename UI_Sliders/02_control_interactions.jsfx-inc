// User Interactions - Controls Module
// UI controls interaction handling
// Dependencies: 01_Utils/02_math_utils.jsfx-inc, UI_General/02_ui_utils.jsfx-inc, UI_Sliders/00_slider_constants.jsfx-inc, UI_Sliders/01_control_definitions.jsfx-inc

@init

//==============================================================================
// INTERACTION STATE
//==============================================================================

// Control States
ui_drag_control = -1;  // -1 = no control, -2 = clicked but not draggable, >= 0 = dragging control index

// Preview Filters: Track initial state of Listen to Detection when dragging HP/LP filters
preview_filters_listen_initial_state = -1;  // -1 = not tracking, 0 = was off, 1 = was on

// Mouse position tracking for delta calculations
ui_prev_mouse_x = 0;
ui_prev_mouse_y = 0;

// Fine drag accumulator for discrete sliders
ui_fine_drag_accum = 0;

// Double-click detection
ui_last_click_time = 0;
ui_last_clicked_control = -1;
ui_double_click_threshold = 0.3; // 300ms for double click

// CTRL key state tracking for snap-on-release behavior
ui_prev_ctrl_key = 0;  // Previous frame's CTRL key state


//==============================================================================
// HELPER FUNCTIONS
//==============================================================================

// Update PDC delay for lookahead slider (param_index 11 = lookahead_ms)
function update_pdc_delay_if_needed(param_index) (
  param_index == 11 ? (
    pdc_delay = min(lookahead_ms * 0.001 * srate, max_lookahead_samples) | 0;
    pdc_delay > 0 ? (
      pdc_bot_ch = 0;
      pdc_top_ch = 2;
    );
  );
);

// Preview Filters: Auto-enable Listen when adjusting HP/LP filters
function handle_preview_filters(param_index, is_drag_start) (
  // If Preview Filters is enabled and adjusting HP or LP filter
  menu_preview_filters_enabled > 0.5 && (param_index == 17 || param_index == 18) ? (
    is_drag_start ? (
      // Drag start: Save initial state of Listen to Detection
      preview_filters_listen_initial_state = slider(16) > 0.5 ? 1 : 0;
      
      // If it was off, enable it temporarily
      preview_filters_listen_initial_state < 0.5 ? (
        listen_to_sidechain = 1;
        slider(16) = 1;
        sliderchange(1 << (16 - 1));
      );
    ) : (
      // During drag: Keep it enabled if it was off initially
      preview_filters_listen_initial_state < 0.5 ? (
        listen_to_sidechain = 1;
        slider(16) = 1;
        sliderchange(1 << (16 - 1));
      );
    );
  );
);

// Preview Filters: Restore Listen state on drag end
function handle_preview_filters_drag_end() (
  // If we were tracking and Listen was off initially, restore it to off
  preview_filters_listen_initial_state >= 0 && preview_filters_listen_initial_state < 0.5 ? (
    listen_to_sidechain = 0;
    slider(16) = 0;
    sliderchange(1 << (16 - 1));
  );
  // Reset tracking state
  preview_filters_listen_initial_state = -1;
);

//==============================================================================
// HELPER FUNCTIONS
//==============================================================================

// Reset control to default value
function reset_control_to_default(control_index) (
  param_index = control_defs[control_index*11 + 5];
  control_type = control_defs[control_index*11 + 0];
  
  // Get default value from stored slider parameters (read from file)
  default_val = get_slider_default(param_index);
  slider(param_index) = default_val;
  
  sliderchange(1 << (param_index - 1));
  update_pdc_delay_if_needed(param_index);
);

// Check if this is a double-click
function is_double_click_control(control_index) local(current_time, is_double) (
  current_time = time_precise();
  is_double = (control_index == ui_last_clicked_control && 
               (current_time - ui_last_click_time) < ui_double_click_threshold);
  ui_last_clicked_control = control_index;
  ui_last_click_time = current_time;
  is_double;
);

// Handle control click based on control type
function handle_control_click(control_index) local(option_count, step_count, min_val, max_val, normalized_pos, ctrl_x, ctrl_y, ctrl_w, ctrl_h, group_idx, ctrl_x_rel, group_x_val, slider_config, slider_orientation, format_options, raw_value, increment, array_index) (
  control_type = control_defs[control_index*11 + 0];
  param_index = control_defs[control_index*11 + 5];
  current_value = slider(param_index);
  
  // Debug logging removed per user request
  
  // Check for double-click or alt-click to reset (but not for dropdowns or buttons)
  (is_double_click_control(control_index) || MOUSE_ALT_KEY) && control_type != 2 && control_type != 1 ? (
    reset_control_to_default(control_index);
    ui_drag_control = -2; // Prevent drag
  ) : (
    // Normal click behavior
    (control_type == 0 || control_type == 3) ? ( // Slider or Parallax Fader
      // Slider - start drag (handles both continuous and enumerated sliders)
      ui_drag_control = control_index;
      
      // Check if CTRL is held - if so, don't snap stepped sliders on initial click
      MOUSE_CTRL_KEY ? (
        // CTRL held: for stepped sliders, use smooth position-based value (no snapping)
        option_count = get_dropdown_option_count(param_index);
        step_count = get_step_point_count(param_index);
        (option_count > 0 || step_count > 0) ? (
          // Stepped slider with CTRL: calculate smooth value from mouse position
          control_type == 3 ? (
            // Parallax fader: get config from separate array
            slider_config = parallax_slider_configs[control_index];
            format_options = (slider_config >> 8) & 0xFF;
            slider_orientation = ORIENTATION_HORIZONTAL; // Parallax faders are always horizontal
          ) : (
            // Regular slider: get config from control_defs
            slider_config = control_defs[control_index*11 + 8];
            slider_orientation = slider_config & 0xFF;
            format_options = (slider_config >> 32) & 0xFF;
          );
          min_val = control_defs[control_index*11 + 6];
          max_val = control_defs[control_index*11 + 7];
          
          group_idx = control_defs[control_index*11 + 10];
          slider_orientation == ORIENTATION_VERTICAL ? (
            ctrl_y = control_defs[control_index*11 + 2];
            ctrl_h = control_defs[control_index*11 + 4];
            group_idx >= 0 ? (
              ctrl_y += group_defs[group_idx*6 + 1];
            );
            normalized_pos = (mouse_y - ctrl_y) / ctrl_h;
            normalized_pos = max(0, min(1, normalized_pos));
            normalized_pos = 1 - normalized_pos;
          ) : (
            ctrl_x_rel = control_defs[control_index*11 + 1];
            ctrl_w = control_defs[control_index*11 + 3];
            group_idx >= 0 ? (
              group_x_val = group_defs[group_idx*6 + 0];
              ctrl_x = ctrl_x_rel + group_x_val;
            ) : (
              ctrl_x = ctrl_x_rel;
            );
            normalized_pos = (mouse_x - ctrl_x) / ctrl_w;
            normalized_pos = max(0, min(1, normalized_pos));
            format_options & OPTION_REVERSE ? (
              normalized_pos = 1.0 - normalized_pos;
            );
          );
          // Calculate smooth value (no snapping)
          raw_value = min_val + normalized_pos * (max_val - min_val);
          slider(param_index) = raw_value;
        ) : (
          // Continuous slider with CTRL: calculate smooth value (no increment snapping)
          control_type == 3 ? (
            // Parallax fader: get config from separate array
            slider_config = parallax_slider_configs[control_index];
            format_options = (slider_config >> 8) & 0xFF;
            slider_orientation = ORIENTATION_HORIZONTAL; // Parallax faders are always horizontal
          ) : (
            // Regular slider: get config from control_defs
            slider_config = control_defs[control_index*11 + 8];
            slider_orientation = slider_config & 0xFF;
            format_options = (slider_config >> 32) & 0xFF;
          );
          min_val = control_defs[control_index*11 + 6];
          max_val = control_defs[control_index*11 + 7];
          
          group_idx = control_defs[control_index*11 + 10];
          slider_orientation == ORIENTATION_VERTICAL ? (
            ctrl_y = control_defs[control_index*11 + 2];
            ctrl_h = control_defs[control_index*11 + 4];
            group_idx >= 0 ? (
              ctrl_y += group_defs[group_idx*6 + 1];
            );
            normalized_pos = (mouse_y - ctrl_y) / ctrl_h;
            normalized_pos = max(0, min(1, normalized_pos));
            normalized_pos = 1 - normalized_pos;
          ) : (
            ctrl_x_rel = control_defs[control_index*11 + 1];
            ctrl_w = control_defs[control_index*11 + 3];
            group_idx >= 0 ? (
              group_x_val = group_defs[group_idx*6 + 0];
              ctrl_x = ctrl_x_rel + group_x_val;
            ) : (
              ctrl_x = ctrl_x_rel;
            );
            normalized_pos = (mouse_x - ctrl_x) / ctrl_w;
            normalized_pos = max(0, min(1, normalized_pos));
            format_options & OPTION_REVERSE ? (
              normalized_pos = 1.0 - normalized_pos;
            );
          );
          // Calculate smooth value (no increment snapping when CTRL is held)
          raw_value = min_val + normalized_pos * (max_val - min_val);
          slider(param_index) = raw_value;
        );
      ) : (
        // CTRL not held: use normal update (with snapping for stepped sliders)
        slider(param_index) = update_slider_value(control_index, mouse_x, mouse_y);
      );
      sliderchange(1 << (param_index - 1));
      update_pdc_delay_if_needed(param_index);
      handle_preview_filters(param_index, 1);  // is_drag_start = 1
    ) : control_type == 1 ? (
      // Button - toggle (don't start drag for buttons)
      slider(param_index) = current_value > 0.5 ? 0 : 1;
      sliderchange(1 << (param_index - 1));
      ui_drag_control = -2; // Special value to prevent further checks
    ) : control_type == 2 ? (
      // Dropdown - cycle (don't start drag for dropdowns)
      max_options = get_dropdown_option_count(param_index);
      max_options > 0 ? (
        slider(param_index) = (current_value + 1) % max_options;
        sliderchange(1 << (param_index - 1));
      );
      ui_drag_control = -2; // Special value to prevent further checks
    );
  );
);

// Handle drag continuation for different control types
function handle_drag_continuation() local(fine_drag_mult, slider_config, slider_style, format_options, snapped_value, ctrl_just_released, increment) (
  // Apply fine drag multiplier when ctrl/cmd is held
  fine_drag_mult = MOUSE_CTRL_KEY ? 0.2 : 1.0;
  
  // Detect CTRL key release (was held, now not held)
  ctrl_just_released = ui_prev_ctrl_key && !MOUSE_CTRL_KEY;
  
  ui_drag_control >= 0 ? (
    // Update dragged control
    param_index = control_defs[ui_drag_control*11 + 5];
    control_type = control_defs[ui_drag_control*11 + 0];

    (control_type == 0 || control_type == 3) ? ( // Slider or Parallax Fader - unified system
      control_type == 3 ? (
        // Parallax fader: get config from separate array
        slider_config = parallax_slider_configs[ui_drag_control];
        format_options = (slider_config >> 8) & 0xFF;
        slider_orientation = ORIENTATION_HORIZONTAL; // Parallax faders are always horizontal
      ) : (
        // Regular slider: get config from control_defs
        slider_config = control_defs[ui_drag_control*11 + 8];
        slider_orientation = slider_config & 0xFF;
        format_options = (slider_config >> 32) & 0xFF;
      );

      min_val = control_defs[ui_drag_control*11 + 6];
      max_val = control_defs[ui_drag_control*11 + 7];
      current_value = slider(param_index);
      
      // Check if this slider has enumerated options or step-points
      option_count = get_dropdown_option_count(param_index);
      step_count = get_step_point_count(param_index);
      
      (option_count > 0 || step_count > 0) ? (
        // Stepped slider (enumerated or step-points)
        MOUSE_CTRL_KEY ? (
          // CTRL held: allow smooth adjustment (ignore stepping) - use position-based calculation
          control_type == 3 ? (
            // Parallax fader: get config from separate array
            slider_config = parallax_slider_configs[ui_drag_control];
            format_options = (slider_config >> 8) & 0xFF;
            slider_orientation = ORIENTATION_HORIZONTAL; // Parallax faders are always horizontal
          ) : (
            // Regular slider: get config from control_defs
            slider_config = control_defs[ui_drag_control*11 + 8];
            slider_orientation = slider_config & 0xFF;
            format_options = (slider_config >> 32) & 0xFF;
          );
          
          group_idx = control_defs[ui_drag_control*11 + 10];
          slider_orientation == ORIENTATION_VERTICAL ? (
            ctrl_y = control_defs[ui_drag_control*11 + 2];
            ctrl_h = control_defs[ui_drag_control*11 + 4];
            group_idx >= 0 ? (
              ctrl_y += group_defs[group_idx*6 + 1];
            );
            normalized_pos = (mouse_y - ctrl_y) / ctrl_h;
            normalized_pos = max(0, min(1, normalized_pos));
            normalized_pos = 1 - normalized_pos;
          ) : (
            ctrl_x_rel = control_defs[ui_drag_control*11 + 1];
            ctrl_w = control_defs[ui_drag_control*11 + 3];
            group_idx >= 0 ? (
              ctrl_x = ctrl_x_rel + group_defs[group_idx*6 + 0];
            ) : (
              ctrl_x = ctrl_x_rel;
            );
            normalized_pos = (mouse_x - ctrl_x) / ctrl_w;
            normalized_pos = max(0, min(1, normalized_pos));
            format_options & OPTION_REVERSE ? (
              normalized_pos = 1.0 - normalized_pos;
            );
          );
          // Calculate smooth value directly from mouse position (no stepping)
          new_value = min_val + normalized_pos * (max_val - min_val);
          slider(param_index) = new_value;
        ) : (
          // CTRL not held: use stepped behavior
          // Stepped slider: divide slider width by number of options
          total_options = option_count > 0 ? option_count : step_count;
          slider_w = control_defs[ui_drag_control*11 + 3];
          pixels_per_option = slider_w / total_options;
          
          // Get mouse position relative to slider
          group_idx = control_defs[ui_drag_control*11 + 10];
          ctrl_x_rel = control_defs[ui_drag_control*11 + 1];
          group_idx >= 0 ? (
            ctrl_x = ctrl_x_rel + group_defs[group_idx*6 + 0];
          ) : (
            ctrl_x = ctrl_x_rel;
          );
          
          mouse_pos_in_slider = mouse_x - ctrl_x;
          option_index = floor(mouse_pos_in_slider / pixels_per_option);
          option_index = max(0, min(total_options - 1, option_index));
          
          // Set slider value based on type
          option_count > 0 ? (
            // Enumerated slider: value is the index
            slider(param_index) = option_index;
          ) : (
            // Step-point slider: value is the step-point value at that index
            step_points_base = get_step_points_base(param_index);
            slider(param_index) = step_points_base[option_index];
          );
        );
        
        // Snap to closest step when CTRL is released
        ctrl_just_released ? (
          // Get current slider value (may have been adjusted smoothly)
          current_slider_value = slider(param_index);
          step_count > 0 ? (
            // Step-point slider: snap to closest step-point
            step_points_base = get_step_points_base(param_index);
            snapped_value = find_closest_step_point(current_slider_value, step_points_base, step_count);
            slider(param_index) = snapped_value;
          ) : option_count > 0 ? (
            // Enumerated slider: snap to closest option index
            // Calculate which option is closest to current value
            total_options = option_count;
            closest_index = 0;
            closest_diff = abs(0 - current_slider_value);
            i = 1;
            while (i < total_options) (
              test_diff = abs(i - current_slider_value);
              test_diff < closest_diff ? (
                closest_index = i;
                closest_diff = test_diff;
              );
              i += 1;
            );
            slider(param_index) = closest_index;
          );
        );
      ) : (
        // Continuous slider - check if this slider supports bidirectional drag
        format_options & OPTION_BIDIRECTIONAL ? (
          // Bidirectional drag - use both X and Y movement
          mouse_dx = (mouse_x - ui_prev_mouse_x) * fine_drag_mult;
          mouse_dy = (mouse_y - ui_prev_mouse_y) * fine_drag_mult;
          
          // Combine X and Y movement for bidirectional interaction
          mouse_delta = mouse_dx - mouse_dy; // Y movement is inverted for intuitive behavior
          
          slider_w = control_defs[ui_drag_control*11 + 3];
          value_range = max_val - min_val;
          delta = (mouse_delta / slider_w) * value_range;
          new_value = clamp(current_value + delta, min_val, max_val);
          
          // Apply snapping based on CTRL state
          MOUSE_CTRL_KEY ? (
            // CTRL held: no snapping, allow smooth adjustment
            slider(param_index) = new_value;
          ) : (
            // CTRL not held: snap to increment if available
            array_index = ui_drag_control * 4 + 0;
            increment = (array_index >= 0 && array_index < NUM_CONTROLS * 4) ? slider_properties_base[array_index] : 0;
            increment > 0 ? (
              // Snap to nearest increment step
              snapped_value = floor(new_value / increment + 0.5) * increment;
              slider(param_index) = clamp(snapped_value, min_val, max_val);
            ) : (
              slider(param_index) = new_value;
            );
          );
          
          // Snap to increment when CTRL is released
          ctrl_just_released ? (
            // Get current slider value (may have been adjusted smoothly)
            current_slider_value = slider(param_index);
            array_index = ui_drag_control * 4 + 0;
            increment = (array_index >= 0 && array_index < NUM_CONTROLS * 4) ? slider_properties_base[array_index] : 0;
            increment > 0 ? (
              snapped_value = floor(current_slider_value / increment + 0.5) * increment;
              slider(param_index) = clamp(snapped_value, min_val, max_val);
            );
          );
        ) : (
          // Continuous slider - use position-based or delta-based depending on fine mode
          MOUSE_CTRL_KEY ? (
            // Fine drag mode - use delta approach (smooth, no snapping)
            mouse_dx = (mouse_x - ui_prev_mouse_x) * fine_drag_mult;
            slider_w = control_defs[ui_drag_control*11 + 3];
            value_range = max_val - min_val;
            delta = (mouse_dx / slider_w) * value_range;
            new_value = clamp(current_value + delta, min_val, max_val);
            slider(param_index) = new_value;
          ) : (
            // Normal drag mode - use position with snapping
            new_value = update_slider_value(ui_drag_control, mouse_x, mouse_y);
            slider(param_index) = new_value;
          );
          
          // Snap to increment when CTRL is released
          ctrl_just_released ? (
            // Get current slider value (may have been adjusted smoothly)
            current_slider_value = slider(param_index);
            array_index = ui_drag_control * 4 + 0;
            increment = (array_index >= 0 && array_index < NUM_CONTROLS * 4) ? slider_properties_base[array_index] : 0;
            increment > 0 ? (
              snapped_value = floor(current_slider_value / increment + 0.5) * increment;
              slider(param_index) = clamp(snapped_value, min_val, max_val);
            );
          );
        );
      );
      
      sliderchange(1 << (param_index - 1));
      update_pdc_delay_if_needed(param_index);
      handle_preview_filters(param_index, 0);  // is_drag_start = 0 (during drag)
    ) : (
      // Other control types - no drag handling needed
      0; // Empty statement to satisfy JSFX syntax
    );
  ) : (
    // No drag operation in progress - no action needed
    0; // Empty statement to satisfy JSFX syntax
  );
);

//==============================================================================
// UI CONTROL MOUSE INPUT
//==============================================================================

function handle_ui_mouse_input() (
  MOUSE_LEFT_BUTTON ? (
    ui_drag_control == -1 ? ( // Start of click - no control selected yet
      // Initialize previous mouse position on first click
      ui_prev_mouse_x = mouse_x;
      ui_prev_mouse_y = mouse_y;
      ui_fine_drag_accum = 0; // Reset accumulator
      
      is_menu_button_clicked() ? (
          handle_menu_button_click();
          ui_drag_control = -2; // Special value to prevent further checks
        ) : menu_visible ? (
          // Check menu items if menu is visible
          hovered_item = get_hovered_menu_item();
          hovered_item >= 0 ? (
            handle_menu_item_click(hovered_item);
            ui_drag_control = -2; // Special value to prevent further checks
          ) : (
            // Clicked outside menu - close it
            menu_visible = 0;
            menu_hovered_item = -1;
          );
        ) : (
        // Check controls until we find one under the mouse
        i = 0;
        while (i < control_count && ui_drag_control == -1) (
          // Control is visible, check if mouse is over it
          is_point_in_control(mouse_x, mouse_y, i) ? (
            handle_control_click(i);
          );
          i += 1;
        );
      );
    ) : ( // Continue drag
      handle_drag_continuation();
    );
  ) : (
    // Mouse released - reset drag state
    // Check if we need to restore Listen to Detection state
    handle_preview_filters_drag_end();
    ui_drag_control = -1;
    ui_fine_drag_accum = 0; // Reset accumulator
  );
  
  // Update previous mouse position for next frame's delta calculation
  ui_prev_mouse_x = mouse_x;
  ui_prev_mouse_y = mouse_y;
  
  // Update previous CTRL key state for next frame
  ui_prev_ctrl_key = MOUSE_CTRL_KEY;
);

