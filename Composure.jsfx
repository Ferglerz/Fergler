// Advanced Multi-Model Compressor JSFX - Modular Version
// Professional multi-algorithm compressor with interactive graph
// Features: multiple characters, feedforward/feedback, RMS normalization,
// program-dependent release, dedicated harmonic stage, soft-clipping limiter
// Author: Custom JSFX Generator
// Version: 3.0 - Advanced multi-model implementation (Modular)

desc:Advanced Multi-Model Compressor (Modular)


//==============================================================================
// SLIDER DEFINITIONS
//==============================================================================


// Time-related parameters (1-5)
// Attack: regular slider with step-points defined in UI (0.01ms to 5000ms)
// Default: 10ms
// Note: The slider variable is 'attack' (unit depends on time_multiplier), converted to 'attack_ms' (milliseconds) in @slider
slider1:attack=10<0.01,5000,0.01>Attack
slider2:attack_curve=0<-2,2,0.01>-Attack Curve
// Release: regular slider with step-points defined in UI (0.01ms to 5000ms)
// Default: 100ms
slider3:release_ms=100<0.01,5000,0.01>Release
slider4:release_curve=-2<-2,2,0.01>-Release Curve
slider5:lookahead_ms=0<0,2000,1>-Lookahead

// RMS & Detection parameters (6-9)
slider6:rms_size_ms=0<1,100,0.1>-RMS Window
slider7:rms_normalization=0<0,1,1{Off,On}>-RMS Normalization
slider8:detection_mode=1<0,1,1{Feedback,Feedforward}>-Detection Mode
slider9:max_gr_db=-100<-100,0,1>-Max GR

// Filtering parameters (10-11)
// Sliders use regular values with step-points defined in UI
// HP: 0=Off, then 20Hz to 6kHz - default 0 (Off)
// LP: 20Hz to 14kHz, then 0=Off - default 0 (Off)
slider10:hp_freq=0<0,6000,1>-HP Filter
slider11:lp_freq=0<0,14000,1>-LP Filter

// Character & Harmonics parameters (12-17)
slider12:harmonic_type=0<0,2,1{Off,Tape,Tube}>-Type
slider13:harmonic_amount=0<0,1,0.01>-Amount
slider14:harmonic_drive=50<0,100,1>-Drive (%)
slider15:harmonic_mix=0<0,100,1>-Mix
slider16:harmonic_even_boost=0<0,200,1>-Even
slider17:harmonic_odd_boost=0<0,200,1>-Odd

// Global parameters (18-24)
slider18:strength=100<0,400,5>-Strength
slider19:global_offset_db=0<-30,30,0.25>-Global Offset
slider20:makeup_gain_db=0<-20,20,0.1>-Makeup Gain
slider21:compressor_type=0<0,6,1{Clean Digital,Varimu,Bridged Diode,VCA,PWM/Fairchild,FET,Optical}>-Compressor Type
slider22:use_sidechain=0<0,1,1{No,Yes}>-Use Sidechain
slider23:listen_to_sidechain=0<0,1,1{No,Yes}>-Listen to Detection Signal
slider24:prog_release_type=0<0,3,1{Fixed Release,Input-Dependent,GR Dependent,Rate-of-Change}>-Program Release Type
slider25:brickwall_limiter=1<0,1,1{Off,On}>-Brickwall Limiter

// Advanced Envelope parameters (26-29)
slider26:gr_blend_threshold_db=6<1,24,0.1>-GR Blend Threshold (dB)
slider27:input_level_threshold_db=-20<-80,0,0.1>-Input Level Threshold (dB)
slider28:input_level_threshold_2_db=-40<-80,0,0.1>-Input Level Threshold 2 (dB)

// Dot Trail parameters (31-32)
slider31:trail_interval_ms=50<10,500,10>-Trail Interval (ms)
slider32:trail_fade_duration_ms=1000<100,5000,50>-Trail Fade Duration (ms)

// Time multiplier for attack display (33)
slider33:time_multiplier=1<0,1,1{Milliseconds,Microseconds}>-Time Unit

// Input dot blend (34)
slider34:input_dot_blend=100<0,100,1>-Input Dot Blend (%)

// Hold parameter (35)
slider35:hold_ms=0<0,1000,1>-Hold

// SEARCH STOP

//==============================================================================
// INCLUDE MODULES
//==============================================================================

// 01_Utils: Foundation utilities (no dependencies)
import 01_Utils/01_constants.jsfx-inc
import 01_Utils/02_math_utils.jsfx-inc
import 01_Utils/03_debug_logging.jsfx-inc

// UI_Sliders/00_file_reading: File reading (standalone, needed by 01_Utils/05_memory, 02_InputProcessing, and UI_General)
import UI_Sliders/00_file_reading.jsfx-inc

import 01_Utils/05_memory.jsfx-inc

// 02_InputProcessing: Input signal conditioning (depends on 01_Utils)
import 02_InputProcessing/01_dsp_utils.jsfx-inc
import 02_InputProcessing/02_filters.jsfx-inc

// 03_Compression: Core compression engine (depends on 01_Utils, 02_InputProcessing)
import 03_Compression/01_compression_constants.jsfx-inc
import 03_Compression/02_graph_data_core.jsfx-inc
import 03_Compression/03_graph_curves.jsfx-inc
import 03_Compression/05_compression_core.jsfx-inc
import 03_Compression/06_gain_reduction.jsfx-inc
import 03_Compression/07_envelope.jsfx-inc
import 03_Compression/08_harmonic_models.jsfx-inc
import 03_Compression/09_audio_processing_chain.jsfx-inc

// UI_General: General UI components (constants, utils, drawing, debug, header, menu)
// These are foundational and must be imported first
import UI_General/00_ui_constants.jsfx-inc
import UI_General/02_ui_utils.jsfx-inc
import UI_General/01_drawing_primitives.jsfx-inc
import UI_General/04_debug.jsfx-inc
import UI_General/10_menu.jsfx-inc
import UI_General/05_header.jsfx-inc
// Coordinate conversion service (independent, used by graph and meter)
import UI_General/12_coordinate_conversion.jsfx-inc
// Threshold lines service (independent, used by graph and meter)
import UI_General/11_threshold_lines.jsfx-inc

// UI_Sliders: Slider control library (depends on UI_General)
import UI_Sliders/00_slider_constants.jsfx-inc
import UI_Sliders/01a_value_formatting.jsfx-inc
import UI_Sliders/01b_value_text_rendering.jsfx-inc
import UI_Sliders/01c_slider_rendering.jsfx-inc
import UI_Sliders/01d_knob_rendering.jsfx-inc
import UI_Sliders/01e_button_rendering.jsfx-inc
import UI_Sliders/01f_dropdown_rendering.jsfx-inc
import UI_Sliders/01h_slider_objects.jsfx-inc
import UI_Sliders/01g_control_dispatcher.jsfx-inc
import UI_Sliders/01_control_definitions.jsfx-inc
import UI_Sliders/02_control_interactions.jsfx-inc

// Composure-specific control layout (uses Sliders library)
import UI_Controls/05_Composure_Controls.jsfx-inc

// UI_Graph: Graph rendering and interaction (depends on UI_General)
// threshold_lines is now in UI_General and independent
import UI_Graph/06_graph_cache.jsfx-inc
import UI_Graph/07_graph_curves.jsfx-inc
import UI_Graph/08_graph_meters.jsfx-inc
import UI_Graph/09_graph_display.jsfx-inc
import UI_Graph/12_dot_trail.jsfx-inc
import UI_Graph/03_graph.jsfx-inc

// 01_Utils/06_state: State initialization (depends on all modules above)
// Must be imported after all init functions are defined
import 01_Utils/06_state.jsfx-inc

// UI_General: UI orchestration (depends on UI_General, UI_Sliders, UI_Graph)
// These must be imported last as they orchestrate all UI components
import UI_General/13_ui_interaction.jsfx-inc
import UI_General/14_ui_orchestration.jsfx-inc


//==============================================================================
// SERIALIZE
//==============================================================================

@serialize
// Prevent memory/variables from being cleared on @init
ext_noinit = 1.0;

// Serialize graph points data for persistence across plugin duplication and project saves
// This ensures graph points and curves are preserved when:
// - Duplicating the plugin instance
// - Copying/pasting the track
// - Saving and reopening the project
// - Restarting REAPER
file_var(0, graph_initialized);
file_var(0, num_points);

// Save all graph points
i = 0;
while (i < num_points) (
  file_var(0, graph_points[i*2]);     // input_db
  file_var(0, graph_points[i*2 + 1]); // output_db
  i += 1;
);

// Save curve data
i = 0;
while (i < num_points) (
  file_var(0, curve_amounts[i]);
  i += 1;
);

//==============================================================================
// INITIALIZATION SEQUENCE
//==============================================================================

@init

// 1. Read slider definitions from file FIRST (needed for memory allocation)
read_slider_definitions("Composure.jsfx");

// 2. Initialize all constants, memory, and state variables
allocate_memory();
init_state_variables();

// 2.5. Initialize graph optimization constants (requires GRAPH_SIZE to be defined)
// Must be called after UI_General imports (specifically after 00_ui_constants.jsfx-inc)
init_graph_optimization_constants();


// Initialize limiter constants (must be called after math_utils import)
init_limiter_constants();

//==============================================================================
// PARAMETER UPDATE FUNCTIONS
//==============================================================================
// These functions calculate coefficients from slider values and can be called
// from both @init and @slider to ensure parameters are always correctly initialized

function update_attack_coefficient() (
  // Clamp attack time to valid range
  attack_raw = max(0.01, min(5000, attack));
  // Convert attack time from slider unit (microseconds/milliseconds) to final milliseconds
  attack_ms = convert_attack_time_to_ms(attack_raw, time_multiplier);
  // Update cached sample rate calculations
  attack_ms_srate = attack_ms * srate;
  
  // Calculate attack coefficient using standard time constant formula (63% of target)
  // Formula: exp(-1 / (time_ms * 0.001 * srate)) = exp(-1000 / (time_ms * srate))
  // After one time constant, envelope reaches 63.2% of the way from start to target
  attack_coeff_base = attack_ms > 0 ? exp(-1000 / (attack_ms * srate)) : 0;
  
  // Apply attack curve shaping
  attack_coeff = attack_coeff_base;
  attack_curve != 0 ? (
    attack_curve > 0 ? (
      // Positive curves (right): S-curve response - smooth, gradual onset
      curve_amount = attack_curve;
      s_curve_factor = 1.0 + curve_amount * 0.3; // Reduced from 0.6 to 0.3
      s_curve_factor *= (1.0 + curve_amount * 0.15); // Reduced from 0.3 to 0.15
      attack_coeff = pow(attack_coeff_base, s_curve_factor);
    ) : (
      // Negative curves (left): steep exponential response - fast, aggressive onset
      curve_amount = abs(attack_curve);
      attack_coeff = pow(attack_coeff_base, 1.0 - curve_amount * 0.3); // Reduced from 0.7 to 0.3
    );
  );
);

function update_release_coefficient() (
  // Clamp release time to valid range
  release_ms = max(0.01, min(5000, release_ms));
  // Update cached sample rate calculations
  release_ms_srate = release_ms * srate;
  
  // Calculate release coefficient using standard time constant formula
  release_coeff = release_ms > 0 ? exp(-1000 / (release_ms * srate)) : 0;
  
  // Cache program-dependent release coefficients (calculated when release_ms or srate changes)
  // These are used by program release modes and curve shaping functions
  rel_mult = 0.5 + (release_ms / 2000.0) * 1.5;
  rel_fast_cached = exp(-1/(base_fast_s * rel_mult * srate));
  rel_med_cached  = exp(-1/(base_med_s  * rel_mult * srate));
  rel_slow_cached = exp(-1/(base_slow_s * rel_mult * srate));
  
  // Cache curve shaping coefficients (only recalculate when release_ms or srate changes)
  // CURVE_FAST_MULTIPLIER and CURVE_SLOW_MULTIPLIER are defined in 07_envelope.jsfx-inc
  release_ms > 0 ? (
    curve_fast_coeff_cached = exp(-1000 / ((release_ms / CURVE_FAST_MULTIPLIER) * srate));
    curve_slow_coeff_cached = exp(-1000 / ((release_ms * CURVE_SLOW_MULTIPLIER) * srate));
    // Clamp to valid range [0, 1] once during caching
    curve_fast_coeff_cached = max(0, min(1, curve_fast_coeff_cached));
    curve_slow_coeff_cached = max(0, min(1, curve_slow_coeff_cached));
    
    // Cache input-dependent fast coefficient (4x faster than user's release setting)
    rel_input_fast_cached = exp(-1000 / ((release_ms * 0.25) * srate));
    rel_input_fast_cached = max(0, min(1, rel_input_fast_cached));
  ) : (
    curve_fast_coeff_cached = 0;
    curve_slow_coeff_cached = 0;
    rel_input_fast_cached = 0;
  );
);

function update_rms_coefficient() (
  // Clear RMS state if window size changed (check previous value before updating)
  (rms_size_ms_prev == -999 || rms_size_ms != rms_size_ms_prev) ? (
    rms_size_ms != rms_size_ms_prev ? (
      clear_rms_state();
    );
    rms_size_ms_prev = rms_size_ms;
  );
  
  // Calculate sample counts (for reference, not used in exponential smoothing)
  rms_samples = floor(rms_size_ms * 0.001 * srate);
  rms_samples < 1 ? rms_samples = 1;
  
  // Calculate RMS exponential smoothing coefficients
  // Always initialize coefficients (even when RMS is 0, to avoid undefined values)
  rms_size_ms > 0 ? (
    rms_smoothing_coeff = exp(-1000.0 / (rms_size_ms * srate));
    rms_smoothing_one_minus = 1 - rms_smoothing_coeff;
  ) : (
    // Initialize to safe defaults when RMS is disabled
    rms_smoothing_coeff = 0;
    rms_smoothing_one_minus = 1;
  );
);

function update_strength_multiplier() (
  // Convert Strength from percentage (0-400%) to multiplier (0.0-4.0)
  strength_multiplier = strength / 100.0;
);

// 4. Initialize curve data
init_curve_data();

// 5. Set up control layout
// Initialize slider objects (namespace-based) before layout uses them
init_slider_objects();
setup_control_layout();

// 6. Initialize graph points (only on first load)
!graph_initialized ? (
  // Initialize with defaults (ext_noinit preserves values across reloads)
  num_points = 6;
  init_graph_points();
  invalidate_compression_threshold(); // Mark threshold for recalculation
  graph_initialized = 1;
) : (
  // If graph was already initialized (loaded from preset), update corner points
  // to ensure they follow the tangent of the loaded user points
  update_corner_points();
);

// 7. Cache frequently used time calculations (sample rate dependent)
srate_inv = 1.0 / srate;
hold_samples = clamp(floor(hold_ms * 0.001 * srate), 0, 44100);  // Max 1 second at 44.1kHz
lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);

// 8. Update all parameter coefficients using dedicated update functions
// This ensures coefficients are correctly initialized even after samplerate changes
update_filter_coefficients();
update_attack_coefficient();
update_release_coefficient();
update_rms_coefficient();
update_strength_multiplier();

// 9. Mark compression system as ready (prevents LUT race condition)
compression_init_complete = 1;

//==============================================================================
// ON SLIDER UPDATES
//==============================================================================

@slider

// --- Filter Parameters (10-11) ---
// Sliders use enumerated indices - get actual frequency value from option
// hp_freq: index 0 = Off, other indices = filter frequency
// lp_freq: index 31 = Off, other indices = filter frequency
// Update filter coefficients (runs every @slider execution)
update_filter_coefficients();

// --- Timing Parameters (1-5) ---
// Update cached sample rate calculations
srate_inv = 1.0 / srate;
hold_samples = clamp(floor(hold_ms * 0.001 * srate), 0, 44100);  // Max 1 second at 44.1kHz
lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);

// Update attack and release coefficients using dedicated functions
update_attack_coefficient();
update_release_coefficient();

// Update RMS coefficients using dedicated function
update_rms_coefficient();

// --- Hold Parameter (35) ---
// Already handled above in timing parameters section

// --- Makeup Gain (21) ---
makeup_gain_linear = db_to_linear(makeup_gain_db);

// --- Harmonic Drive (14) ---
// Cache harmonic drive compensation reciprocal to avoid per-sample division
drive_compensation_inv = 1.0 / max(harmonic_drive, 1);


// --- Plugin Delay Compensation ---
// Cockos pattern: Calculate and set unconditionally every @slider execution
// This MUST run every time @slider executes (not just on change)
// Use cached lookahead_samples instead of recalculating
pdc_delay = min(lookahead_samples, max_lookahead_samples) | 0;
pdc_delay > 0 ? (
  pdc_bot_ch = 0;
  pdc_top_ch = 2;  // Stereo channels (0=left, 1=right)
);

// --- Strength and Global Offset parameters ---
// Update strength multiplier using dedicated function
update_strength_multiplier();

// Note: Strength is now used directly in gain reduction calculation
// Global offset is applied at lookup time (shifts input level before curve lookup).

// --- Trail Parameters (31-32) ---
// Recalculate trail buffer size
trail_interval_samples = trail_interval_ms * 0.001 * srate;
trail_fade_samples = trail_fade_duration_ms * 0.001 * srate;
new_trail_max_dots = ceil(trail_fade_samples / trail_interval_samples) + 10;

// Clamp to allocated size to prevent buffer overflow
new_trail_max_dots = min(new_trail_max_dots, trail_max_dots_allocated);

// Only update if size changed significantly
abs(new_trail_max_dots - trail_max_dots) > 5 ? (
  // Update buffer size limit (memory is already allocated)
  trail_max_dots = new_trail_max_dots;
  // Clear existing trail dots when parameters change
  trail_count = 0;
  trail_write_pos = 0;
  trail_last_creation_time = 0;
);


//==============================================================================
// ON BLOCK
//==============================================================================

@block

// Store block-level max values for histograms (captured during previous block)
// Convert detector level from linear to dB (once per block instead of per sample)
input_db_for_histogram = linear_to_db(max(detector_level_block_max, MIN_DETECTOR_LEVEL));
gr_db_for_histogram = gr_db_block_max;

// Reset max trackers for next block
detector_level_block_max = MIN_DETECTOR_LEVEL;
gr_db_block_max = 0;

// Update coefficients every block for real-time response
// This ensures parameters work immediately even if @slider doesn't run right away when sliderchange() is called from @gfx
update_filter_coefficients();
update_attack_coefficient();
update_release_coefficient();
update_rms_coefficient();
update_strength_multiplier();


//==============================================================================
// GFX RUNTIME
//==============================================================================

@gfx 2625 800 // Width: 2625 (75% of 3500), Height: 800 (increased to show debug panel at bottom)

// Update mouse state constants dynamically (evaluated every frame)
MOUSE_LEFT_BUTTON = mouse_cap & 1 ? 1 : 0;      // Left mouse button
MOUSE_RIGHT_BUTTON = mouse_cap & 2 ? 1 : 0;     // Right mouse button
MOUSE_MIDDLE_BUTTON = mouse_cap & 64 ? 1 : 0;   // Middle mouse button (wheel click)
MOUSE_CTRL_KEY = mouse_cap & 4 ? 1 : 0;         // Ctrl/Cmd key held
MOUSE_SHIFT_KEY = mouse_cap & 8 ? 1 : 0;        // Shift key held
MOUSE_ALT_KEY = mouse_cap & 16 ? 1 : 0;         // Alt key held

// Convert detector level to dB once per frame for UI display (instead of per-sample)
current_input_db = linear_to_db(max(detector_level, MIN_DETECTOR_LEVEL));

// Get latest input histogram value (if available)
input_histogram_db = current_input_db;  // Default to current input if histogram not available
INPUT_HISTOGRAM_ENABLED && input_histogram_initialized ? (
  // Get the most recent value from the input histogram buffer
  // buffer_pos points to the next write position, so most recent is (pos - 1) wrapped
  latest_idx = (input_histogram_pos - 1 + input_histogram_max_samples) % input_histogram_max_samples;
  input_histogram_db = input_histogram_buffer[latest_idx];
);

// Calculate blended input dB value based on slider
blend_amount = input_dot_blend / 100.0;  // Convert 0-100 to 0-1
blended_input_db = current_input_db * (1.0 - blend_amount) + input_histogram_db * blend_amount;

// OPTIMIZATION: Cache audio active state (play_state 1=playing, 5=recording)
// This avoids recalculating it 3+ times per frame across different render functions
is_audio_active = (play_state == 1) || (play_state == 5);

// Update histograms with block-max values (most efficient and smooth)
HISTOGRAM_ENABLED ? update_histogram_state(gr_db_for_histogram);
INPUT_HISTOGRAM_ENABLED ? update_input_histogram_state(input_db_for_histogram);

// Strength now used directly - no need for strength_actual

// Render main interface
render_complete_interface();

// Render debug information (controlled by menu_debug_enabled toggle in right-click menu)
debug_render();


//==============================================================================
// ON SAMPLE
//==============================================================================

@sample

// Process the complete audio chain using modular functions
process_complete_audio_chain();
