// Advanced Multi-Model Compressor JSFX - Modular Version
// Professional multi-algorithm compressor with interactive graph
// Features: multiple characters, feedforward/feedback, RMS normalization,
// program-dependent release, dedicated harmonic stage, soft-clipping limiter
// Author: Custom JSFX Generator
// Version: 3.0 - Advanced multi-model implementation (Modular)

desc:Advanced Multi-Model Compressor (Modular)


//==============================================================================
// SLIDER DEFINITIONS
//==============================================================================


// Time-related parameters (1-5)
slider1:attack_ms=10<0.05,100,0.1>-Attack
slider2:attack_curve=0<-2,2,0.01>-Attack Curve
slider3:release_ms=100<10,1000,1>Release
slider4:release_curve=-2<-2,2,0.01>-Release Curve
slider5:lookahead_ms=0<0,2000,1>-Lookahead

// RMS & Detection parameters (6-9)
slider6:rms_size_ms=0<1,100,0.1>-RMS Window
slider7:rms_normalization=0<0,1,1{Off,On}>-RMS Normalization
slider8:detection_mode=1<0,1,1{Feedback,Feedforward}>-Detection Mode
slider9:max_gr_db=-100<-100,0,1>-Max GR

// Filtering parameters (10-11)
// Sliders store actual frequency values - discrete steps
// HP: 0=Off (displayed as "Off" in UI), then 20Hz to 6kHz
// LP: 20Hz to 14kHz, then 0=Off (displayed as "Off" in UI, default)
slider10:hp_freq=0<0,6000,1{0,20,30,40,60,80,100,120,150,200,250,300,350,400,500,600,750,1000,1250,1500,1750,2000,2500,3000,3500,4000,5000,6000}>-HP Filter
slider11:lp_freq=16000<0,14000,1{20,30,40,60,80,100,120,150,200,250,300,350,400,500,600,750,1000,1250,1500,1750,2000,2500,3000,3500,4000,5000,6000,8000,10000,12000,14000,0}>-LP Filter

// Character & Harmonics parameters (12-17)
slider12:harmonic_type=0<0,2,1{Off,Tape,Tube}>-Type
slider13:harmonic_amount=0<0,1,0.01>-Amount
slider14:harmonic_drive=50<0,100,1>-Drive (%)
slider15:harmonic_mix=0<0,100,1>-Mix
slider16:harmonic_even_boost=0<0,200,1>-Even
slider17:harmonic_odd_boost=0<0,200,1>-Odd

// Global parameters (18-24)
slider18:strength=1<0.25,10,0.1>Strength
slider19:global_offset_db=0<-30,30,0.25>-Global Offset
slider20:makeup_gain_db=0<-20,20,0.1>-Makeup Gain
slider21:compressor_type=0<0,6,1{Clean Digital,Varimu,Bridged Diode,VCA,PWM/Fairchild,FET,Optical}>-Compressor Type
slider22:use_sidechain=0<0,1,1{No,Yes}>-Use Sidechain
slider23:listen_to_sidechain=0<0,1,1{No,Yes}>-Listen to Detection Signal
slider24:prog_release_type=0<0,4,1{Fixed Release,Input-Dependent,GR Dependent,Rate-of-Change,Input-Dependent 2}>-Program Release Type
slider25:brickwall_limiter=1<0,1,1{Off,On}>-Brickwall Limiter

// Advanced Envelope parameters (26-29)
slider26:gr_blend_threshold_db=6<1,24,0.1>-GR Blend Threshold (dB)
slider27:input_level_threshold_db=-20<-80,0,0.1>-Input Level Threshold (dB)
slider28:input_level_threshold_2_db=-40<-80,0,0.1>-Input Level Threshold 2 (dB)
slider29:transient_detection=0<0,100,1>-Transient Detection
slider30:transient_threshold_db=-6<-80,0,0.1>-Transient Threshold (dB)

// Dot Trail parameters (31-32)
slider31:trail_interval_ms=50<10,500,10>-Trail Interval (ms)
slider32:trail_fade_duration_ms=1000<100,5000,50>-Trail Fade Duration (ms)

// Time multiplier for attack display (33)
slider33:time_multiplier=1<0,2,1{Microseconds,Milliseconds,Seconds}>-Time Unit

// SEARCH STOP

//==============================================================================
// INCLUDE MODULES
//==============================================================================

// For Claude: These are import, not @import or include or @include

// 01_Utils: Foundation utilities (no dependencies)
import 01_Utils/01_constants.jsfx-inc
import 01_Utils/02_math_utils.jsfx-inc
import 01_Utils/03_debug_logging.jsfx-inc
import 01_Utils/04_file_reading.jsfx-inc
import 01_Utils/05_memory.jsfx-inc
import 01_Utils/06_state.jsfx-inc

// 02_InputProcessing: Input signal conditioning (depends on 01_Utils)
import 02_InputProcessing/01_dsp_utils.jsfx-inc
import 02_InputProcessing/02_filters.jsfx-inc
import 02_InputProcessing/04_transient_detection.jsfx-inc

// 03_Compression: Core compression engine (depends on 01_Utils, 02_InputProcessing)
import 03_Compression/01_compression_constants.jsfx-inc
import 03_Compression/02_graph_data_core.jsfx-inc
import 03_Compression/03_graph_curves.jsfx-inc
import 03_Compression/04_graph_cache.jsfx-inc
import 03_Compression/05_compression_core.jsfx-inc
import 03_Compression/06_gain_reduction.jsfx-inc
import 03_Compression/07_envelope.jsfx-inc
import 03_Compression/08_harmonic_models.jsfx-inc
import 03_Compression/09_audio_processing_chain.jsfx-inc

// 04_UI_Rendering: UI rendering components (depends on 01_Utils)
import 01_Utils/07_ui_constants.jsfx-inc
import 01_Utils/08_ui_utils.jsfx-inc
import 04_UI_Rendering/01_helpers.jsfx-inc
import 04_UI_Rendering/02_knobs.jsfx-inc
import 04_UI_Rendering/03_controls.jsfx-inc
import 04_UI_Rendering/04_debug.jsfx-inc
import 04_UI_Rendering/10_menu.jsfx-inc
import 04_UI_Rendering/05_header.jsfx-inc
import 04_UI_Rendering/11_threshold_lines.jsfx-inc
import 04_UI_Rendering/06_graph_cache.jsfx-inc
import 04_UI_Rendering/07_graph_curves.jsfx-inc
import 04_UI_Rendering/08_graph_meters.jsfx-inc
import 04_UI_Rendering/09_graph_display.jsfx-inc
import 04_UI_Rendering/12_dot_trail.jsfx-inc

// 05_UI_UserInteractions: User interaction handling (depends on 01_Utils, 04_UI_Rendering)
import 05_UI_UserInteractions/01_control_definitions.jsfx-inc
import 05_UI_UserInteractions/02_control_interactions.jsfx-inc
import 05_UI_UserInteractions/03_graph.jsfx-inc

// 06_UI_Orchestration: UI orchestration (depends on 01_Utils, 04_UI_Rendering, 05_UI_UserInteractions)
import 06_UI_Orchestration/01_ui_interaction.jsfx-inc
import 06_UI_Orchestration/02_ui_orchestration.jsfx-inc


//==============================================================================
// SERIALIZE
//==============================================================================

@serialize
// Prevent memory/variables from being cleared on @init
ext_noinit = 1.0;

// Serialize graph points data for persistence across plugin duplication and project saves
// This ensures graph points and curves are preserved when:
// - Duplicating the plugin instance
// - Copying/pasting the track
// - Saving and reopening the project
// - Restarting REAPER
file_var(0, graph_initialized);
file_var(0, num_points);

// Save all graph points
i = 0;
while (i < num_points) (
  file_var(0, graph_points[i*2]);     // input_db
  file_var(0, graph_points[i*2 + 1]); // output_db
  i += 1;
);

// Save curve data
i = 0;
while (i < num_points) (
  file_var(0, curve_amounts[i]);
  i += 1;
);

//==============================================================================
// INITIALIZATION SEQUENCE
//==============================================================================

@init

// 1. Read slider definitions from file FIRST (needed for memory allocation)
read_slider_definitions();

// 2. Initialize all constants, memory, and state variables
allocate_memory();
init_state_variables();

// 2.5. Initialize graph optimization constants (requires GRAPH_SIZE to be defined)
init_graph_optimization_constants();

// 3. Initialize stage control variables
stage_input = 1;                    // Input stage (always needed)
stage_detection_source = 1;         // Detection source selection
stage_filtering = 1;                // Detection signal filtering (applies to active detection signal)
stage_detection_analysis = 1;       // RMS detection and gain reduction calculation
stage_character = 1;                // Character application
stage_envelope = 1;                 // Envelope following
stage_lookahead = 1;                // Lookahead processing
stage_gain_reduction = 1;           // Gain reduction application
stage_harmonics = 1;                // Harmonic processing
stage_final_mix = 1;                // Final mix
stage_limiter = 1;                  // Brickwall limiter
stage_output = 1;                   // Output stage (always needed)

// Initialize slider processing flag (ensures @slider calculations run on first load)
slider_initialized = 0;

// Initialize makeup gain to unity (will be recalculated in @slider)
makeup_gain_linear = 1.0;

// Initialize strength multiplier (will be recalculated in @slider)
strength_actual = strength * strength;

// Calculate limiter normalization constant (pre-calculated to avoid per-sample division)
LIMITER_TANH_NORM = 1.0 / tanh(0.95);  // â‰ˆ 1.343

// 4. Initialize curve data
init_curve_data();

// 5. Set up control layout
setup_control_layout();

// 6. Initialize graph points (only on first load)
!graph_initialized ? (
  // Initialize with defaults (ext_noinit preserves values across reloads)
  num_points = 6;
  init_graph_points();
  invalidate_compression_threshold(); // Mark threshold for recalculation
  graph_initialized = 1;
);

// 7. Mark compression system as ready (prevents LUT race condition)
compression_init_complete = 1;

//==============================================================================
// ON SLIDER UPDATES
//==============================================================================

@slider

// Track which parameters actually changed
param_changed = 0;

// --- Filter Parameters (11-12) ---
// Sliders store actual frequency values directly in Hz
// hp_freq: 0 = Off, 1-6000 = filter frequency
// lp_freq: 20000 = Off, 80-19999 = filter frequency
(slider11 != hp_freq_prev || !slider_initialized) ? (
  hp_freq_prev = slider11;
  param_changed = 1;
);

(slider12 != lp_freq_prev || !slider_initialized) ? (
  lp_freq_prev = slider12;
  param_changed = 1;
);

// Filter coefficients are updated in @block for real-time response

// --- Timing Parameters (1-5) ---
(slider1 != attack_ms_prev || slider3 != release_ms_prev ||
 slider5 != lookahead_ms_prev ||
 slider7 != rms_size_ms_prev || slider2 != attack_curve_prev ||
 slider4 != release_curve_prev || !slider_initialized) ? (

  // Clear RMS buffer if window size changed
  slider7 != rms_size_ms_prev ? (
    clear_rms_state();
  );

  // Calculate sample counts
  rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
  lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);

  param_changed = 1;

  // Store for next comparison
  attack_ms_prev = slider1;
  release_ms_prev = slider3;
  lookahead_ms_prev = slider5;
  rms_size_ms_prev = slider7;
  attack_curve_prev = slider2;
  release_curve_prev = slider4;
);

// --- Makeup Gain (21) ---
(slider21 != makeup_gain_db_prev || !slider_initialized) ? (
  makeup_gain_linear = db_to_linear(makeup_gain_db);
  makeup_gain_db_prev = slider21;
  param_changed = 1;
);


// --- Plugin Delay Compensation ---
// Cockos pattern: Calculate and set unconditionally every @slider execution
// This MUST run every time @slider executes (not just on change)
pdc_delay = min(lookahead_ms * 0.001 * srate, max_lookahead_samples) | 0;
pdc_delay > 0 ? (
  pdc_bot_ch = 0;
  pdc_top_ch = 2;  // Stereo channels (0=left, 1=right)
);

// --- Strength and Global Offset parameters ---
(slider19 != strength_prev || slider20 != global_offset_db_prev || !slider_initialized) ? (
  strength_prev = slider19;
  global_offset_db_prev = slider20;
  
  // Apply logarithmic/exponential transformation to strength for more pronounced effect
  // Using power of 2: strength=1 -> actual=1, strength=3 -> actual=9, strength=10 -> actual=100
  strength_actual = strength * strength;
  
  param_changed = 1;
  
  // Note: Strength is applied AFTER curve lookup in calculate_gain_reduction(),
  // so it doesn't affect the curve shape itself. No need to invalidate curve cache.
  // Global offset is applied at lookup time (shifts input level before curve lookup).
);

// --- Trail Parameters (31-32) ---
(slider31 != trail_interval_ms_prev || slider32 != trail_fade_duration_ms_prev || !slider_initialized) ? (
  trail_interval_ms_prev = slider31;
  trail_fade_duration_ms_prev = slider32;
  
  // Recalculate trail buffer size if parameters changed
  trail_interval_samples = trail_interval_ms * 0.001 * srate;
  trail_fade_samples = trail_fade_duration_ms * 0.001 * srate;
  new_trail_max_dots = ceil(trail_fade_samples / trail_interval_samples) + 10;
  
  // Only reallocate if size changed significantly
  abs(new_trail_max_dots - trail_max_dots) > 5 ? (
    // Update buffer size (memory is already allocated, just update the limit)
    trail_max_dots = new_trail_max_dots;
    // Clear existing trail dots when parameters change
    trail_count = 0;
    trail_write_pos = 0;
    trail_last_creation_time = 0;
  );
  
  param_changed = 1;
);

// Mark slider section as initialized (ensures all calculations run on first load)
slider_initialized = 1;

//==============================================================================
// ON BLOCK
//==============================================================================

@block

// Store block-level max values for histograms (captured during previous block)
// Convert detector level from linear to dB (once per block instead of per sample)
input_db_for_histogram = linear_to_db(max(detector_level_block_max, MIN_DETECTOR_LEVEL));
gr_db_for_histogram = gr_db_block_max;

// Reset max trackers for next block
detector_level_block_max = MIN_DETECTOR_LEVEL;
gr_db_block_max = 0;

// Update filter coefficients every block for real-time response
update_filter_coefficients();

// Update attack and release coefficients every block for real-time response
// Cache coefficients to avoid redundant calculations
attack_coeff = attack_ms > 0 ? exp(-1000 / (attack_ms * srate)) : 0;
release_coeff = release_ms > 0 ? exp(-1000 / (release_ms * srate)) : 0;

// Cache frequently used calculations
srate_inv = 1.0 / srate;
attack_ms_srate = attack_ms * srate;
release_ms_srate = release_ms * srate;

// Apply curves with S-curve and exponential algorithms
attack_curve != 0 ? (
  attack_curve > 0 ? (
    // Positive curves (right): S-curve response - smooth, gradual onset
    curve_amount = attack_curve;
    s_curve_factor = 1.0 + curve_amount * 0.3; // Reduced from 0.6 to 0.3
    s_curve_factor *= (1.0 + curve_amount * 0.15); // Reduced from 0.3 to 0.15
    attack_coeff = pow(attack_coeff, s_curve_factor);
  ) : (
    // Negative curves (left): steep exponential response - fast, aggressive onset
    curve_amount = abs(attack_curve);
    attack_coeff = pow(attack_coeff, 1.0 - curve_amount * 0.3); // Reduced from 0.7 to 0.3
  );
);

release_curve != 0 ? (
  release_curve > 0 ? (
    // Positive curves (right): S-curve response - smooth, gradual recovery
    curve_amount = release_curve;
    s_curve_factor = 1.0 + curve_amount * 0.3; // Reduced from 0.6 to 0.3
    s_curve_factor *= (1.0 + curve_amount * 0.15); // Reduced from 0.3 to 0.15
    release_coeff = pow(release_coeff, s_curve_factor);
  ) : (
    // Negative curves (left): steep exponential response - fast, aggressive recovery
    curve_amount = abs(release_curve);
    release_coeff = pow(release_coeff, 1.0 - curve_amount * 0.3); // Reduced from 0.7 to 0.3
  );
);

// Update RMS parameters every block for real-time response
// Fix: Clear buffer when RMS window size changes to prevent stale data bug
new_rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
new_rms_samples != rms_samples ? (
  rms_samples = new_rms_samples;
  // Clear RMS state when window size changes (fixes bug with stale buffer data)
  menu_true_rms_enabled > 0.5 ? (
    clear_rms_state();  // Clear circular buffer for True RMS mode
  ) : (
    rms_smoothed_squared = 0;  // Reset exponential smoothing state
  );
) : (
  rms_samples = new_rms_samples;  // Update even if same (for safety)
);

// OPTIMIZATION: Cache RMS reciprocal to avoid per-sample division
rms_samples_inv = 1.0 / max(rms_samples, 1);

// OPTIMIZATION: Calculate power-of-2 size and bit mask for fast circular buffer (like lookahead)
// Bit masking (x & mask) is 3-5x faster than modulo (x % size)
// TEMPORARILY DISABLED: These variables are calculated but not used, and may cause performance issues
// rms_samples_pow2 = 1;
// while(rms_samples_pow2 < rms_samples) (rms_samples_pow2 *= 2);
// rms_mask = rms_samples_pow2 - 1;

// OPTIMIZATION: Pre-calculate RMS exponential smoothing coefficients (moved from @sample)
// Only needed when NOT using True RMS mode and RMS window > 0
menu_true_rms_enabled == 0 && rms_size_ms > 0 ? (
  rms_smoothing_coeff = exp(-1000.0 / (rms_size_ms * srate));
  rms_smoothing_one_minus = 1 - rms_smoothing_coeff;
);

// OPTIMIZATION: Cache harmonic drive compensation reciprocal to avoid per-sample division
drive_compensation_inv = 1.0 / max(harmonic_drive, 1);


//==============================================================================
// GFX RUNTIME
//==============================================================================

@gfx 2625 800 // Width: 2625 (75% of 3500), Height: 800 (increased to show debug panel at bottom)

// Update mouse state constants dynamically (evaluated every frame)
MOUSE_LEFT_BUTTON = mouse_cap & 1 ? 1 : 0;      // Left mouse button
MOUSE_RIGHT_BUTTON = mouse_cap & 2 ? 1 : 0;     // Right mouse button
MOUSE_MIDDLE_BUTTON = mouse_cap & 64 ? 1 : 0;   // Middle mouse button (wheel click)
MOUSE_CTRL_KEY = mouse_cap & 4 ? 1 : 0;         // Ctrl/Cmd key held
MOUSE_SHIFT_KEY = mouse_cap & 8 ? 1 : 0;        // Shift key held
MOUSE_ALT_KEY = mouse_cap & 16 ? 1 : 0;         // Alt key held

// Convert detector level to dB once per frame for UI display (instead of per-sample)
current_input_db = linear_to_db(max(detector_level, MIN_DETECTOR_LEVEL));

// Update histograms with block-max values (most efficient and smooth)
HISTOGRAM_ENABLED ? update_histogram_state(gr_db_for_histogram);
INPUT_HISTOGRAM_ENABLED ? update_input_histogram_state(input_db_for_histogram);

// Render main interface
render_complete_interface();

// Render debug information (controlled by menu_debug_enabled toggle in right-click menu)
debug_render();


//==============================================================================
// ON SAMPLE
//==============================================================================

@sample

// Process the complete audio chain using modular functions
process_complete_audio_chain();
