desc:Composure

//==============================================================================
// SLIDER DEFINITIONS
//==============================================================================
// Reordered to match UI layout (logical grouping)

// GROUP 0: ENVELOPE (1-6)
slider1:attack=10<0.01,5000,0.01>-Attack
slider2:attack_curve=0<-2,2,0.01>-Attack Curve
slider3:hold_ms=0<0,1000,1>-Hold
slider4:release_ms=100<0.01,5000,0.01>-Release
slider5:release_curve=0<-2,2,0.01>-Release Curve
slider6:prog_release_type=0<0,5,1{Fixed Release,Input-Dependent,GR Dependent,Rate-of-Change,GR Dep Inverse,Input Dep Inverse}>-Program Release

// GROUP 1: DETECTION (7-11)
slider7:time_multiplier=1<0,1,1{Milliseconds,Microseconds}>-Time Unit
slider8:rms_size_ms=0<0,100,0.1>-RMS Window
slider9:rms_normalization=0<0,1,1{Off,On}>-RMS Normalization
slider10:detection_mode=1<0,1,1{Feedback,Feedforward}>-Detection Mode
slider11:lookahead_ms=0<0,2000,1>-Lookahead

// GROUP 2: COMPRESSION (13-14)
slider13:strength=100<0,400,5>-Strength
slider14:input_offset_db=0<-30,30,0.25>-Input Offset

// GROUP 4: SOURCE (15-18)
slider15:use_sidechain=0<0,1,1{No,Yes}>-Use Sidechain
slider16:listen_to_sidechain=0<0,1,1{No,Yes}>-Listen to Detection Signal
slider17:hp_freq=0<0,6000,1>-High Pass
slider18:lp_freq=0<0,14000,1>-Low Pass

// GROUP 3: HARMONICS (19-23)
slider19:harmonic_type=0<0,1,1{Tape,Tube}>-Type
slider20:harmonic_drive=50<0,100,1>-Drive
slider21:harmonic_mix=0<0,100,1>-Mix
slider22:harmonic_even_boost=0<0,200,1>-Even
slider23:harmonic_odd_boost=0<0,200,1>-Odd

// HEADER (25)
slider25:makeup_gain_db=0<-20,20,0.1>Makeup Gain

// ADVANCED/HIDDEN PARAMETERS (26-34)
slider26:brickwall_limiter=1<0,1,1{Off,On}>-Brickwall Limiter
slider27:gr_blend_threshold_reduction_db=6<1,24,0.1>-GR Threshold Cut (dB)
slider28:input_level_threshold_db=-20<-80,0,0.1>-Input Level Threshold (dB)
slider29:input_level_threshold_2_db=-40<-80,0,0.1>-Input Level Threshold 2 (dB)
slider30:harmonic_amount=1<0,1,0.01>Amount
slider31:trail_interval_ms=50<10,500,10>-Trail Interval (ms)
slider32:trail_fade_duration_ms=1000<100,5000,50>-Trail Fade Duration (ms)
slider33:rate_change_sensitivity_db=3<0.5,20,0.1>-Rate Change Sensitivity (dB)
slider34:gr_blend_threshold_addition_db=6<1,24,0.1>-GR Threshold Boost (dB)
slider35:rate_change_threshold_modifier=1<0.5,4,0.1>-Rate Change Threshold Modifier
slider36:gr_blend_threshold_reduction_knee_db=2<0,12,0.1>-GR Threshold Cut Knee (dB)
slider37:gr_blend_threshold_addition_knee_db=2<0,12,0.1>-GR Threshold Boost Knee (dB)

// SEARCH STOP

//==============================================================================
// IMAGE DEFINITIONS
//==============================================================================

// Load background image (PNG files are loaded from same directory as effect)
filename:0,Images/Composure_BG1.png
// Load toggle switch images
filename:1,Images/toggle_left2.png
filename:2,Images/toggle_right2.png
// Load parallax fader images
filename:3,Images/para_horz_fader_top.png
filename:4,Images/para_horz_fader_bot_left.png
filename:5,Images/para_horz_fader_bot_right.png

//==============================================================================
// INCLUDE MODULES
//==============================================================================

// 01_Utils: Foundation utilities (no dependencies)
import 01_Utils/01_constants.jsfx-inc
import 01_Utils/02_math_utils.jsfx-inc
import 01_Utils/03_debug_logging.jsfx-inc

// UI_Sliders/00_file_reading: File reading (standalone, needed by 01_Utils/05_memory, 02_InputProcessing, and UI_General)
import UI_Sliders/00_file_reading.jsfx-inc

import 01_Utils/05_memory.jsfx-inc

// 02_InputProcessing: Input signal conditioning (depends on 01_Utils)
import 02_InputProcessing/01_dsp_utils.jsfx-inc
import 02_InputProcessing/02_filters.jsfx-inc

// 03_Compression: Core compression engine (depends on 01_Utils, 02_InputProcessing)
import 03_Compression/01_compression_constants.jsfx-inc
import 03_Compression/02_graph_data_core.jsfx-inc
import 03_Compression/03_graph_curves.jsfx-inc
import 03_Compression/05_compression_core.jsfx-inc
import 03_Compression/06_gain_reduction.jsfx-inc
import 03_Compression/08_harmonic_models.jsfx-inc

// 03_Compression/Envelope: Envelope processing modules (must be imported before 09_audio_processing_chain)
// 05_envelope_parameters depends on clear_rms_state from 09_audio_processing_chain, but we handle this by importing utils first
import 03_Compression/Envelope/00_envelope_utils.jsfx-inc
import 03_Compression/Envelope/01_envelope_attack.jsfx-inc
import 03_Compression/Envelope/02_envelope_hold.jsfx-inc
import 03_Compression/Envelope/03_envelope_release.jsfx-inc
import 03_Compression/Envelope/04_envelope_orchestration.jsfx-inc

// 03_Compression/09_audio_processing_chain: Audio processing (depends on envelope modules for process_envelope_following)
import 03_Compression/09_audio_processing_chain.jsfx-inc

// 03_Compression/Envelope/05_envelope_parameters: Parameter updates (depends on clear_rms_state from 09_audio_processing_chain)
import 03_Compression/Envelope/05_envelope_parameters.jsfx-inc

// UI_General: General UI components (constants, utils, drawing, debug, header, menu)
// These are foundational and must be imported first
import UI_General/00_ui_constants.jsfx-inc
import UI_General/02_ui_utils.jsfx-inc
import UI_General/01_drawing_primitives.jsfx-inc
import UI_General/04_debug.jsfx-inc
import UI_General/10_menu.jsfx-inc
import UI_General/05_header.jsfx-inc
// Page buttons system (modular button-based pagination)
import UI_General/17_page_buttons.jsfx-inc
// Coordinate conversion service (independent, used by graph and meter)
import UI_General/12_coordinate_conversion.jsfx-inc
// Threshold lines service (independent, used by graph and meter)
import UI_General/11_threshold_lines.jsfx-inc

// UI_Sliders: Slider control library (depends on UI_General)
import UI_Sliders/00_slider_constants.jsfx-inc
import UI_Sliders/01a_value_formatting.jsfx-inc
import UI_Sliders/01b_value_text_rendering.jsfx-inc
import UI_Sliders/01c_slider_rendering.jsfx-inc
import UI_Sliders/01d_parallax_fader_rendering.jsfx-inc
import UI_Sliders/01e_button_rendering.jsfx-inc
import UI_Sliders/01f_dropdown_rendering.jsfx-inc
import UI_Sliders/01h_slider_objects.jsfx-inc
import UI_Sliders/01g_control_dispatcher.jsfx-inc
import UI_Sliders/01_control_definitions.jsfx-inc
import UI_Sliders/02_control_interactions.jsfx-inc

// Composure-specific control layout (uses Sliders library)
import UI_Controls/05_Composure_Controls.jsfx-inc

// UI_Graph: Graph rendering and interaction (depends on UI_General)
// threshold_lines is now in UI_General and independent
import UI_Graph/06_graph_cache.jsfx-inc
import UI_Graph/07_graph_curves.jsfx-inc
import UI_Graph/08_graph_meters.jsfx-inc
import UI_Graph/09_graph_display.jsfx-inc
import UI_Graph/12_dot_trail.jsfx-inc
import UI_Graph/03_graph.jsfx-inc

// UI_General: Custom buttons (depends on UI_General constants and drawing, and page buttons)
// Must be imported before 01_Utils/06_state.jsfx-inc since init_state_variables() calls init_custom_button_state()
import UI_General/15_custom_buttons.jsfx-inc
// Settings page (depends on page buttons system)
import UI_General/18_settings_page.jsfx-inc
// Filters page (depends on page buttons system)
import UI_General/19_filters_page.jsfx-inc

// 01_Utils/06_state: State initialization (depends on all modules above)
// Must be imported after all init functions are defined
import 01_Utils/06_state.jsfx-inc

// UI_General: UI orchestration (depends on UI_General, UI_Sliders, UI_Graph)
// These must be imported last as they orchestrate all UI components
import UI_General/13_ui_interaction.jsfx-inc
import UI_General/14_ui_orchestration.jsfx-inc


//==============================================================================
// SERIALIZE
//==============================================================================

@serialize
// Prevent memory/variables from being cleared on @init
ext_noinit = 1.0;

// Serialize graph points data for persistence across plugin duplication and project saves
// This ensures graph points and curves are preserved when:
// - Duplicating the plugin instance
// - Copying/pasting the track
// - Saving and reopening the project
// - Restarting REAPER
file_var(0, graph_initialized);
file_var(0, num_points);

// Save all graph points
i = 0;
while (i < num_points) (
  file_var(0, graph_points[i*2]);     // input_db
  file_var(0, graph_points[i*2 + 1]); // output_db
  i += 1;
);

// Save curve data
i = 0;
while (i < num_points) (
  file_var(0, curve_amounts[i]);
  i += 1;
);

//==============================================================================
// INITIALIZATION SEQUENCE
//==============================================================================

@init

// 1. Read slider definitions from file FIRST (needed for memory allocation)
read_slider_definitions("Composure.jsfx");

// 2. Initialize all constants, memory, and state variables
allocate_memory();
// Initialize step-point arrays (must happen after memory allocation)
init_step_points();
init_state_variables();

// 2.5. Initialize graph optimization constants (requires GRAPH_SIZE to be defined)
// Must be called after UI_General imports (specifically after 00_ui_constants.jsfx-inc)
init_graph_optimization_constants();


// Initialize limiter constants (must be called after math_utils import)
init_limiter_constants();

// 4. Initialize curve data
init_curve_data();

// 5. Set up control layout
// Initialize slider objects (namespace-based) before layout uses them
init_slider_objects();
setup_control_layout();

// 6. Initialize graph points (only on first load)
!graph_initialized ? (
  // Initialize with defaults (ext_noinit preserves values across reloads)
  num_points = 6;
  init_graph_points();
  invalidate_compression_threshold(); // Mark threshold for recalculation
  graph_initialized = 1;
) : (
  // If graph was already initialized (loaded from preset), update corner points
  // to ensure they follow the tangent of the loaded user points
  update_corner_points();
);

// 7. Cache frequently used time calculations (sample rate dependent)
srate_inv = 1.0 / srate;
// Update lookahead samples using dedicated function
// Update functions are defined in 02_InputProcessing/
update_lookahead_samples();

// 8. Update all parameter coefficients using dedicated update functions
// This ensures coefficients are correctly initialized even after samplerate changes
// Update functions are defined in 03_Compression/Envelope/
update_filter_coefficients();
update_attack_coefficient();
update_release_coefficient();
update_hold_samples();
update_rms_coefficient();
// Convert Strength from percentage (0-400%) to multiplier (0.0-4.0)
strength_multiplier = strength / 100.0;
// Convert Makeup Gain from dB to linear scale
makeup_gain_linear = db_to_linear(makeup_gain_db);

// 9. Mark compression system as ready (prevents LUT race condition)
compression_init_complete = 1;

//==============================================================================
// ON SLIDER UPDATES
//==============================================================================

@slider

// --- Envelope Parameters (1-6) ---
// Update cached sample rate calculations
srate_inv = 1.0 / srate;
// Update attack and release coefficients using dedicated functions
// Update functions are defined in 03_Compression/Envelope/
update_attack_coefficient();
update_release_coefficient();
update_hold_samples();

// --- Detection Parameters (7-12) ---
// Update RMS coefficients using dedicated function
update_rms_coefficient();
// Start smoothing immediately when slider changes (also smoothed in @block for continuous updates)
smooth_rms_coefficient();
// Update lookahead samples using dedicated function
// Update functions are defined in 02_InputProcessing/
update_lookahead_samples();

// --- Compression Parameters (13-14) ---
// Convert Strength from percentage (0-400%) to multiplier (0.0-4.0)
strength_multiplier = strength / 100.0;
// Note: Strength is now used directly in gain reduction calculation
// Input offset is applied at lookup time (shifts input level before curve lookup).

// --- Source Parameters (15-18) ---
// Filter Parameters (17-18)
// Sliders use enumerated indices - get actual frequency value from option
// hp_freq: index 0 = Off, other indices = filter frequency
// lp_freq: index 31 = Off, other indices = filter frequency
// Update filter coefficients (runs every @slider execution)
update_filter_coefficients();

// --- Harmonics Parameters (19-23) ---
// Cache harmonic drive compensation reciprocal to avoid per-sample division
drive_compensation_inv = 1.0 / max(harmonic_drive, 1);

// --- Header Parameters (24-25) ---
// Convert Makeup Gain from dB to linear scale
makeup_gain_linear = db_to_linear(makeup_gain_db);

// --- Plugin Delay Compensation ---
// Cockos pattern: Calculate and set unconditionally every @slider execution
// This MUST run every time @slider executes (not just on change)
// Use cached lookahead_samples instead of recalculating
pdc_delay = min(lookahead_samples, max_lookahead_samples) | 0;
pdc_delay > 0 ? (
  pdc_bot_ch = 0;
  pdc_top_ch = 2;  // Stereo channels (0=left, 1=right)
);

// --- Trail Parameters (31-32) ---
// Recalculate trail buffer size
trail_interval_samples = trail_interval_ms * 0.001 * srate;
trail_fade_samples = trail_fade_duration_ms * 0.001 * srate;
new_trail_max_dots = ceil(trail_fade_samples / trail_interval_samples) + 10;

// Clamp to allocated size to prevent buffer overflow
new_trail_max_dots = min(new_trail_max_dots, trail_max_dots_allocated);

// Only update if size changed significantly
abs(new_trail_max_dots - trail_max_dots) > 5 ? (
  // Update buffer size limit (memory is already allocated)
  trail_max_dots = new_trail_max_dots;
  // Clear existing trail dots when parameters change
  trail_count = 0;
  trail_write_pos = 0;
  trail_last_creation_time = 0;
);


//==============================================================================
// ON BLOCK
//==============================================================================

@block

// Store block-level max values for histograms (captured during previous block)
// Convert detector level from linear to dB (once per block instead of per sample)
// Apply input offset to histogram so it shows offset-adjusted input level (what compressor sees)
input_db_for_histogram = linear_to_db(max(detector_level_block_max, MIN_DETECTOR_LEVEL)) + input_offset_db;
gr_db_for_histogram = gr_db_block_max;
gr_db_before_strength_for_histogram = gr_db_before_strength_block_max;

// Reset max trackers for next block
detector_level_block_max = MIN_DETECTOR_LEVEL;
gr_db_block_max = 0;
gr_db_before_strength_block_max = 0;

// Update coefficients every block for real-time response
// This ensures parameters work immediately even if @slider doesn't run right away when sliderchange() is called from @gfx
// Update functions are defined in 03_Compression/Envelope/ and 02_InputProcessing/
update_filter_coefficients();
update_lookahead_samples();
update_attack_coefficient();
update_release_coefficient();
update_hold_samples();
update_rms_coefficient();
// Smoothly interpolate RMS coefficient to prevent zipper noise when window size changes
smooth_rms_coefficient();
// Convert Strength from percentage (0-400%) to multiplier (0.0-4.0)
strength_multiplier = strength / 100.0;
// Convert Makeup Gain from dB to linear scale
makeup_gain_linear = db_to_linear(makeup_gain_db);


//==============================================================================
// GFX RUNTIME
//==============================================================================

@gfx 1066 428 // Width: 1066 (half of 2132), Height: 428

// Update mouse state constants dynamically (evaluated every frame)
MOUSE_LEFT_BUTTON = mouse_cap & 1 ? 1 : 0;      // Left mouse button
MOUSE_RIGHT_BUTTON = mouse_cap & 2 ? 1 : 0;     // Right mouse button
MOUSE_MIDDLE_BUTTON = mouse_cap & 64 ? 1 : 0;   // Middle mouse button (wheel click)
MOUSE_CTRL_KEY = mouse_cap & 4 ? 1 : 0;         // Ctrl/Cmd key held
MOUSE_SHIFT_KEY = mouse_cap & 8 ? 1 : 0;        // Shift key held
MOUSE_ALT_KEY = mouse_cap & 16 ? 1 : 0;         // Alt key held

// Convert detector level to dB once per frame for UI display (instead of per-sample)
// Apply input offset so dot shows offset-adjusted input level (what compressor sees)
current_input_db = linear_to_db(max(detector_level, MIN_DETECTOR_LEVEL)) + input_offset_db;

// Get current GR values for display (post-strength is already available as current_gr_db)
// Pre-strength GR represents the "true" GR used in calculations before strength multiplier
// This is tracked in the audio processing chain (@sample section) and available for visualization
// current_gr_db_before_strength is set in process_complete_audio_chain()

// Get latest input histogram value (if available)
input_histogram_db = current_input_db;  // Default to current input if histogram not available
INPUT_HISTOGRAM_ENABLED && input_histogram_initialized ? (
  // Get the most recent value from the input histogram buffer
  // buffer_pos points to the next write position, so most recent is (pos - 1) wrapped
  latest_idx = (input_histogram_pos - 1 + input_histogram_max_samples) % input_histogram_max_samples;
  input_histogram_db = input_histogram_buffer[latest_idx];
);

// Use input histogram value directly (100% blend - always use smoothed histogram value)
blended_input_db = input_histogram_db;

// OPTIMIZATION: Cache audio active state (play_state 1=playing, 5=recording)
// This avoids recalculating it 3+ times per frame across different render functions
is_audio_active = (play_state == 1) || (play_state == 5);

// Update histograms with block-max values (most efficient and smooth)
HISTOGRAM_ENABLED ? (
  update_histogram_state(gr_db_for_histogram);
  update_histogram_before_strength_state(gr_db_before_strength_for_histogram);
);
INPUT_HISTOGRAM_ENABLED ? update_input_histogram_state(input_db_for_histogram);

// Strength now used directly - no need for strength_actual

// Render main interface
render_complete_interface();

// Render debug information (controlled by menu_debug_enabled toggle in right-click menu)
debug_render();


//==============================================================================
// ON SAMPLE
//==============================================================================

@sample

// Process the complete audio chain using modular functions
process_complete_audio_chain();
