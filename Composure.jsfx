// Advanced Multi-Model Compressor JSFX - Full Featured Version
// Professional multi-algorithm compressor with interactive graph
// Features: multiple characters, feedforward/feedback, RMS normalization,
// program-dependent release, dedicated harmonic stage, soft-clipping limiter
// Author: Custom JSFX Generator
// Version: 3.0 - Advanced multi-model implementation

desc:Advanced Multi-Model Compressor (Full)

//==============================================================================
// SLIDER DEFINITIONS
//==============================================================================

slider1:strength=1<0.5,10,0.1>-Strength
slider2:global_offset_db=0<-30,30,0.1>-Global Offset (dB) - Traditional Threshold Control
slider3:attack_ms=10<0.1,100,0.1>-Attack (ms)
slider4:attack_curve=0<-2,2,0.01>-Attack Curve
slider5:release_ms=100<10,1000,1>-Release (ms)
slider6:release_curve=0<-2,2,0.01>-Release Curve
slider7:strength_curve=0<-2,2,0.01>-Strength Curve (exp)
slider8:makeup_gain_db=0<-20,20,0.1>-Makeup Gain (dB)
slider9:mix_wet=100<0,100,1>-Mix %
slider10:compressor_type=0<0,6,1{Clean Digital,Varimu,Bridged Diode,VCA,PWM/Fairchild,FET,Optical}>Compressor Type
slider11:use_sidechain=0<0,1,1{No,Yes}>-Use Sidechain
slider12:listen_to_sidechain=0<0,1,1{No,Yes}>-Listen to Detection Signal
slider13:hp_freq=20<20,200,1>-HP Filter (Hz)
slider14:lp_freq=20000<1000,20000,10>-LP Filter (Hz)
slider15:rms_size_ms=10<1,100,0.1>RMS Window (ms)
slider16:lookahead_ms=0<0,10,0.1>-Lookahead (ms)
slider17:hold_ms=0<0,50,0.1>-Hold Time (ms)
slider18:max_gr_db=-10<-30,0,1>-Max GR (dB)
slider19:over_the_top=100<0,200,1>-Over The Top % (Analog Character Intensity)
slider20:rms_normalization=0<0,1,1{Off,On}>RMS Normalization
slider21:detection_mode=1<0,1,1{Feedback,Feedforward}>-Detection Mode
slider22:prog_release_mode=0<0,1,1{Fixed Release,Program-Dependent Release}>Program Release Mode
slider23:prog_release_type=0<0,2,1{Level-Dependent,Rate-Of-Change,Hybrid}>Program Release Type
slider24:harmonic_type=0<0,4,1{Off,Tube Even,Tube Odd,Tube Both,Tape Saturation}>Harmonic Type
slider25:harmonic_amount=0<0,1,0.01>-Harmonic Amount
slider26:harmonic_drive=1<0.5,10,0.1>-Harmonic Drive
slider27:harmonic_mix=0<0,1,0.01>-Harmonic Mix
slider28:harmonic_even_boost=0<0,2,0.01>-Even Harmonic Boost
slider29:harmonic_odd_boost=0<0,2,0.01>-Odd Harmonic Boost
slider30:brickwall_limiter=1<0,1,1{Off,On}>-Brickwall Limiter

//==============================================================================
// PERSISTENT STATE VARIABLES (must be in global scope)
//==============================================================================

// Graph state - these need to persist across @init calls
num_points = 6;
selected_point = -1;
mouse_down = 0;
mouse_x_prev = 0;
mouse_y_prev = 0;
mouse_moved = 0;
graph_initialized = 0;

//==============================================================================
// CONSTANTS AND CONFIGURATION
//==============================================================================

@init

// Mathematical constants
PI = $pi;
LOG10_20 = 20 / log(10);
LOG_10_20 = log(10) / 20;
SRATE_INV = 1 / srate;

// Graph configuration
GRAPH_X = 50;
GRAPH_Y = 50;
GRAPH_SIZE = 500;
GRAPH_RANGE_DB = 60; // -30 to +30
GRAPH_MIN_DB = -30;
GRAPH_MAX_DB = 30;

// Point management
MIN_POINTS = 4;
MAX_POINTS = 12;
DEFAULT_KNEE_SIZE = 2;
MOUSE_CLICK_RADIUS = 10;

// Visual configuration
GFX_WIDTH = 600;
GFX_HEIGHT = 700;

//==============================================================================
// MEMORY ALLOCATION
//==============================================================================

freemem = 0;

// Graph point data: [input_db, output_db, knee_size] for each point
graph_points = freemem; 
freemem += MAX_POINTS * 3;

// Audio buffers
max_lookahead_samples = ceil(0.01 * srate);
lookahead_buffer_l = freemem; freemem += max_lookahead_samples;
lookahead_buffer_r = freemem; freemem += max_lookahead_samples;

max_rms_samples = ceil(0.1 * srate);
rms_buffer = freemem; freemem += max_rms_samples;

//==============================================================================
// STATE VARIABLES
//==============================================================================


// Audio processing state
envelope_out = 1;
hold_counter = 0;
rms_sum = 0;
rms_pos = 0;
lookahead_pos = 0;

// Filter states  
hp_x1_l=hp_x2_l=hp_y1_l=hp_y2_l=0;
hp_x1_r=hp_x2_r=hp_y1_r=hp_y2_r=0;
lp_x1_l=lp_x2_l=lp_y1_l=lp_y2_l=0;
lp_x1_r=lp_x2_r=lp_y1_r=lp_y2_r=0;

// Compressor character state
compression_history = 0;
photocell_charge = 0;
tube_saturation = 0;
fet_transient_detector = 0;
program_release_timer = 0;
average_input_level = 0;
varimu_release_factor = 1;
fet_attack_factor_stored = 1;
optical_program_factor = 1;

// New character model states
bridged_diode_env = 0;
vca_env = 0;
pwm_env = 0;
fet_env = 0;
optical_env = 0;
tape_env = 0;
prev_detector_db = 0;

// RMS normalization state
rms_max = 0.0001;

// Program release state
base_fast_s = 0.05;  // 50ms
base_med_s = 0.3;    // 300ms
base_slow_s = 1.0;   // 1000ms
global_smoothed_gain_db = 0;
modelGR_dB_prev = 0;

// Out-of-bounds flags (internal)
oob_attack = 0;
oob_release = 0;
oob_depth = 0;

// Limiter state variables
limiter_prev_l = 0;
limiter_prev_r = 0;
limiter_oversample_l1 = 0;
limiter_oversample_l2 = 0;
limiter_oversample_r1 = 0;
limiter_oversample_r2 = 0;


// Math constants
eps = 0.000000000000000000000000000001;
pi = 3.141592653589793;

// Helper function for tanh (hyperbolic tangent)
function tanh(x) (
  x > 10 ? 1 : (
    x < -10 ? -1 : (
      (exp(2*x) - 1) / (exp(2*x) + 1)
    )
  )
);

// Helper function for atan (arctangent)
function atan(x) (
  abs(x) > 1 ? (
    x > 0 ? pi/2 - atan(1/x) : -pi/2 - atan(1/x)
  ) : (
    // Taylor series approximation for |x| <= 1
    x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7
  )
);

// Helper function for pow (power function)
function pow(base, exponent) (
  base > 0 ? exp(exponent * log(base)) : (
    base == 0 ? (exponent > 0 ? 0 : 1) : (
      // Handle negative base (assuming integer exponent)
      exp(exponent * log(abs(base))) * (exponent % 2 == 0 ? 1 : -1)
    )
  )
);

// Feedback detection state
feedback_l_prev = 0;
feedback_r_prev = 0;

// Display state
current_input_db = GRAPH_MIN_DB;
current_gr_db = 0;

//==============================================================================
// UTILITY FUNCTIONS
//==============================================================================

function db_to_linear(db) (
  exp(db * LOG_10_20)
);

function linear_to_db(linear) (
  linear > 0 ? log(linear) * LOG10_20 : -150
);

function clamp(value, min_val, max_val) (
  max(min_val, min(max_val, value))
);

//==============================================================================
// GRAPH COORDINATE FUNCTIONS
//==============================================================================

function db_to_graph_x(db) (
  GRAPH_X + (db - GRAPH_MIN_DB) / GRAPH_RANGE_DB * GRAPH_SIZE
);

function db_to_graph_y(db) (
  GRAPH_Y + GRAPH_SIZE - (db - GRAPH_MIN_DB) / GRAPH_RANGE_DB * GRAPH_SIZE
);

function graph_x_to_db(x) (
  (x - GRAPH_X) / GRAPH_SIZE * GRAPH_RANGE_DB + GRAPH_MIN_DB
);

function graph_y_to_db(y) (
  GRAPH_MAX_DB - (y - GRAPH_Y) / GRAPH_SIZE * GRAPH_RANGE_DB
);

function is_point_in_graph(x, y) (
  x >= GRAPH_X && x <= GRAPH_X + GRAPH_SIZE && 
  y >= GRAPH_Y && y <= GRAPH_Y + GRAPH_SIZE
);

//==============================================================================
// GRAPH DATA MANAGEMENT
//==============================================================================

function init_graph_points() (
  // Initialize points on diagonal line (1:1 compression)
  graph_points[0] = GRAPH_MIN_DB; graph_points[1] = GRAPH_MIN_DB; graph_points[2] = 0;
  graph_points[3] = -18; graph_points[4] = -18; graph_points[5] = DEFAULT_KNEE_SIZE;
  graph_points[6] = -6;  graph_points[7] = -6;  graph_points[8] = DEFAULT_KNEE_SIZE;
  graph_points[9] = 6;   graph_points[10] = 6;  graph_points[11] = DEFAULT_KNEE_SIZE;
  graph_points[12] = 18; graph_points[13] = 18; graph_points[14] = DEFAULT_KNEE_SIZE;
  graph_points[15] = GRAPH_MAX_DB; graph_points[16] = GRAPH_MAX_DB; graph_points[17] = 0;
);

function sort_points() local(i, j, temp_in, temp_out, temp_knee) (
  i = 1;
  while (i < num_points - 2) (
    j = i + 1;
    while (j < num_points - 1) (
      graph_points[i*3] > graph_points[j*3] ? (
        temp_in = graph_points[i*3];
        temp_out = graph_points[i*3 + 1];
        temp_knee = graph_points[i*3 + 2];
        
        graph_points[i*3] = graph_points[j*3];
        graph_points[i*3 + 1] = graph_points[j*3 + 1];
        graph_points[i*3 + 2] = graph_points[j*3 + 2];
        
        graph_points[j*3] = temp_in;
        graph_points[j*3 + 1] = temp_out;
        graph_points[j*3 + 2] = temp_knee;
      );
      j += 1;
    );
    i += 1;
  );
);

function add_point(input_db, output_db) local(insert_pos, i, new_point_index) (
  num_points >= MAX_POINTS ? -1 : (
    insert_pos = num_points - 1;

    i = num_points;
    while (i > insert_pos) (
      graph_points[i*3] = graph_points[(i-1)*3];
      graph_points[i*3 + 1] = graph_points[(i-1)*3 + 1];
      graph_points[i*3 + 2] = graph_points[(i-1)*3 + 2];
      i -= 1;
    );

    graph_points[insert_pos*3] = input_db;
    graph_points[insert_pos*3 + 1] = output_db;
    graph_points[insert_pos*3 + 2] = DEFAULT_KNEE_SIZE;

    num_points += 1;
    sort_points();

    // Find the new index of the added point after sorting
    new_point_index = 0;
    i = 0;
    while (i < num_points) (
      abs(graph_points[i*3] - input_db) < 0.01 && abs(graph_points[i*3 + 1] - output_db) < 0.01 ? (
        new_point_index = i;
        i = num_points; // break
      ) : (
        i += 1;
      );
    );
    new_point_index;
  );
);

function delete_point(point_index) local(i) (
  point_index <= 0 || point_index >= num_points - 1 || num_points <= MIN_POINTS ? 0 : (
    i = point_index;
    while (i < num_points - 1) (
      graph_points[i*3] = graph_points[(i+1)*3];
      graph_points[i*3 + 1] = graph_points[(i+1)*3 + 1];
      graph_points[i*3 + 2] = graph_points[(i+1)*3 + 2];
      i += 1;
    );
    num_points -= 1;
    1;
  );
);

function find_point_at_mouse(x, y) local(i, point_x, point_y, dist_sq) (
  i = 0;
  while (i < num_points) (
    point_x = db_to_graph_x(graph_points[i*3]);
    point_y = db_to_graph_y(graph_points[i*3 + 1]);
    dist_sq = (x - point_x) * (x - point_x) + (y - point_y) * (y - point_y);
    dist_sq < MOUSE_CLICK_RADIUS * MOUSE_CLICK_RADIUS ? (
      i; // Return point index
    ) : (
      i += 1;
    );
  );
  -1; // No point found
);

//==============================================================================
// COMPRESSION CURVE MATH
//==============================================================================

function smooth_knee(x, threshold, knee) (
  knee > 0 ? (
    x <= threshold - knee/2 ? x :
    x >= threshold + knee/2 ? threshold + (x - threshold) :
    threshold - knee/2 + (knee/4) * (1 + sin(PI * (x - threshold) / knee))
  ) : (
    x <= threshold ? x : threshold + (x - threshold)
  )
);

function interpolate_compression_curve(input_db) local(i, x1, y1, x2, y2, t, knee1, knee2, output_db, knee_amount) (
  i = 0;
  while (i < num_points - 1 && graph_points[(i+1)*3] < input_db) (
    i += 1;
  );
  
  x1 = graph_points[i*3];
  y1 = graph_points[i*3 + 1];
  knee1 = graph_points[i*3 + 2];
  
  x2 = graph_points[(i+1)*3];
  y2 = graph_points[(i+1)*3 + 1];
  knee2 = graph_points[(i+1)*3 + 2];
  
  t = (input_db - x1) / (x2 - x1);
  output_db = y1 + t * (y2 - y1);
  
  knee_amount = knee1 + t * (knee2 - knee1);
  knee_amount > 0 ? (
    output_db = smooth_knee(output_db, y1 + t * (y2 - y1), knee_amount);
  );
  
  output_db
);

//==============================================================================
// FILTER PROCESSING
//==============================================================================

function calc_biquad_hp(freq) (
  w = 2 * PI * freq * SRATE_INV;
  cosw = cos(w);
  sinw = sin(w);
  alpha = sinw / sqrt(2);
  
  b0 = (1 + cosw) / 2;
  b1 = -(1 + cosw);
  b2 = (1 + cosw) / 2;
  a0 = 1 + alpha;
  a1 = -2 * cosw;
  a2 = 1 - alpha;
  
  a1 /= a0; a2 /= a0; b0 /= a0; b1 /= a0; b2 /= a0;
);

function calc_biquad_lp(freq) (
  w = 2 * PI * freq * SRATE_INV;
  cosw = cos(w);
  sinw = sin(w);
  alpha = sinw / sqrt(2);
  
  b0 = (1 - cosw) / 2;
  b1 = 1 - cosw;
  b2 = (1 - cosw) / 2;
  a0 = 1 + alpha;
  a1 = -2 * cosw;
  a2 = 1 - alpha;
  
  a1 /= a0; a2 /= a0; b0 /= a0; b1 /= a0; b2 /= a0;
);

//==============================================================================
// COMPRESSOR CHARACTER ALGORITHMS
//==============================================================================

function generate_tube_harmonics(input, saturation_amount, intensity_factor) local(x, x2, harmonic_content, scaled_saturation, clip_threshold) (
  scaled_saturation = saturation_amount * intensity_factor;
  x = input * (1 + scaled_saturation * 0.3);
  x2 = x * x;
  
  clip_threshold = 0.7 / (1 + scaled_saturation * 0.3);
  x > clip_threshold ? x = clip_threshold + (x - clip_threshold) / (1 + pow((x - clip_threshold) * 4 * intensity_factor, 2));
  x < -clip_threshold ? x = -clip_threshold + (x + clip_threshold) / (1 + pow((x + clip_threshold) * 4 * intensity_factor, 2));
  
  harmonic_content = x + x2 * scaled_saturation * 0.1 + x2 * x2 * scaled_saturation * 0.02;
  harmonic_content
);

function generate_fet_harmonics(input, compression_amount, intensity_factor) local(x, x3, x5, clipped, scaled_compression, clip_point) (
  scaled_compression = compression_amount * intensity_factor;
  x = input;
  x3 = x * x * x;
  x5 = x3 * x * x;

  scaled_compression > 0.3 / intensity_factor ? (
    clipped = x;
    clip_point = 0.8 / (1 + scaled_compression * 0.5);
    clipped > clip_point ? clipped = clip_point + (clipped - clip_point) * (0.1 / intensity_factor);
    clipped < -clip_point ? clipped = -clip_point + (clipped + clip_point) * (0.1 / intensity_factor);
    x = clipped;
  );

  x + x3 * scaled_compression * 0.08 + x5 * scaled_compression * 0.015
);

function apply_harmonic_processing(input, gr_amount, type, amount, drive, mix, even_boost, odd_boost) local(driven, processed, dry_signal, wet_signal, asymL, asymR, even_proc, odd_proc) (
  // No processing if harmonic type is off or amount is zero
  type == 0 || amount <= 0.0001 ? (
    input
  ) : (
    dry_signal = input;
    driven = input * drive;

    type == 1 ? ( // Tube Even
      processed = tanh(abs(driven)) * (driven < 0 ? -1 : 1);
      even_proc = processed * (1 + even_boost);
      processed = even_proc;
    ) : type == 2 ? ( // Tube Odd
      processed = tanh(driven);
      odd_proc = processed * (1 + odd_boost);
      processed = odd_proc;
    ) : type == 3 ? ( // Tube Both
      even_proc = tanh(abs(driven)) * (driven < 0 ? -1 : 1) * (1 + even_boost);
      odd_proc = tanh(driven) * (1 + odd_boost);
      processed = 0.5 * (even_proc + odd_proc);
    ) : ( // Tape Saturation
      asymL = driven * (driven > 0 ? 1.02 : 0.98);
      processed = atan(asymL) / (pi/2);
      // Apply even/odd boost to tape saturation components
      processed = processed * (1 + 0.5 * (even_boost + odd_boost));
    );

    // Scale back by drive to maintain levels
    processed = processed / max(drive, 1);

    // Apply amount (intensity) - this is driven by gain reduction amount
    intensity = amount * (1 + gr_amount * 0.5); // More harmonics with more GR
    wet_signal = dry_signal + intensity * (processed - dry_signal);

    // Final dry/wet mix
    dry_signal * (1 - mix) + wet_signal * mix
  )
);

function soft_clip_limiter(input, prev_sample) local(oversample1, oversample2, peak_detected, limited) (
  // 2x oversampling for inter-sample peak detection
  oversample1 = (input + prev_sample) * 0.5;
  oversample2 = input;

  // Detect peaks above threshold
  peak_detected = max(abs(oversample1), abs(oversample2)) > 0.95;

  peak_detected ? (
    // Soft clipping using tanh
    limited = tanh(input * 0.95) * (1.0 / tanh(0.95));
  ) : (
    limited = input;
  );

  limited
);

function update_compression_history(current_gr, dt, intensity_factor) (
  history_rate = 0.001 * intensity_factor;
  compression_history = compression_history * (1 - history_rate) + abs(current_gr) * history_rate;
  
  abs(current_gr) > 0.1 ? (
    program_release_timer = min(program_release_timer + dt * 2 * intensity_factor, 1.0);
  ) : (
    program_release_timer = max(program_release_timer - dt * 0.5 / intensity_factor, 0);
  );
);

function apply_compressor_character(gain_reduction, type, input_level, dt, intensity_factor) local(scaled_intensity, saturation_rate, decay_rate, input_change, transient_sensitivity, transient_decay, target_charge, charge_rate, base_discharge_rate, discharge_rate, atk_coef, rel_coef, relF, relS, bl, prog, rel_ms, r1, r2, r3, det_delta, transient_boost, target, rf, rs, drive, sat, sat_effect_dB) (
  scaled_intensity = intensity_factor;
  update_compression_history(gain_reduction, dt, scaled_intensity);

  type == 0 ? ( // Clean Digital - no character modifications
    gain_reduction
  ) : type == 1 ? ( // Varimu (preserve existing)
    saturation_rate = 0.0005 * scaled_intensity;
    decay_rate = 0.9995 - (scaled_intensity - 1) * 0.0002;
    tube_saturation = tube_saturation * decay_rate + abs(gain_reduction) * saturation_rate;
    varimu_release_factor = 1 + compression_history * 1.5 * scaled_intensity + tube_saturation * 1.0 * scaled_intensity;
    gain_reduction
  ) : type == 2 ? ( // Bridged Diode
    atk_coef = exp(-1/(0.0003*srate));
    relF = exp(-1/(0.04*srate));
    relS = exp(-1/(0.4*srate));
    bl = clamp(abs(gain_reduction)/24, 0, 1);
    gain_reduction < bridged_diode_env ?
      (bridged_diode_env = atk_coef*bridged_diode_env + (1-atk_coef)*gain_reduction) :
      (bridged_diode_env = bl*(relS*bridged_diode_env + (1-relS)*gain_reduction) + (1-bl)*(relF*bridged_diode_env + (1-relF)*gain_reduction));
    bridged_diode_env
  ) : type == 3 ? ( // VCA
    atk_coef = exp(-1/(0.001*srate));
    prog = clamp(input_level*10, 0, 1);
    rel_ms = 0.06*(1 - 0.6*prog) + 0.4*(0.6*prog);
    rel_coef = exp(-1/(rel_ms*srate));
    gain_reduction < vca_env ?
      (vca_env = atk_coef*vca_env + (1-atk_coef)*gain_reduction) :
      (vca_env = rel_coef*vca_env + (1-rel_coef)*gain_reduction);
    vca_env
  ) : type == 4 ? ( // PWM/Fairchild
    atk_coef = exp(-1/(0.01*srate));
    r1 = exp(-1/(0.06*srate));
    r2 = exp(-1/(0.2*srate));
    r3 = exp(-1/(0.8*srate));
    gain_reduction < pwm_env ?
      (pwm_env = atk_coef*pwm_env + (1-atk_coef)*gain_reduction) :
      (pwm_env = r3*(r2*(r1*pwm_env + (1-r1)*gain_reduction) + (1-r2)*gain_reduction) + (1-r3)*gain_reduction);
    pwm_env
  ) : type == 5 ? ( // FET (1176-like) - updated from old FET
    atk_coef = exp(-1/(0.00015*srate));
    rel_coef = exp(-1/(0.05*srate));
    det_delta = linear_to_db(input_level) - prev_detector_db;
    transient_boost = det_delta > 3 ? min(det_delta*0.6, 6) : 0;
    target = gain_reduction - transient_boost;
    target < fet_env ?
      (fet_env = atk_coef*fet_env + (1-atk_coef)*target) :
      (fet_env = rel_coef*fet_env + (1-rel_coef)*target);
    prev_detector_db = linear_to_db(input_level);
    fet_env
  ) : type == 6 ? ( // Optical (LA-2A-like) - updated from old Optical
    atk_coef = exp(-1/(0.018*srate));
    rf = exp(-1/(0.12*srate));
    rs = exp(-1/(0.9*srate));
    gain_reduction < optical_env ?
      (optical_env = atk_coef*optical_env + (1-atk_coef)*gain_reduction) :
      (optical_env = rs*(rf*optical_env + (1-rf)*gain_reduction) + (1-rs)*gain_reduction);
    optical_env
  ) : ( // Default fallback
    gain_reduction
  )
);

//==============================================================================
// MOUSE INTERACTION HANDLERS
//==============================================================================

function handle_point_movement() local(new_input_db, new_output_db, i, old_input_db) (
  new_input_db = clamp(graph_x_to_db(mouse_x), GRAPH_MIN_DB, GRAPH_MAX_DB);
  new_output_db = clamp(graph_y_to_db(mouse_y), GRAPH_MIN_DB, GRAPH_MAX_DB);

  // Store old position for sorting lookup
  old_input_db = graph_points[selected_point*3];

  // Constrain corner points
  selected_point == 0 ? (
    new_input_db = GRAPH_MIN_DB;
    new_output_db = GRAPH_MIN_DB;
  ) : selected_point == num_points - 1 ? (
    new_input_db = GRAPH_MAX_DB;
    new_output_db = GRAPH_MAX_DB;
  );

  // Update point position
  graph_points[selected_point*3] = new_input_db;
  graph_points[selected_point*3 + 1] = new_output_db;

  // For middle points, handle sorting and find new index
  selected_point > 0 && selected_point < num_points - 1 ? (
    // Only sort if input position actually changed significantly
    abs(new_input_db - old_input_db) > 0.1 ? (
      sort_points();

      // Find the moved point's new index
      i = 0;
      while (i < num_points) (
        abs(graph_points[i*3] - new_input_db) < 0.01 && abs(graph_points[i*3 + 1] - new_output_db) < 0.01 ? (
          selected_point = i;
          i = num_points; // break
        ) : (
          i += 1;
        );
      );
    );
  );
);

function handle_knee_adjustment() local(knee_delta) (
  knee_delta = (mouse_y - mouse_y_prev) * 0.05;
  graph_points[selected_point*3 + 2] = clamp(graph_points[selected_point*3 + 2] + knee_delta, 0, 10);
);

function handle_point_addition() local(new_input_db, new_output_db) (
  new_input_db = clamp(graph_x_to_db(mouse_x), GRAPH_MIN_DB, GRAPH_MAX_DB);
  new_output_db = clamp(graph_y_to_db(mouse_y), GRAPH_MIN_DB, GRAPH_MAX_DB);
  add_point(new_input_db, new_output_db);
);

function handle_point_deletion() local(point_to_delete) (
  point_to_delete = find_point_at_mouse(mouse_x, mouse_y);
  point_to_delete > 0 && point_to_delete < num_points - 1 ? (
    delete_point(point_to_delete);
  );
);

function process_mouse_input() (
  mouse_cap & 1 ? ( // Left mouse button pressed
    !mouse_down ? (
      // Mouse just pressed down
      mouse_down = 1;
      mouse_moved = 0; // Track if mouse has moved during this click

      mouse_cap & 16 ? ( // Alt+click = delete point
        handle_point_deletion();
        selected_point = -1;
      ) : (
        // Normal click - find point under mouse
        selected_point = find_point_at_mouse(mouse_x, mouse_y);
      );

      mouse_x_prev = mouse_x;
      mouse_y_prev = mouse_y;
    ) : (
      // Mouse is being held down
      // Check if mouse has moved enough to be considered a drag
      abs(mouse_x - mouse_x_prev) > 2 || abs(mouse_y - mouse_y_prev) > 2 ? (
        mouse_moved = 1;
      );

      selected_point >= 0 ? (
        // We have a selected point
        mouse_moved ? (
          // Mouse has moved - drag the point
          mouse_cap & 4 || mouse_cap & 8 || mouse_cap & 32 ? (
            // Ctrl/Shift/Cmd + drag = adjust knee
            handle_knee_adjustment();
          ) : (
            // Normal drag = move point
            handle_point_movement();
          );
        );
        // If mouse hasn't moved yet, do nothing (wait for movement)
      );

      mouse_x_prev = mouse_x;
      mouse_y_prev = mouse_y;
    );
  ) : mouse_cap & 2 ? ( // Right mouse button
    !mouse_down ? (
      handle_point_deletion();
    );
  ) : (
    // Mouse button released
    mouse_down == 1 && !mouse_moved && selected_point == -1 ? (
      // This was a click (not drag) in empty space - add point
      is_point_in_graph(mouse_x, mouse_y) ? (
        selected_point = handle_point_addition();
      );
    );

    // Reset state
    mouse_down = 0;
    selected_point = -1;
    mouse_moved = 0;
  );
);

//==============================================================================
// GRAPHICS RENDERING
//==============================================================================

function draw_grid() local(i, x_pos, y_pos) (
  gfx_set(0.4, 0.4, 0.4, 1);
  i = 0;
  while (i <= 6) (
    x_pos = GRAPH_X + i * GRAPH_SIZE / 6;
    y_pos = GRAPH_Y + i * GRAPH_SIZE / 6;
    gfx_line(x_pos, GRAPH_Y, x_pos, GRAPH_Y + GRAPH_SIZE);
    gfx_line(GRAPH_X, y_pos, GRAPH_X + GRAPH_SIZE, y_pos);
    i += 1;
  );
);

function draw_compression_curves() local(i, input_db, output_db, graph_y_pos, actual_input_db, adjusted_input_db, raw_output_db, effective_output_db) (
  // Main compression curve
  gfx_set(1, 0.8, 0.2, 1);
  i = 0;
  while (i < GRAPH_SIZE) (
    input_db = graph_x_to_db(GRAPH_X + i);
    output_db = interpolate_compression_curve(input_db);
    graph_y_pos = db_to_graph_y(output_db);
    i == 0 ? gfx_x = GRAPH_X : gfx_lineto(GRAPH_X + i, graph_y_pos);
    i += 1;
  );
  
  // Effective curve with global offset
  global_offset_db != 0 ? (
    gfx_set(1, 0.6, 0.8, 0.8);
    i = 0;
    while (i < GRAPH_SIZE) (
      actual_input_db = graph_x_to_db(GRAPH_X + i);
      adjusted_input_db = actual_input_db - global_offset_db;
      raw_output_db = interpolate_compression_curve(adjusted_input_db);
      effective_output_db = raw_output_db + global_offset_db;
      graph_y_pos = db_to_graph_y(effective_output_db);
      i == 0 ? gfx_x = GRAPH_X : gfx_lineto(GRAPH_X + i, graph_y_pos);
      i += 1;
    );
  );
);

function draw_knee_curves() local(i, point_x, point_y, knee_size, input_center, output_center, knee_range, curve_points, j, t, test_input, knee_factor, smooth_factor, test_output, curve_x, curve_y, first_point) (
  i = 0;
  while (i < num_points) (
    knee_size = graph_points[i*3 + 2];
    knee_size > 0 ? (
      gfx_set(0.7, 0.7, 1, 0.8);
      input_center = graph_points[i*3];
      output_center = graph_points[i*3 + 1];
      knee_range = knee_size;
      
      curve_points = 20;
      j = 0;
      first_point = 1;
      while (j < curve_points) (
        t = (j - curve_points/2) / (curve_points/2);
        test_input = input_center + t * knee_range;
        
        test_input >= input_center - knee_range/2 && test_input <= input_center + knee_range/2 ? (
          knee_factor = (test_input - input_center) / knee_range;
          smooth_factor = 0.5 + 0.5 * sin(knee_factor * PI);
          test_output = output_center + (test_input - input_center) * smooth_factor;
          
          curve_x = db_to_graph_x(test_input);
          curve_y = db_to_graph_y(test_output);
          
          first_point ? (
            gfx_x = curve_x; gfx_y = curve_y;
            first_point = 0;
          ) : (
            gfx_lineto(curve_x, curve_y);
          );
        );
        j += 1;
      );
    );
    i += 1;
  );
);

function draw_graph_points() local(i, point_x, point_y, knee_size) (
  i = 0;
  while (i < num_points) (
    point_x = db_to_graph_x(graph_points[i*3]);
    point_y = db_to_graph_y(graph_points[i*3 + 1]);
    knee_size = graph_points[i*3 + 2];
    
    // Knee indicator circle
    knee_size > 0 ? (
      gfx_set(0.5, 0.5, 1, 0.3);
      gfx_circle(point_x, point_y, 6 + knee_size * 3, 0);
    );
    
    // Point color
    (i == 0 || i == num_points - 1) ? (
      gfx_set(0.9, 0.9, 0.6, 1);
    ) : (
      gfx_set(1, 1, 1, 1);
    );
    
    gfx_circle(point_x, point_y, 6, 1);
    i += 1;
  );
);

function draw_level_indicators() local(input_x, adjusted_input_for_display, input_x_adjusted, input_y_on_unity, input_y_on_curve, input_y_raw_curve) (
  input_x = db_to_graph_x(current_input_db);
  adjusted_input_for_display = current_input_db - global_offset_db;
  input_x_adjusted = db_to_graph_x(adjusted_input_for_display);
  
  input_y_on_unity = db_to_graph_y(current_input_db);
  input_y_on_curve = db_to_graph_y(interpolate_compression_curve(adjusted_input_for_display) + global_offset_db);
  
  gfx_set(0, 1, 0, 0.8);
  gfx_circle(input_x, input_y_on_unity, 4, 1);
  
  gfx_set(1, 0, 0, 0.8);
  gfx_circle(input_x, input_y_on_curve, 4, 1);
  
  global_offset_db != 0 ? (
    gfx_set(1, 1, 0, 0.6);
    input_y_raw_curve = db_to_graph_y(interpolate_compression_curve(adjusted_input_for_display));
    gfx_circle(input_x_adjusted, input_y_raw_curve, 3, 1);
  );
);

function draw_gain_reduction_meter() local(gr_meter_x, gr_meter_y, gr_meter_w, gr_meter_h, gr_height) (
  gr_meter_x = GRAPH_X + GRAPH_SIZE + 20;
  gr_meter_y = GRAPH_Y;
  gr_meter_w = 30;
  gr_meter_h = GRAPH_SIZE;
  
  gfx_set(0.2, 0.2, 0.2, 1);
  gfx_rect(gr_meter_x, gr_meter_y, gr_meter_w, gr_meter_h);
  
  current_gr_db < 0 ? (
    gr_height = abs(current_gr_db) / abs(max_gr_db) * gr_meter_h;
    gfx_set(1, 0.5, 0, 1);
    gfx_rect(gr_meter_x, gr_meter_y + gr_meter_h - gr_height, gr_meter_w, gr_height);
  );
);

function draw_labels_and_info() (
  gfx_set(1, 1, 1, 1);
  gfx_x = GRAPH_X; gfx_y = GRAPH_Y + GRAPH_SIZE + 10;
  gfx_drawstr("Input Level (dB)");
  
  gfx_x = GRAPH_X - 40; gfx_y = GRAPH_Y - 10;
  gfx_drawstr("");
  
  gfx_x = GRAPH_X + GRAPH_SIZE + 20; gfx_y = GRAPH_Y - 20;
  gfx_drawstr("GR");
  
  global_offset_db != 0 ? (
    gfx_set(1, 1, 0.6, 1);
    gfx_x = GRAPH_X + GRAPH_SIZE + 60; gfx_y = GRAPH_Y + 20;
    gfx_printf("Offset: %+.1f dB", global_offset_db);
  );
  
  gfx_set(0.8, 0.8, 1, 1);
  gfx_x = GRAPH_X; gfx_y = GRAPH_Y + GRAPH_SIZE + 30;
  gfx_printf("Points: %d/%d", num_points, MAX_POINTS);
  
  gfx_set(0.7, 0.7, 0.7, 1);
  gfx_x = GRAPH_X; gfx_y = GRAPH_Y + GRAPH_SIZE + 45;
  gfx_drawstr("Click empty: Add | Right-click/Alt+click point: Delete | Ctrl+Drag: Knee");
);

//==============================================================================
// MAIN SECTIONS
//==============================================================================


@slider

// Update filter coefficients
calc_biquad_hp(hp_freq);
hp_b0 = b0; hp_b1 = b1; hp_b2 = b2; hp_a1 = a1; hp_a2 = a2;

calc_biquad_lp(lp_freq);
lp_b0 = b0; lp_b1 = b1; lp_b2 = b2; lp_a1 = a1; lp_a2 = a2;

// Calculate time constants
rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);
hold_samples = floor(hold_ms * 0.001 * srate);

attack_coeff = attack_ms > 0 ? exp(-1000 / (attack_ms * srate)) : 0;
release_coeff = release_ms > 0 ? exp(-1000 / (release_ms * srate)) : 0;

attack_curve != 0 ? attack_coeff = pow(attack_coeff, pow(2, attack_curve));
release_curve != 0 ? release_coeff = pow(release_coeff, pow(2, release_curve));

makeup_gain_linear = db_to_linear(makeup_gain_db);
over_the_top_factor = over_the_top * 0.01;

// Set plugin delay compensation
lookahead_samples > 0 ? (
  pdc_delay = lookahead_samples;
  pdc_bot_ch = 0;
  pdc_top_ch = num_ch;
) : (
  pdc_delay = 0;
);

@gfx 600 700

// Initialize graph points if they don't exist or are invalid
// Force initialization when graph appears empty or uninitialized
!graph_initialized || num_points < MIN_POINTS || num_points > MAX_POINTS || num_points == 0 ? (
  init_graph_points();
  graph_initialized = 1;
);

gfx_clear = 0x202020;

// Draw graph background
gfx_set(0.3, 0.3, 0.3, 1);
gfx_rect(GRAPH_X, GRAPH_Y, GRAPH_SIZE, GRAPH_SIZE);

// Draw unity line
gfx_set(0.6, 0.6, 0.6, 1);
gfx_line(GRAPH_X, GRAPH_Y + GRAPH_SIZE, GRAPH_X + GRAPH_SIZE, GRAPH_Y);

// Render all graph elements
draw_grid();
draw_compression_curves();
draw_knee_curves();
draw_graph_points();
draw_level_indicators();
draw_gain_reduction_meter();
draw_labels_and_info();

// Handle user interaction
process_mouse_input();

@sample

// Store original signals
input_l_orig = spl0;
input_r_orig = num_ch >= 2 ? spl1 : spl0;

// Select detection source - feedforward vs feedback
detection_mode > 0.5 ? (
  // Feedforward mode: detect from current input
  detect_l = use_sidechain && num_ch >= 3 ? spl2 : spl0;
  detect_r = use_sidechain && num_ch >= 4 ? spl3 : (num_ch >= 2 ? spl1 : spl0);
) : (
  // Feedback mode: detect from previous output (stored in feedback_l/feedback_r)
  detect_l = use_sidechain && num_ch >= 3 ? spl2 : (feedback_l_prev ? feedback_l_prev : spl0);
  detect_r = use_sidechain && num_ch >= 4 ? spl3 : (feedback_r_prev ? feedback_r_prev : (num_ch >= 2 ? spl1 : spl0));
);

// Apply filters
detect_l_filtered = hp_b0 * detect_l + hp_b1 * hp_x1_l + hp_b2 * hp_x2_l - hp_a1 * hp_y1_l - hp_a2 * hp_y2_l;
hp_x2_l = hp_x1_l; hp_x1_l = detect_l; hp_y2_l = hp_y1_l; hp_y1_l = detect_l_filtered;

detect_r_filtered = hp_b0 * detect_r + hp_b1 * hp_x1_r + hp_b2 * hp_x2_r - hp_a1 * hp_y1_r - hp_a2 * hp_y2_r;
hp_x2_r = hp_x1_r; hp_x1_r = detect_r; hp_y2_r = hp_y1_r; hp_y1_r = detect_r_filtered;

detect_l = lp_b0 * detect_l_filtered + lp_b1 * lp_x1_l + lp_b2 * lp_x2_l - lp_a1 * lp_y1_l - lp_a2 * lp_y2_l;
lp_x2_l = lp_x1_l; lp_x1_l = detect_l_filtered; lp_y2_l = lp_y1_l; lp_y1_l = detect_l;

detect_r = lp_b0 * detect_r_filtered + lp_b1 * lp_x1_r + lp_b2 * lp_x2_r - lp_a1 * lp_y1_r - lp_a2 * lp_y2_r;
lp_x2_r = lp_x1_r; lp_x1_r = detect_r_filtered; lp_y2_r = lp_y1_r; lp_y1_r = detect_r;

// Listen mode bypass
listen_to_sidechain ? (
  spl0 = detect_l;
  num_ch >= 2 ? spl1 = detect_r;
) : (

// RMS calculation with optional normalization
detect_squared = (detect_l * detect_l + detect_r * detect_r) * 0.5;
rms_sum -= rms_buffer[rms_pos];
rms_buffer[rms_pos] = detect_squared;
rms_sum += detect_squared;
rms_pos = (rms_pos + 1) % rms_samples;

rms_level = sqrt(rms_sum / rms_samples);

// Apply RMS normalization if enabled
rms_normalization > 0.5 ? (
  // Track running maximum for normalization
  rms_level > rms_max ? (rms_max = rms_level) : (rms_max = rms_max * 0.9999); // slow decay

  // Normalize RMS to 0..1 relative to running max
  normalized_rms = rms_level / (rms_max + eps);

  // Use peak detection for final level but shape with normalized RMS
  peak_level = max(abs(detect_l), abs(detect_r));
  detector_level = normalized_rms * peak_level;
) : (
  // Standard RMS or peak detection
  rms_size_ms > 0 ? (
    detector_level = rms_level;
  ) : (
    detector_level = max(abs(detect_l), abs(detect_r)); // peak mode when RMS window = 0
  );
);

input_level_db = linear_to_db(detector_level);
current_input_db = input_level_db;

// Apply compression curve with global offset
adjusted_input_db = input_level_db - global_offset_db;
target_output_db = interpolate_compression_curve(adjusted_input_db);
target_output_db += global_offset_db;
target_gr_db = target_output_db - input_level_db;

// Apply strength and curves
target_gr_db *= strength;

strength_curve != 0 ? (
  gr_factor = abs(target_gr_db) / abs(max_gr_db);
  curve_factor = pow(gr_factor, pow(2, strength_curve));
  target_gr_db *= curve_factor;
);

target_gr_db = max(max_gr_db, target_gr_db);

// Apply compressor character
dt = SRATE_INV;
average_input_level = average_input_level * 0.999 + rms_level * 0.001;
target_gr_db = apply_compressor_character(target_gr_db, compressor_type, rms_level, dt, over_the_top_factor);

// Global smoothing with program-dependent release
global_attack_coef = exp(-1/(max(0.0001, attack_ms*0.001)*srate));

// Attack always uses global attack coefficient
target_gr_db < global_smoothed_gain_db ? (
  global_smoothed_gain_db = global_attack_coef * global_smoothed_gain_db + (1 - global_attack_coef) * target_gr_db;
) : (
  // Release path: check if program-dependent mode is enabled
  prog_release_mode > 0.5 ? (
    // Program-dependent release: use release slider as multiplier (0..2000ms -> 0.5x..2.0x)
    rel_mult = 0.5 + (release_ms / 2000.0) * 1.5;

    // Base release coefficients adjusted by multiplier
    rel_fast = exp(-1/(base_fast_s * rel_mult * srate));
    rel_med = exp(-1/(base_med_s * rel_mult * srate));
    rel_slow = exp(-1/(base_slow_s * rel_mult * srate));

    gr_amount = abs(target_gr_db);
    det_delta = prev_detector_db - linear_to_db(detector_level);

    // Select release coefficient based on program release type
    rel_coef_use = rel_med;
    prog_release_type == 0 ? (
      // Level-dependent: deeper GR -> slower release
      blend_fast = clamp(1 - gr_amount / 6, 0, 1);
      blend_slow = clamp(gr_amount / 6, 0, 1);
      sum = blend_fast + blend_slow + eps;
      rel_coef_use = (blend_fast * rel_fast + blend_slow * rel_slow) / sum;
    ) : prog_release_type == 1 ? (
      // Rate-of-change: fast release if level drops rapidly
      rel_coef_use = det_delta > 3 ? rel_fast : rel_slow;
    ) : (
      // Hybrid: combine level base then bias by rate-of-change
      blend_fast = clamp(1 - gr_amount / 6, 0, 1);
      blend_slow = clamp(gr_amount / 6, 0, 1);
      base = (blend_fast * rel_fast + blend_slow * rel_slow) / max(blend_fast + blend_slow, eps);
      rel_coef_use = det_delta > 3 ? min(base, rel_fast) : max(base, rel_slow);
    );

    global_smoothed_gain_db = rel_coef_use * global_smoothed_gain_db + (1 - rel_coef_use) * target_gr_db;
  ) : (
    // Fixed release mode: use release slider as direct time
    fixed_rel_coef = exp(-1/(max(0.0001, release_ms*0.001) * srate));
    global_smoothed_gain_db = fixed_rel_coef * global_smoothed_gain_db + (1 - fixed_rel_coef) * target_gr_db;
  );
);

// Update previous detector level for next sample
prev_detector_db = linear_to_db(detector_level);

// Convert final gain reduction to linear for application
envelope_out = db_to_linear(global_smoothed_gain_db);
current_gr_db = global_smoothed_gain_db;

// Lookahead processing
lookahead_samples > 0 ? (
  lookahead_buffer_l[lookahead_pos] = input_l_orig;
  lookahead_buffer_r[lookahead_pos] = input_r_orig;
  
  delayed_pos = (lookahead_pos - lookahead_samples + max_lookahead_samples) % max_lookahead_samples;
  processed_l = lookahead_buffer_l[delayed_pos];
  processed_r = lookahead_buffer_r[delayed_pos];
  
  lookahead_pos = (lookahead_pos + 1) % max_lookahead_samples;
) : (
  processed_l = input_l_orig;
  processed_r = input_r_orig;
);

// Apply gain reduction
processed_l *= envelope_out * makeup_gain_linear;
processed_r *= envelope_out * makeup_gain_linear;

// Dedicated harmonic processing stage (driven by gain reduction amount)
gr_amount_normalized = abs(current_gr_db) / 30.0; // Normalize GR to 0..1 range
processed_l = apply_harmonic_processing(processed_l, gr_amount_normalized, harmonic_type, harmonic_amount, harmonic_drive, harmonic_mix, harmonic_even_boost, harmonic_odd_boost);
processed_r = apply_harmonic_processing(processed_r, gr_amount_normalized, harmonic_type, harmonic_amount, harmonic_drive, harmonic_mix, harmonic_even_boost, harmonic_odd_boost);

// Final mix
mix_dry = (100 - mix_wet) * 0.01;
mix_wet_factor = mix_wet * 0.01;

final_l = processed_l * mix_wet_factor + input_l_orig * mix_dry;
final_r = processed_r * mix_wet_factor + input_r_orig * mix_dry;

// Out-of-bounds calculation (after all processing is complete)
// Calculate effective attack/release times including all modifications
effective_attack_time = attack_ms;
effective_release_time = prog_release_mode > 0.5 ? (base_med_s * 1000) : release_ms; // Approximate calculation for display

oob_attack = (effective_attack_time < 0.2);
oob_release = (effective_release_time < 30);
oob_depth = (abs(current_gr_db) > 20);

// Apply soft-clipping brickwall limiter if enabled
brickwall_limiter > 0.5 ? (
  final_l = soft_clip_limiter(final_l, limiter_prev_l);
  final_r = soft_clip_limiter(final_r, limiter_prev_r);
  limiter_prev_l = final_l;
  limiter_prev_r = final_r;
);

// Output final results
spl0 = final_l;
num_ch >= 2 ? spl1 = final_r;

// Store feedback signals for next sample (for feedback detection mode)
feedback_l_prev = final_l;
feedback_r_prev = final_r;

); 