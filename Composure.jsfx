// Advanced Multi-Model Compressor JSFX - Modular Version
// Professional multi-algorithm compressor with interactive graph
// Features: multiple characters, feedforward/feedback, RMS normalization,
// program-dependent release, dedicated harmonic stage, soft-clipping limiter
// Author: Custom JSFX Generator
// Version: 3.0 - Advanced multi-model implementation (Modular)

desc:Advanced Multi-Model Compressor (Modular)


//==============================================================================
// SLIDER DEFINITIONS
//==============================================================================


// Time-related parameters (1-5)
slider1:attack_ms=10<0.05,100,0.1>-Attack (ms)
slider2:attack_curve=0<-2,2,0.01>-Attack Curve
slider3:release_ms=100<10,1000,1>Release (ms)
slider4:release_curve=-2<-2,2,0.01>-Release Curve
slider5:lookahead_ms=0<0,2000,0.1>-Lookahead (ms)

// RMS & Detection parameters (7-10)
slider7:rms_size_ms=0<1,100,0.1>-RMS Window (ms)
slider8:rms_normalization=0<0,1,1{Off,On}>-RMS Normalization
slider9:detection_mode=1<0,1,1{Feedback,Feedforward}>-Detection Mode
slider10:max_gr_db=-100<-100,0,1>-Max GR (dB)

// Filtering parameters (11-12)
// Sliders store actual frequency values - discrete steps
// HP: 0=Off (displayed as "Off" in UI), then 20Hz to 6kHz
// LP: 20Hz to 14kHz, then 0=Off (displayed as "Off" in UI, default)
slider11:hp_freq=0<0,6000,1{0,20,30,40,60,80,100,120,150,200,250,300,350,400,500,600,750,1000,1250,1500,1750,2000,2500,3000,3500,4000,5000,6000}>-HP Filter
slider12:lp_freq=16000<0,14000,1{20,30,40,60,80,100,120,150,200,250,300,350,400,500,600,750,1000,1250,1500,1750,2000,2500,3000,3500,4000,5000,6000,8000,10000,12000,14000,0}>-LP Filter

// Character & Harmonics parameters (13-20)
slider13:harmonic_type=0<0,7,1{Off,Tube Even,Tube Odd,Tube Both,Tape Saturation,Enhanced Tube,FET,Clean Drive}>-Harmonic Type
slider14:harmonic_amount=0<0,1,0.01>-Harmonic Amount
slider15:harmonic_drive=1<0.5,10,0.1>-Harmonic Drive
slider16:harmonic_mix=0<0,1,0.01>-Harmonic Mix
slider17:harmonic_even_boost=0<0,2,0.01>-Even
slider18:harmonic_odd_boost=0<0,2,0.01>-Odd

// Global parameters (19-25)
slider19:strength=1<0.25,10,0.1>Strength
slider20:global_offset_db=0<-30,30,0.1>-Global Offset (dB)
slider21:makeup_gain_db=0<-20,20,0.1>-Makeup Gain (dB)
slider22:compressor_type=0<0,6,1{Clean Digital,Varimu,Bridged Diode,VCA,PWM/Fairchild,FET,Optical}>-Compressor Type
slider23:use_sidechain=0<0,1,1{No,Yes}>-Use Sidechain
slider24:listen_to_sidechain=0<0,1,1{No,Yes}>-Listen to Detection Signal
slider25:prog_release_type=0<0,4,1{Fixed Release,Input-Dependent,GR Dependent,Rate-of-Change,Input-Dependent 2}>-Program Release Type
slider26:brickwall_limiter=1<0,1,1{Off,On}>-Brickwall Limiter

// Advanced Envelope parameters (27-30)
slider27:gr_blend_threshold_db=6<1,24,0.1>-GR Blend Threshold (dB)
slider28:input_level_threshold_db=-20<-80,0,0.1>-Input Level Threshold (dB)
slider29:input_level_threshold_2_db=-40<-80,0,0.1>-Input Level Threshold 2 (dB)
slider30:transient_detection=0<0,100,1>-Transient Detection (0=Off, 100=Max)
slider31:transient_threshold_db=-6<-80,0,0.1>-Transient Threshold (dB)

// SEARCH STOP

//==============================================================================
// INCLUDE MODULES
//==============================================================================

// For Claude: These are import, not @import or include or @include

// 01_Utils: Foundation utilities (no dependencies)
import 01_Utils/01_constants.jsfx-inc
import 01_Utils/02_math_utils.jsfx-inc
import 01_Utils/03_debug_logging.jsfx-inc
import 01_Utils/04_file_reading.jsfx-inc
import 01_Utils/05_memory.jsfx-inc
import 01_Utils/06_state.jsfx-inc
import 01_Utils/09_audio_objects.jsfx-inc
import 01_Utils/10_ui_objects.jsfx-inc
import 01_Utils/11_memory_objects.jsfx-inc
import 01_Utils/12_memory_manager.jsfx-inc
import 01_Utils/13_constants_objects.jsfx-inc
import 01_Utils/14_math_objects.jsfx-inc
import 01_Utils/15_debug_objects.jsfx-inc

// 02_InputProcessing: Input signal conditioning (depends on 01_Utils)
import 02_InputProcessing/01_dsp_utils.jsfx-inc
import 02_InputProcessing/02_filters.jsfx-inc
import 02_InputProcessing/03_audio_memory.jsfx-inc
import 02_InputProcessing/04_transient_detection.jsfx-inc
import 02_InputProcessing/05_dsp_objects.jsfx-inc
import 02_InputProcessing/06_transient_objects.jsfx-inc

// 03_Compression: Core compression engine (depends on 01_Utils, 02_InputProcessing)
import 03_Compression/01_compression_constants.jsfx-inc
import 03_Compression/02_graph_data_core.jsfx-inc
import 03_Compression/03_graph_curves.jsfx-inc
import 03_Compression/04_graph_cache.jsfx-inc
import 03_Compression/05_compression_core.jsfx-inc
import 03_Compression/06_gain_reduction.jsfx-inc
import 03_Compression/07_envelope.jsfx-inc
import 03_Compression/08_harmonic_models.jsfx-inc
import 03_Compression/09_audio_processing_chain.jsfx-inc
import 03_Compression/10_compression_memory.jsfx-inc
import 03_Compression/11_graph_objects.jsfx-inc
import 03_Compression/12_harmonic_objects.jsfx-inc

// 04_UI_Rendering: UI rendering components (depends on 01_Utils)
import 01_Utils/07_ui_constants.jsfx-inc
import 01_Utils/08_ui_utils.jsfx-inc
import 04_UI_Rendering/02_ui_memory.jsfx-inc
import 04_UI_Rendering/01_helpers.jsfx-inc
import 04_UI_Rendering/02_knobs.jsfx-inc
import 04_UI_Rendering/03_controls.jsfx-inc
import 04_UI_Rendering/04_debug.jsfx-inc
import 04_UI_Rendering/10_menu.jsfx-inc
import 04_UI_Rendering/05_header.jsfx-inc
import 04_UI_Rendering/11_threshold_lines.jsfx-inc
import 04_UI_Rendering/06_graph_cache.jsfx-inc
import 04_UI_Rendering/07_graph_curves.jsfx-inc
import 04_UI_Rendering/08_graph_meters.jsfx-inc
import 04_UI_Rendering/09_graph_display.jsfx-inc

// 05_UI_UserInteractions: User interaction handling (depends on 01_Utils, 04_UI_Rendering)
import 05_UI_UserInteractions/01_control_definitions.jsfx-inc
import 05_UI_UserInteractions/02_control_interactions.jsfx-inc
import 05_UI_UserInteractions/03_graph.jsfx-inc

// 06_UI_Orchestration: UI orchestration (depends on 01_Utils, 04_UI_Rendering, 05_UI_UserInteractions)
import 06_UI_Orchestration/01_ui_interaction.jsfx-inc
import 06_UI_Orchestration/02_ui_orchestration.jsfx-inc


//==============================================================================
// SERIALIZE
//==============================================================================

@serialize
// Prevent memory/variables from being cleared on @init
ext_noinit = 1.0;

// Serialize graph points data for persistence across plugin duplication and project saves
// This ensures graph points and curves are preserved when:
// - Duplicating the plugin instance
// - Copying/pasting the track
// - Saving and reopening the project
// - Restarting REAPER
file_var(0, graph_initialized);
file_var(0, num_points);

// Save all graph points
i = 0;
while (i < num_points) (
  file_var(0, graph_points[i*2]);     // input_db
  file_var(0, graph_points[i*2 + 1]); // output_db
  i += 1;
);

// Save curve data
i = 0;
while (i < num_points) (
  file_var(0, curve_amounts[i]);
  i += 1;
);

@init

//==============================================================================
// INITIALIZATION SEQUENCE
//==============================================================================

// 1. Read slider definitions from file FIRST (needed for memory allocation)
read_slider_definitions();

// 2. Initialize all constants, memory, and state variables
init_constants_objects();
init_math_objects();
init_debug_objects();
init_memory_objects();
init_memory_manager();
memory_manager_allocate_all();
init_state_variables();
init_audio_objects();
init_ui_objects();
init_dsp_objects();
init_transient_objects();
init_graph_objects();
init_harmonic_objects();

// 2.5. Initialize graph optimization constants (requires GRAPH_SIZE to be defined)
init_graph_optimization_constants();

// 3. Initialize stage control variables (now using audio objects)
audio_stage_set_enabled("input", 1);                    // Input stage (always needed)
audio_stage_set_enabled("detection_source", 1);         // Detection source selection
audio_stage_set_enabled("filtering", 1);                // Detection signal filtering (applies to active detection signal)
audio_stage_set_enabled("detection_analysis", 1);       // RMS detection and gain reduction calculation
audio_stage_set_enabled("character", 1);                // Character application
audio_stage_set_enabled("envelope", 1);                 // Envelope following
audio_stage_set_enabled("lookahead", 1);                // Lookahead processing
audio_stage_set_enabled("gain_reduction", 1);           // Gain reduction application
audio_stage_set_enabled("harmonics", 1);                // Harmonic processing
audio_stage_set_enabled("final_mix", 1);                // Final mix
audio_stage_set_enabled("limiter", 1);                  // Brickwall limiter
audio_stage_set_enabled("output", 1);                   // Output stage (always needed)

// Initialize slider processing flag (ensures @slider calculations run on first load)
slider_initialized = 0;

// Initialize makeup gain to unity (will be recalculated in @slider)
audio.output.state.makeup_gain_linear = 1.0;

// Initialize strength multiplier (will be recalculated in @slider)
audio.compression.state.strength_actual = strength * strength;

// Calculate limiter normalization constant (pre-calculated to avoid per-sample division)
audio.output.constants.limiter_tanh_norm = 1.0 / tanh(0.95);  // â‰ˆ 1.343

// 4. Initialize curve data
init_curve_data();

// 5. Set up control layout
setup_control_layout();

// 6. Initialize graph points (only on first load)
!graph_initialized ? (
  // Initialize with defaults (ext_noinit preserves values across reloads)
  num_points = 6;
  init_graph_points();
  invalidate_compression_threshold(); // Mark threshold for recalculation
  graph_initialized = 1;
);

// 7. Mark compression system as ready (prevents LUT race condition)
compression_init_complete = 1;

//==============================================================================
// ON SLIDER UPDATES
//==============================================================================

@slider

// Track which parameters actually changed
param_changed = 0;

// --- Filter Parameters (11-12) ---
// Sliders store actual frequency values directly in Hz
// hp_freq: 0 = Off, 1-6000 = filter frequency
// lp_freq: 20000 = Off, 80-19999 = filter frequency
(slider11 != hp_freq_prev || !slider_initialized) ? (
  hp_freq_prev = slider11;
  param_changed = 1;
);

(slider12 != lp_freq_prev || !slider_initialized) ? (
  lp_freq_prev = slider12;
  param_changed = 1;
);

// Filter coefficients are updated in @block for real-time response

// --- Timing Parameters (1-5) ---
(slider1 != attack_ms_prev || slider3 != release_ms_prev ||
 slider5 != lookahead_ms_prev ||
 slider7 != rms_size_ms_prev || slider2 != attack_curve_prev ||
 slider4 != release_curve_prev || !slider_initialized) ? (

  // Clear RMS buffer if window size changed
  slider7 != rms_size_ms_prev ? (
    clear_rms_state();
  );

  // Calculate sample counts
  rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
  lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);

  param_changed = 1;

  // Store for next comparison
  attack_ms_prev = slider1;
  release_ms_prev = slider3;
  lookahead_ms_prev = slider5;
  rms_size_ms_prev = slider7;
  attack_curve_prev = slider2;
  release_curve_prev = slider4;
);

// --- Makeup Gain (21) ---
(slider21 != makeup_gain_db_prev || !slider_initialized) ? (
  audio.output.state.makeup_gain_linear = db_to_linear(makeup_gain_db);
  makeup_gain_db_prev = slider21;
  param_changed = 1;
);


// --- Plugin Delay Compensation ---
// Cockos pattern: Calculate and set unconditionally every @slider execution
// This MUST run every time @slider executes (not just on change)
pdc_delay = min(lookahead_ms * 0.001 * srate, max_lookahead_samples) | 0;
pdc_delay > 0 ? (
  pdc_bot_ch = 0;
  pdc_top_ch = 2;  // Stereo channels (0=left, 1=right)
);

// --- Strength and Global Offset parameters ---
(slider19 != strength_prev || slider20 != global_offset_db_prev || !slider_initialized) ? (
  strength_prev = slider19;
  global_offset_db_prev = slider20;
  
  // Apply logarithmic/exponential transformation to strength for more pronounced effect
  // Using power of 2: strength=1 -> actual=1, strength=3 -> actual=9, strength=10 -> actual=100
  audio.compression.state.strength_actual = strength * strength;
  audio.compression.state.global_offset_db = global_offset_db;
  
  param_changed = 1;
  
  // Note: Strength is applied AFTER curve lookup in calculate_gain_reduction(),
  // so it doesn't affect the curve shape itself. No need to invalidate curve cache.
  // Global offset is applied at lookup time (shifts input level before curve lookup).
);

// Mark slider section as initialized (ensures all calculations run on first load)
slider_initialized = 1;

//==============================================================================
// ON BLOCK
//==============================================================================

@block

// Store block-level max values for histograms (captured during previous block)
// Convert detector level from linear to dB (once per block instead of per sample)
input_db_for_histogram = linear_to_db(max(audio.detection.state.level_block_max, audio.detection.constants.min_detector_level));
gr_db_for_histogram = audio.compression.state.gain_reduction_block_max;

// Reset max trackers for next block
audio.detection.state.level_block_max = audio.detection.constants.min_detector_level;
audio.compression.state.gain_reduction_block_max = 0;

// Update filter coefficients every block for real-time response
update_filter_coefficients();

// Update attack and release coefficients every block for real-time response
// Cache coefficients to avoid redundant calculations
audio_envelope_set_coeffs(
  attack_ms > 0 ? exp(-1000 / (attack_ms * srate)) : 0,
  release_ms > 0 ? exp(-1000 / (release_ms * srate)) : 0
);

// Cache frequently used calculations
srate_inv = 1.0 / srate;
attack_ms_srate = attack_ms * srate;
release_ms_srate = release_ms * srate;

// Apply curves with S-curve and exponential algorithms
attack_curve != 0 ? (
  attack_curve > 0 ? (
    // Positive curves (right): S-curve response - smooth, gradual onset
    curve_amount = attack_curve;
    s_curve_factor = 1.0 + curve_amount * 0.3; // Reduced from 0.6 to 0.3
    s_curve_factor *= (1.0 + curve_amount * 0.15); // Reduced from 0.3 to 0.15
    audio.envelope.state.attack_coeff = pow(audio.envelope.state.attack_coeff, s_curve_factor);
  ) : (
    // Negative curves (left): steep exponential response - fast, aggressive onset
    curve_amount = abs(attack_curve);
    audio.envelope.state.attack_coeff = pow(audio.envelope.state.attack_coeff, 1.0 - curve_amount * 0.3); // Reduced from 0.7 to 0.3
  );
);

release_curve != 0 ? (
  release_curve > 0 ? (
    // Positive curves (right): S-curve response - smooth, gradual recovery
    curve_amount = release_curve;
    s_curve_factor = 1.0 + curve_amount * 0.3; // Reduced from 0.6 to 0.3
    s_curve_factor *= (1.0 + curve_amount * 0.15); // Reduced from 0.3 to 0.15
    audio.envelope.state.release_coeff = pow(audio.envelope.state.release_coeff, s_curve_factor);
  ) : (
    // Negative curves (left): steep exponential response - fast, aggressive recovery
    curve_amount = abs(release_curve);
    audio.envelope.state.release_coeff = pow(audio.envelope.state.release_coeff, 1.0 - curve_amount * 0.3); // Reduced from 0.7 to 0.3
  );
);

// Update RMS parameters every block for real-time response
// Fix: Clear buffer when RMS window size changes to prevent stale data bug
new_rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
new_rms_samples != rms_samples ? (
  rms_samples = new_rms_samples;
  // Clear RMS state when window size changes (fixes bug with stale buffer data)
  menu_true_rms_enabled > 0.5 ? (
    clear_rms_state();  // Clear circular buffer for True RMS mode
  ) : (
    rms_smoothed_squared = 0;  // Reset exponential smoothing state
  );
) : (
  rms_samples = new_rms_samples;  // Update even if same (for safety)
);

// OPTIMIZATION: Cache RMS reciprocal to avoid per-sample division
rms_samples_inv = 1.0 / max(rms_samples, 1);

// OPTIMIZATION: Calculate power-of-2 size and bit mask for fast circular buffer (like lookahead)
// Bit masking (x & mask) is 3-5x faster than modulo (x % size)
// TEMPORARILY DISABLED: These variables are calculated but not used, and may cause performance issues
// rms_samples_pow2 = 1;
// while(rms_samples_pow2 < rms_samples) (rms_samples_pow2 *= 2);
// rms_mask = rms_samples_pow2 - 1;

// OPTIMIZATION: Pre-calculate RMS exponential smoothing coefficients (moved from @sample)
// Only needed when NOT using True RMS mode and RMS window > 0
menu_true_rms_enabled == 0 && rms_size_ms > 0 ? (
  rms_smoothing_coeff = exp(-1000.0 / (rms_size_ms * srate));
  rms_smoothing_one_minus = 1 - rms_smoothing_coeff;
);

// OPTIMIZATION: Cache harmonic drive compensation reciprocal to avoid per-sample division
drive_compensation_inv = 1.0 / max(harmonic_drive, 1);


//==============================================================================
// GFX RUNTIME
//==============================================================================

@gfx 2625 800 // Width: 2625 (75% of 3500), Height: 800 (increased to show debug panel at bottom)

// Update mouse state constants dynamically (evaluated every frame)
ui_mouse_update_state();

// Convert detector level to dB once per frame for UI display (instead of per-sample)
current_input_db = linear_to_db(max(audio.detection.state.level, audio.detection.constants.min_detector_level));

// Update histograms with block-max values (most efficient and smooth)
HISTOGRAM_ENABLED ? update_histogram_state(gr_db_for_histogram);
INPUT_HISTOGRAM_ENABLED ? update_input_histogram_state(input_db_for_histogram);

// Render main interface
render_complete_interface();

// Render debug information (controlled by menu_debug_enabled toggle in right-click menu)
debug_render();


//==============================================================================
// ON SAMPLE
//==============================================================================

@sample

// Process the complete audio chain using modular functions
process_complete_audio_chain();
