// Advanced Multi-Model Compressor JSFX - Modular Version
// Professional multi-algorithm compressor with interactive graph
// Features: multiple characters, feedforward/feedback, RMS normalization,
// program-dependent release, dedicated harmonic stage, soft-clipping limiter
// Author: Custom JSFX Generator
// Version: 3.0 - Advanced multi-model implementation (Modular)

desc:Advanced Multi-Model Compressor (Modular)


//==============================================================================
// SLIDER DEFINITIONS
//==============================================================================


// Time-related parameters (1-5)
slider1:attack_ms=10<0.05,100,0.1>Attack (ms)
slider2:attack_curve=0<-2,2,0.01>-Attack Curve
slider3:release_ms=100<10,1000,1>-Release (ms)
slider4:release_curve=-2<-2,2,0.01>-Release Curve
slider5:lookahead_ms=0<0,2000,0.1>Lookahead (ms)

// RMS & Detection parameters (7-10)
slider7:rms_size_ms=10<1,100,0.1>-RMS Window (ms)
slider8:rms_normalization=0<0,1,1{Off,On}>-RMS Normalization
slider9:detection_mode=1<0,1,1{Feedback,Feedforward}>-Detection Mode
slider10:max_gr_db=-100<-100,0,1>-Max GR (dB)

// Filtering parameters (11-12)
slider11:hp_freq=20<20,1000,1>-HP Filter (Hz)
slider12:lp_freq=20000<100,20000,10>-LP Filter (Hz)

// Character & Harmonics parameters (13-20)
slider13:harmonic_type=0<0,7,1{Off,Tube Even,Tube Odd,Tube Both,Tape Saturation,Enhanced Tube,FET,Clean Drive}>-Harmonic Type
slider14:harmonic_amount=0<0,1,0.01>-Harmonic Amount
slider15:harmonic_drive=1<0.5,10,0.1>-Harmonic Drive
slider16:harmonic_mix=0<0,1,0.01>-Harmonic Mix
slider17:harmonic_even_boost=0<0,2,0.01>-Even Harmonic Boost
slider18:harmonic_odd_boost=0<0,2,0.01>-Odd Harmonic Boost

// Global parameters (19-25)
slider19:strength=1<0.25,10,0.1>Strength
slider20:global_offset_db=0<-30,30,0.1>-Global Offset (dB)
slider21:makeup_gain_db=0<-20,20,0.1>-Makeup Gain (dB)
slider22:compressor_type=0<0,6,1{Clean Digital,Varimu,Bridged Diode,VCA,PWM/Fairchild,FET,Optical}>-Compressor Type
slider23:use_sidechain=0<0,1,1{No,Yes}>-Use Sidechain
slider24:listen_to_sidechain=0<0,1,1{No,Yes}>-Listen to Detection Signal
slider25:prog_release_type=0<0,3,1{Fixed Release,Input-Dependent,GR Dependent,Rate-of-Change}>-Program Release Type
slider26:brickwall_limiter=1<0,1,1{Off,On}>-Brickwall Limiter

// Stage Control parameters (27-31) - Control which processing stages are active
slider27:stage_filtering=1<0,1,1{Off,On}>-Detection Filtering
slider28:stage_harmonics=1<0,1,1{Off,On}>-Harmonic Processing
slider29:stage_lookahead=1<0,1,1{Off,On}>-Lookahead Processing
slider30:stage_character=1<0,1,1{Off,On}>-Character Processing
slider31:stage_limiter=1<0,1,1{Off,On}>-Brickwall Limiter

// Advanced Envelope parameters (32-35)
slider32:gr_blend_threshold_db=6<1,24,0.1>-GR Blend Threshold (dB)
slider33:input_level_threshold_db=-20<-80,0,0.1>-Input Level Threshold (dB)
slider34:transient_detection=0<0,100,1>-Transient Detection (0=Off, 100=Max)
slider35:transient_threshold_db=-6<-80,0,0.1>-Transient Threshold (dB)

// SEARCH STOP

//==============================================================================
// INCLUDE MODULES
//==============================================================================

// For Claude: These are import, not @import or include or @include

// 01_Utils: Foundation utilities (no dependencies)
import 01_Utils/01_constants.jsfx-inc
import 01_Utils/02_math_utils.jsfx-inc
import 01_Utils/03_debug_logging.jsfx-inc
import 01_Utils/04_file_reading.jsfx-inc
import 01_Utils/05_memory.jsfx-inc
import 01_Utils/06_state.jsfx-inc

// 02_InputProcessing: Input signal conditioning (depends on 01_Utils)
import 02_InputProcessing/01_dsp_utils.jsfx-inc
import 02_InputProcessing/02_filters.jsfx-inc
import 02_InputProcessing/04_transient_detection.jsfx-inc

// 03_Compression: Core compression engine (depends on 01_Utils, 02_InputProcessing)
import 03_Compression/01_compression_constants.jsfx-inc
import 03_Compression/02_graph_data_core.jsfx-inc
import 03_Compression/03_graph_curves.jsfx-inc
import 03_Compression/04_graph_cache.jsfx-inc
import 03_Compression/05_compression_core.jsfx-inc
import 03_Compression/06_gain_reduction.jsfx-inc
import 03_Compression/07_envelope.jsfx-inc
import 03_Compression/08_harmonic_models.jsfx-inc
import 03_Compression/09_audio_processing_chain.jsfx-inc

// 04_UI: All UI components (depends on 01_Utils, 03_Compression)
import 04_UI/01_ui_constants.jsfx-inc
import 04_UI/02_ui_utils.jsfx-inc
import 04_UI/03_ui_threshold_lines.jsfx-inc
import 04_UI/04_ui_interaction.jsfx-inc
import 04_UI/05_ui_rendering.jsfx-inc
import 04_UI/06_ui_controls.jsfx-inc
import 04_UI/07_ui_graph_cache.jsfx-inc
import 04_UI/08_ui_graph_curves.jsfx-inc
import 04_UI/09_ui_graph_meters.jsfx-inc
import 04_UI/10_ui_graph_display.jsfx-inc
import 04_UI/11_ui_orchestration.jsfx-inc


//==============================================================================
// SERIALIZE
//==============================================================================

@serialize
// Prevent memory/variables from being cleared on @init
ext_noinit = 1.0;

// Serialize graph points data for persistence across plugin duplication and project saves
// This ensures graph points and curves are preserved when:
// - Duplicating the plugin instance
// - Copying/pasting the track
// - Saving and reopening the project
// - Restarting REAPER
file_var(0, graph_initialized);
file_var(0, num_points);

// Save all graph points
i = 0;
while (i < num_points) (
  file_var(0, graph_points[i*2]);     // input_db
  file_var(0, graph_points[i*2 + 1]); // output_db
  i += 1;
);

// Save curve data
i = 0;
while (i < num_points) (
  file_var(0, curve_amounts[i]);
  i += 1;
);

@init

//==============================================================================
// INITIALIZATION SEQUENCE
//==============================================================================

// Clear and start debug logging
debug_clear();
debug_log("");
debug_log("=== PLUGIN INITIALIZATION ===");

// 1. Read slider definitions from file FIRST (needed for memory allocation)
read_slider_definitions();

slider_names_loaded ? (
  debug_logf("Loaded %d slider definitions", slider_names_count);
) : (
  debug_log("ERROR: Failed to load slider definitions");
);

// 2. Initialize all constants, memory, and state variables
allocate_memory();
init_state_variables();

// 3. Initialize stage control variables
debug_log("Initializing stage controls...");
stage_input = 1;                    // Input stage (always needed)
stage_detection_source = 1;         // Detection source selection
stage_filtering = 1;      // Detection signal filtering (applies to active detection signal)
stage_detection_analysis = 1;       // RMS detection and gain reduction calculation
stage_character = 1;                // Character application
stage_envelope = 1;                 // Envelope following
stage_lookahead = 1;                // Lookahead processing
stage_gain_reduction = 1;           // Gain reduction application
stage_harmonics = 1;                // Harmonic processing
stage_final_mix = 1;                // Final mix
stage_limiter = 1;                  // Brickwall limiter
stage_output = 1;                   // Output stage (always needed)

stage_filtering_prev = -1;
stage_harmonics_prev = -1;
stage_lookahead_prev = -1;
stage_character_prev = -1;
stage_limiter_prev = -1;

// Initialize slider processing flag (ensures @slider calculations run on first load)
slider_initialized = 0;

// 4. Initialize curve data
init_curve_data();

// 5. Set up control layout
setup_control_layout();

// 6. Initialize graph points (only on first load)
debug_log("Initializing graph...");
!graph_initialized ? (
  // Initialize with defaults (ext_noinit preserves values across reloads)
  num_points = 6;
  init_graph_points();
  invalidate_compression_threshold(); // Mark threshold for recalculation
  graph_initialized = 1;
  debug_log("Initialized default graph points");
);
debug_logf("Graph ready with %d points", num_points);

// 7. Mark compression system as ready (prevents LUT race condition)
compression_init_complete = 1;

// 8. Initialization complete
debug_separator();
debug_log("INITIALIZATION COMPLETE");
debug_logf("Total debug messages: %d", debug_get_message_count());

//==============================================================================
// ON SLIDER UPDATES
//==============================================================================

@slider

// Track which parameters actually changed
param_changed = 0;

// --- Filter Parameters (11-12) ---
// Filter coefficients are updated in @block for real-time response

// --- Timing Parameters (1-5) ---
(slider1 != attack_ms_prev || slider3 != release_ms_prev ||
 slider5 != lookahead_ms_prev ||
 slider7 != rms_size_ms_prev || slider2 != attack_curve_prev ||
 slider4 != release_curve_prev || !slider_initialized) ? (

  // Clear RMS buffer if window size changed
  slider7 != rms_size_ms_prev ? (
    clear_rms_state();
  );

  // Calculate sample counts
  rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
  lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);

  param_changed = 1;

  // Store for next comparison
  attack_ms_prev = slider1;
  release_ms_prev = slider3;
  lookahead_ms_prev = slider5;
  rms_size_ms_prev = slider7;
  attack_curve_prev = slider2;
  release_curve_prev = slider4;
);

// --- Makeup Gain (21) ---
(slider21 != makeup_gain_db_prev || !slider_initialized) ? (
  makeup_gain_linear = db_to_linear(makeup_gain_db);
  makeup_gain_db_prev = slider21;
  param_changed = 1;
);


// --- Plugin Delay Compensation ---
// Cockos pattern: Calculate and set unconditionally every @slider execution
// This MUST run every time @slider executes (not just on change)
pdc_delay = min(lookahead_ms * 0.001 * srate, max_lookahead_samples) | 0;
pdc_delay > 0 ? (
  pdc_bot_ch = 0;
  pdc_top_ch = 2;  // Stereo channels (0=left, 1=right)
);

// --- Stage Control Parameters (27-31) ---
(stage_filtering != stage_filtering_prev || slider28 != stage_harmonics_prev ||
 slider29 != stage_lookahead_prev || slider30 != stage_character_prev ||
 slider31 != stage_limiter_prev || !slider_initialized) ? (
  // stage_filtering is automatically set by slider27
  stage_harmonics = slider28;
  stage_lookahead = slider29;
  stage_character = slider30;
  stage_limiter = slider31;

  stage_filtering_prev = stage_filtering;
  stage_harmonics_prev = slider28;
  stage_lookahead_prev = slider29;
  stage_character_prev = slider30;
  stage_limiter_prev = slider31;

  param_changed = 1;
);

// --- Curve-affecting parameters ---
(slider19 != strength_prev || slider20 != global_offset_db_prev || !slider_initialized) ? (
  strength_prev = slider19;
  global_offset_db_prev = slider20;
  
  // Apply logarithmic/exponential transformation to strength for more pronounced effect
  // Using power of 2: strength=1 -> actual=1, strength=3 -> actual=9, strength=10 -> actual=100
  strength_actual = strength * strength;
  
  param_changed = 1;
  
  // Only strength affects the curve, not global_offset (which is applied at lookup time)
  slider19 != strength_prev ? (
    invalidate_curve_cache();
    invalidate_compression_lut();
  );
);

// Mark slider section as initialized (ensures all calculations run on first load)
slider_initialized = 1;

// Debug parameter changes
param_changed ? (
  debug_logf("Parameters updated (count: %d)", param_changed);
);

//==============================================================================
// ON BLOCK
//==============================================================================

@block

// Store block-level max values for histograms (captured during previous block)
// No calculation needed - already tracked in @sample section
input_db_for_histogram = input_db_block_max;
gr_db_for_histogram = gr_db_block_max;

// Reset max trackers for next block
input_db_block_max = GRAPH_MIN_DB;
gr_db_block_max = 0;

// Update filter coefficients every block for real-time response
update_filter_coefficients();

// Update attack and release coefficients every block for real-time response
// Cache coefficients to avoid redundant calculations
attack_coeff = attack_ms > 0 ? exp(-1000 / (attack_ms * srate)) : 0;
release_coeff = release_ms > 0 ? exp(-1000 / (release_ms * srate)) : 0;

// Cache frequently used calculations
srate_inv = 1.0 / srate;
attack_ms_srate = attack_ms * srate;
release_ms_srate = release_ms * srate;

// Apply curves with S-curve and exponential algorithms
attack_curve != 0 ? (
  attack_curve > 0 ? (
    // Positive curves (right): S-curve response - smooth, gradual onset
    curve_amount = attack_curve;
    s_curve_factor = 1.0 + curve_amount * 0.3; // Reduced from 0.6 to 0.3
    s_curve_factor *= (1.0 + curve_amount * 0.15); // Reduced from 0.3 to 0.15
    attack_coeff = pow(attack_coeff, s_curve_factor);
  ) : (
    // Negative curves (left): steep exponential response - fast, aggressive onset
    curve_amount = abs(attack_curve);
    attack_coeff = pow(attack_coeff, 1.0 - curve_amount * 0.3); // Reduced from 0.7 to 0.3
  );
);

release_curve != 0 ? (
  release_curve > 0 ? (
    // Positive curves (right): S-curve response - smooth, gradual recovery
    curve_amount = release_curve;
    s_curve_factor = 1.0 + curve_amount * 0.3; // Reduced from 0.6 to 0.3
    s_curve_factor *= (1.0 + curve_amount * 0.15); // Reduced from 0.3 to 0.15
    release_coeff = pow(release_coeff, s_curve_factor);
  ) : (
    // Negative curves (left): steep exponential response - fast, aggressive recovery
    curve_amount = abs(release_curve);
    release_coeff = pow(release_coeff, 1.0 - curve_amount * 0.3); // Reduced from 0.7 to 0.3
  );
);

// Update RMS parameters every block for real-time response
// Fix: Clear buffer when RMS window size changes to prevent stale data bug
new_rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
new_rms_samples != rms_samples ? (
  rms_samples = new_rms_samples;
  // Clear RMS state when window size changes (fixes bug with stale buffer data)
  menu_true_rms_enabled > 0.5 ? (
    clear_rms_state();  // Clear circular buffer for True RMS mode
  ) : (
    rms_smoothed_squared = 0;  // Reset exponential smoothing state
  );
) : (
  rms_samples = new_rms_samples;  // Update even if same (for safety)
);


//==============================================================================
// GFX RUNTIME
//==============================================================================

@gfx 2625 373 // These MUST be numbers, not variables (75% of original: 3500*0.75=2625, 450*0.75=338, +35 for header)

// Update mouse state constants dynamically (evaluated every frame)
MOUSE_LEFT_BUTTON = mouse_cap & 1 ? 1 : 0;      // Left mouse button
MOUSE_RIGHT_BUTTON = mouse_cap & 2 ? 1 : 0;     // Right mouse button
MOUSE_MIDDLE_BUTTON = mouse_cap & 64 ? 1 : 0;   // Middle mouse button (wheel click)
MOUSE_CTRL_KEY = mouse_cap & 4 ? 1 : 0;         // Ctrl/Cmd key held
MOUSE_SHIFT_KEY = mouse_cap & 8 ? 1 : 0;        // Shift key held
MOUSE_ALT_KEY = mouse_cap & 16 ? 1 : 0;         // Alt key held

// Update histograms with block-max values (most efficient and smooth)
HISTOGRAM_ENABLED ? update_histogram_state(gr_db_for_histogram);
INPUT_HISTOGRAM_ENABLED ? update_input_histogram_state(input_db_for_histogram);

// Render main interface
render_complete_interface();

// Render debug information (controlled by DEBUG_ENABLED in 03_debug_logging.jsfx-inc)
debug_render();


//==============================================================================
// ON SAMPLE
//==============================================================================

@sample

// Process the complete audio chain using modular functions
process_complete_audio_chain();
