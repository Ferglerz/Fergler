// Advanced Multi-Model Compressor JSFX - Modular Version
// Professional multi-algorithm compressor with interactive graph
// Features: multiple characters, feedforward/feedback, RMS normalization,
// program-dependent release, dedicated harmonic stage, soft-clipping limiter
// Author: Custom JSFX Generator
// Version: 3.0 - Advanced multi-model implementation (Modular)

desc:Advanced Multi-Model Compressor (Modular)


//==============================================================================
// SLIDER DEFINITIONS
//==============================================================================


// Time-related parameters (1-6)
slider1:attack_ms=10<0.1,100,0.1>Attack (ms)
slider2:attack_curve=0<-2,2,0.01>-Attack Curve
slider3:release_ms=100<10,1000,1>-Release (ms)
slider4:release_curve=0<-2,2,0.01>-Release Curve
slider5:lookahead_ms=0<0,10,0.1>-Lookahead (ms)
slider6:hold_ms=0<0,50,0.1>-Hold Time (ms)

// RMS & Detection parameters (7-10)
slider7:rms_size_ms=10<1,100,0.1>-RMS Window (ms)
slider8:rms_normalization=0<0,1,1{Off,On}>-RMS Normalization
slider9:detection_mode=1<0,1,1{Feedback,Feedforward}>-Detection Mode
slider10:max_gr_db=-10<-30,0,1>-Max GR (dB)

// Filtering parameters (11-12)
slider11:hp_freq=20<20,1000,1>-HP Filter (Hz)
slider12:lp_freq=20000<200,20000,10>-LP Filter (Hz)

// Character & Harmonics parameters (13-20)
slider13:over_the_top=100<0,200,1>-Over The Top
slider14:harmonic_type=0<0,7,1{Off,Tube Even,Tube Odd,Tube Both,Tape Saturation,Enhanced Tube,FET,Clean Drive}>-Harmonic Type
slider15:harmonic_amount=0<0,1,0.01>-Harmonic Amount
slider16:harmonic_drive=1<0.5,10,0.1>-Harmonic Drive
slider17:harmonic_mix=0<0,1,0.01>-Harmonic Mix
slider18:harmonic_even_boost=0<0,2,0.01>-Even Harmonic Boost
slider19:harmonic_odd_boost=0<0,2,0.01>-Odd Harmonic Boost
slider20:prog_release_mode=0<0,1,1{Fixed Release,Program-Dependent Release}>-Program Release Mode

// Global parameters (21-30)
slider21:strength=1<0.25,3,0.1>-Strength
slider22:global_offset_db=0<-30,30,0.1>-Global Offset (dB)
slider23:strength_curve=0<-2,2,0.01>-Strength Curve (exp)
slider24:makeup_gain_db=0<-20,20,0.1>-Makeup Gain (dB)
slider25:compressor_type=0<0,6,1{Clean Digital,Varimu,Bridged Diode,VCA,PWM/Fairchild,FET,Optical}>-Compressor Type
slider26:use_sidechain=0<0,1,1{No,Yes}>-Use Sidechain
slider27:listen_to_sidechain=0<0,1,1{No,Yes}>-Listen to Detection Signal
slider28:prog_release_type=0<0,3,1{Level-Dependent,Rate-Of-Change,Hybrid,Input-Level}>-Program Release Type
slider29:brickwall_limiter=1<0,1,1{Off,On}>-Brickwall Limiter

// Stage Control parameters (31-40) - Control which processing stages are active
slider31:stage_filtering=1<0,1,1{Off,On}>-Detection Filtering
slider32:stage_harmonics=1<0,1,1{Off,On}>-Harmonic Processing
slider33:stage_lookahead=1<0,1,1{Off,On}>-Lookahead Processing
slider34:stage_character=1<0,1,1{Off,On}>-Character Processing
slider35:stage_limiter=1<0,1,1{Off,On}>-Brickwall Limiter

// Advanced Envelope parameters (36-40)
slider36:multi_stage_release=0<0,1,1{Off,On}>-Multi-Stage Release
slider37:gr_blend_threshold_db=6<1,24,0.1>-GR Blend Threshold (dB)
slider38:input_level_threshold_db=-20<-80,0,0.1>-Input Level Threshold (dB)
slider39:transient_detection=0<0,100,1>-Transient Detection (0=Off, 100=Max)
slider40:transient_threshold_db=-10<-80,0,0.1>-Transient Threshold (dB)

// SEARCH STOP

//==============================================================================
// INCLUDE MODULES
//==============================================================================

// For Claude: These are import, not @import or include or @include

// Phase 00: Constants and utilities (no dependencies)
import 00a_constants.jsfx-inc
import 00b_math_utils.jsfx-inc
import 00d_dsp_utils.jsfx-inc
import 00e_debug_logging.jsfx-inc

// Phase 01: Foundation modules (depend on phase 00)
import 01a_memory.jsfx-inc
import 01b_state.jsfx-inc
// UI config now included in 00a_constants.jsfx-inc
import 01g_file_reading.jsfx-inc

// Phase 02: UI utilities (depend on phase 00-01)
import 02d_ui_utils.jsfx-inc


// Graph data modules
import 03a_graph_data.jsfx-inc

// Audio processing modules
import 04a_compression_core.jsfx-inc
import 04c_filters.jsfx-inc
import 04d_detection.jsfx-inc
import 04e_envelope.jsfx-inc
import 04f_harmonic_models.jsfx-inc
// 04g_effects.jsfx-inc removed - lookahead moved to 00d_dsp_utils.jsfx-inc, final mix inlined
import 04h_audio_processing_chain.jsfx-inc

// UI modules (in dependency order - orchestration MUST be last)
import 05a_ui_threshold_lines.jsfx-inc
import 05b_ui_interaction.jsfx-inc
import 05c_ui_rendering.jsfx-inc
import 05d_ui_controls.jsfx-inc
import 05e_ui_graph.jsfx-inc
import 05f_ui_orchestration.jsfx-inc


//==============================================================================
// SERIALIZE
//==============================================================================

@serialize
// Prevent memory/variables from being cleared on @init
ext_noinit = 1.0;

debug_log("");
debug_log("=== SERIALIZATION ===");
debug_logf("Version: %d", graph_serialization_version);
debug_logf("Points: %d", num_points);

// Serialize graph points data for persistence across plugin duplication and project saves
// Format: [version][num_points][point1_x][point1_y][point2_x][point2_y]...[curve1][curve2]...
// Version 1: Basic graph points serialization
// Version 2: Added curve data serialization
// This ensures graph points and curves are preserved when:
// - Duplicating the plugin instance
// - Copying/pasting the track
// - Saving and reopening the project
// - Restarting REAPER
file_var(0, graph_serialization_version);
file_var(0, num_points);

// Save all graph points
i = 0;
while (i < num_points) (
  file_var(0, graph_points[i*2]);     // input_db
  file_var(0, graph_points[i*2 + 1]); // output_db
  i += 1;
);

// Save curve data (Version 2+)
graph_serialization_version >= 2 ? (
  i = 0;
  while (i < num_points) (
    file_var(0, curve_amounts[i]);
    i += 1;
  );
);

@init

//==============================================================================
// INITIALIZATION SEQUENCE
//==============================================================================

// Clear and start debug logging
debug_clear();
debug_log("");
debug_log("=== PLUGIN INITIALIZATION ===");

// 1. Initialize all constants, memory, and state variables
debug_log("Allocating memory...");
// Allocate all memory
allocate_memory();
allocate_control_memory();
// Initialize all state variables
init_state_variables();
debug_logf("Memory allocated: %d bytes", get_memory_usage());

// 2. Initialize stage control variables
debug_log("Initializing stage controls...");
stage_input = 1;                    // Input stage (always needed)
stage_detection_source = 1;         // Detection source selection
stage_filtering = 1;      // Detection signal filtering (applies to active detection signal)
stage_detection_analysis = 1;       // RMS detection and gain reduction calculation
stage_character = 1;                // Character application
stage_envelope = 1;                 // Envelope following
stage_lookahead = 1;                // Lookahead processing
stage_gain_reduction = 1;           // Gain reduction application
stage_harmonics = 1;                // Harmonic processing
stage_final_mix = 1;                // Final mix
stage_limiter = 1;                  // Brickwall limiter
stage_output = 1;                   // Output stage (always needed)

stage_filtering_prev = -1;
stage_harmonics_prev = -1;
stage_lookahead_prev = -1;
stage_character_prev = -1;
stage_limiter_prev = -1;

// Initialize slider processing flag (ensures @slider calculations run on first load)
slider_initialized = 0;

// 3. Read slider definitions from file
debug_log("Reading slider definitions...");
read_slider_definitions();

slider_names_loaded ? (
  debug_logf("Loaded %d slider definitions", slider_names_count);
) : (
  debug_log("ERROR: Failed to load slider definitions");
);

// 3. Initialize curve data
debug_log("Initializing curve data...");
init_curve_data();

// 4. Set up control layout
debug_log("Setting up control layout...");
setup_control_layout();
debug_logf("Configured %d controls", NUM_CONTROLS);

// 5. Initialize or restore graph points
debug_log("Initializing graph...");
!graph_initialized ? (
  // Try to restore from serialized data
  restore_graph_points_from_serialization() ? (
    debug_log("Restored graph from saved data");
  ) : (
    // Initialize with defaults
    num_points = 6;
    init_graph_points();
    debug_log("Initialized default graph points");
  );
  graph_initialized = 1;
);
debug_logf("Graph ready with %d points", num_points);

// 6. Initialization complete
debug_separator();
debug_log("INITIALIZATION COMPLETE");
debug_logf("Total debug messages: %d", debug_get_message_count());

//==============================================================================
// ON SLIDER UPDATES
//==============================================================================

@slider

// Track which parameters actually changed
param_changed = 0;

// --- Filter Parameters (11-12) ---
// Filter coefficients are updated in @block for real-time response

// --- Timing Parameters (1-6) ---
(slider1 != attack_ms_prev || slider3 != release_ms_prev || 
 slider5 != lookahead_ms_prev || slider6 != hold_ms_prev ||
 slider7 != rms_size_ms_prev || !slider_initialized) ? (
  
  // Calculate sample counts
  rms_samples = clamp(floor(rms_size_ms * 0.001 * srate), 1, max_rms_samples);
  lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);
  hold_samples = floor(hold_ms * 0.001 * srate);

  // Calculate time coefficients
  attack_coeff = attack_ms > 0 ? exp(-1000 / (attack_ms * srate)) : 0;
  release_coeff = release_ms > 0 ? exp(-1000 / (release_ms * srate)) : 0;

  // Apply curves if set
  attack_curve != 0 ? attack_coeff = pow(attack_coeff, pow(2, attack_curve));
  release_curve != 0 ? release_coeff = pow(release_coeff, pow(2, release_curve));
  
  param_changed = 1;
  
  // Store for next comparison
  attack_ms_prev = slider1;
  release_ms_prev = slider3;
  lookahead_ms_prev = slider5;
  hold_ms_prev = slider6;
  rms_size_ms_prev = slider7;
);

// --- Makeup Gain (24) ---
(slider24 != makeup_gain_db_prev || !slider_initialized) ? (
  makeup_gain_linear = db_to_linear(makeup_gain_db);
  makeup_gain_db_prev = slider24;
  param_changed = 1;
);

// --- Over The Top (13) ---
(slider13 != over_the_top_prev || !slider_initialized) ? (
  over_the_top_factor = over_the_top * 0.01;
  over_the_top_prev = slider13;
  param_changed = 1;
);

// --- Plugin Delay Compensation ---
slider5 != lookahead_ms_pdc_prev ? (
  lookahead_samples > 0 ? (
    pdc_delay = lookahead_samples;
    pdc_bot_ch = 0;
    pdc_top_ch = num_ch;
  ) : (
    pdc_delay = 0;
  );
  lookahead_ms_pdc_prev = slider5;
);

// --- Stage Control Parameters (31-35) ---
(stage_filtering != stage_filtering_prev || slider32 != stage_harmonics_prev ||
 slider33 != stage_lookahead_prev || slider34 != stage_character_prev ||
 slider35 != stage_limiter_prev || !slider_initialized) ? (
  // stage_filtering is automatically set by slider31
  stage_harmonics = slider32;
  stage_lookahead = slider33;
  stage_character = slider34;
  stage_limiter = slider35;

  stage_filtering_prev = stage_filtering;
  stage_harmonics_prev = slider32;
  stage_lookahead_prev = slider33;
  stage_character_prev = slider34;
  stage_limiter_prev = slider35;

  param_changed = 1;
);

// --- Curve-affecting parameters ---
(slider21 != strength_prev || slider22 != global_offset_db_prev ||
 slider23 != strength_curve_prev || !slider_initialized) ? (
  strength_prev = slider21;
  global_offset_db_prev = slider22;
  strength_curve_prev = slider23;
  param_changed = 1;
);

// Mark slider section as initialized (ensures all calculations run on first load)
slider_initialized = 1;

// Debug parameter changes
param_changed ? (
  debug_logf("Parameters updated (count: %d)", param_changed);
);

//==============================================================================
// ON BLOCK
//==============================================================================

@block

// Update filter coefficients every block for real-time response
update_filter_coefficients();

//==============================================================================
// GFX RUNTIME
//==============================================================================

@gfx 3500 450 // These MUST be numbers, not variables

// Update mouse state constants dynamically (evaluated every frame)
MOUSE_LEFT_BUTTON = mouse_cap & 1 ? 1 : 0;      // Left mouse button
MOUSE_RIGHT_BUTTON = mouse_cap & 2 ? 1 : 0;     // Right mouse button
MOUSE_MIDDLE_BUTTON = mouse_cap & 64 ? 1 : 0;   // Middle mouse button (wheel click)
MOUSE_CTRL_KEY = mouse_cap & 4 ? 1 : 0;         // Ctrl/Cmd key held
MOUSE_SHIFT_KEY = mouse_cap & 8 ? 1 : 0;        // Shift key held
MOUSE_ALT_KEY = mouse_cap & 16 ? 1 : 0;         // Alt key held

// Render main interface
render_complete_interface();

// Render debug information (controlled by DEBUG_ENABLED in 01f_debug_logging.jsfx-inc)
debug_render();


//==============================================================================
// ON SAMPLE
//==============================================================================

@sample

// Process the complete audio chain using modular functions
process_complete_audio_chain();
