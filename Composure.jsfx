// Advanced Multi-Model Compressor JSFX - Modular Version
// Professional multi-algorithm compressor with interactive graph
// Features: multiple characters, feedforward/feedback, RMS normalization,
// program-dependent release, dedicated harmonic stage, soft-clipping limiter
// Author: Custom JSFX Generator
// Version: 3.0 - Advanced multi-model implementation (Modular)

desc:Advanced Multi-Model Compressor (Modular)


//==============================================================================
// SLIDER DEFINITIONS
//==============================================================================


// Time-related parameters (1-5)
slider1:attack_ms=10<0.05,100,0.1>-Attack
slider2:attack_curve=0<-2,2,0.01>-Attack Curve
slider3:release_ms=100<10,1000,1>Release
slider4:release_curve=-2<-2,2,0.01>-Release Curve
slider5:lookahead_ms=0<0,2000,1>-Lookahead

// RMS & Detection parameters (6-9)
slider6:rms_size_ms=0<1,100,0.1>-RMS Window
slider7:rms_normalization=0<0,1,1{Off,On}>-RMS Normalization
slider8:detection_mode=1<0,1,1{Feedback,Feedforward}>-Detection Mode
slider9:max_gr_db=-100<-100,0,1>-Max GR

// Filtering parameters (10-11)
// Sliders store actual frequency values - discrete steps
// HP: 0=Off (displayed as "Off" in UI), then 20Hz to 6kHz
// LP: 20Hz to 14kHz, then 0=Off (displayed as "Off" in UI, default)
slider10:hp_freq=0<0,6000,1{0,20,30,40,60,80,100,120,150,200,250,300,350,400,500,600,750,1000,1250,1500,1750,2000,2500,3000,3500,4000,5000,6000}>-HP Filter
slider11:lp_freq=16000<0,14000,1{20,30,40,60,80,100,120,150,200,250,300,350,400,500,600,750,1000,1250,1500,1750,2000,2500,3000,3500,4000,5000,6000,8000,10000,12000,14000,0}>-LP Filter

// Character & Harmonics parameters (12-17)
slider12:harmonic_type=0<0,2,1{Off,Tape,Tube}>-Type
slider13:harmonic_amount=0<0,1,0.01>-Amount
slider14:harmonic_drive=50<0,100,1>-Drive (%)
slider15:harmonic_mix=0<0,100,1>-Mix
slider16:harmonic_even_boost=0<0,200,1>-Even
slider17:harmonic_odd_boost=0<0,200,1>-Odd

// Global parameters (18-24)
slider18:strength=1<0.25,10,0.1>Strength
slider19:global_offset_db=0<-30,30,0.25>-Global Offset
slider20:makeup_gain_db=0<-20,20,0.1>-Makeup Gain
slider21:compressor_type=0<0,6,1{Clean Digital,Varimu,Bridged Diode,VCA,PWM/Fairchild,FET,Optical}>-Compressor Type
slider22:use_sidechain=0<0,1,1{No,Yes}>-Use Sidechain
slider23:listen_to_sidechain=0<0,1,1{No,Yes}>-Listen to Detection Signal
slider24:prog_release_type=0<0,3,1{Fixed Release,Input-Dependent,GR Dependent,Rate-of-Change}>-Program Release Type
slider25:brickwall_limiter=1<0,1,1{Off,On}>-Brickwall Limiter

// Advanced Envelope parameters (26-29)
slider26:gr_blend_threshold_db=6<1,24,0.1>-GR Blend Threshold (dB)
slider27:input_level_threshold_db=-20<-80,0,0.1>-Input Level Threshold (dB)
slider28:input_level_threshold_2_db=-40<-80,0,0.1>-Input Level Threshold 2 (dB)

// Dot Trail parameters (31-32)
slider31:trail_interval_ms=50<10,500,10>-Trail Interval (ms)
slider32:trail_fade_duration_ms=1000<100,5000,50>-Trail Fade Duration (ms)

// Time multiplier for attack display (33)
slider33:time_multiplier=1<0,2,1{Milliseconds,Microseconds,Seconds}>-Time Unit

// Input dot blend (34)
slider34:input_dot_blend=100<0,100,1>-Input Dot Blend (%)

// Hold parameter (35)
slider35:hold_ms=0<0,1000,1>Hold

// SEARCH STOP

//==============================================================================
// INCLUDE MODULES
//==============================================================================

// For Claude: These are import, not @import or include or @include

// 01_Utils: Foundation utilities (no dependencies)
import 01_Utils/01_constants.jsfx-inc
import 01_Utils/02_math_utils.jsfx-inc
import 01_Utils/03_debug_logging.jsfx-inc
import 01_Utils/04_file_reading.jsfx-inc
import 01_Utils/05_memory.jsfx-inc
import 01_Utils/06_state.jsfx-inc

// 02_InputProcessing: Input signal conditioning (depends on 01_Utils)
import 02_InputProcessing/01_dsp_utils.jsfx-inc
import 02_InputProcessing/02_filters.jsfx-inc

// 03_Compression: Core compression engine (depends on 01_Utils, 02_InputProcessing)
import 03_Compression/01_compression_constants.jsfx-inc
import 03_Compression/02_graph_data_core.jsfx-inc
import 03_Compression/03_graph_curves.jsfx-inc
import 03_Compression/05_compression_core.jsfx-inc
import 03_Compression/06_gain_reduction.jsfx-inc
import 03_Compression/07_envelope.jsfx-inc
import 03_Compression/08_harmonic_models.jsfx-inc
import 03_Compression/09_audio_processing_chain.jsfx-inc

// UI_General: General UI components (constants, utils, drawing, debug, header, menu)
// These are foundational and must be imported first
import UI_General/00_ui_constants.jsfx-inc
import UI_General/02_ui_utils.jsfx-inc
import UI_General/01_drawing_primitives.jsfx-inc
import UI_General/04_debug.jsfx-inc
import UI_General/10_menu.jsfx-inc
import UI_General/05_header.jsfx-inc
// Coordinate conversion service (independent, used by graph and meter)
import UI_General/12_coordinate_conversion.jsfx-inc
// Threshold lines service (independent, used by graph and meter)
import UI_General/11_threshold_lines.jsfx-inc

// UI_Sliders: Slider control library (depends on UI_General)
import UI_Sliders/01a_value_formatting.jsfx-inc
import UI_Sliders/01b_value_text_rendering.jsfx-inc
import UI_Sliders/01c_slider_rendering.jsfx-inc
import UI_Sliders/01d_knob_rendering.jsfx-inc
import UI_Sliders/01e_button_rendering.jsfx-inc
import UI_Sliders/01f_dropdown_rendering.jsfx-inc
import UI_Sliders/01g_control_dispatcher.jsfx-inc
import UI_Sliders/01_control_definitions.jsfx-inc
import UI_Sliders/02_control_interactions.jsfx-inc

// Composure-specific control layout (uses Sliders library)
import UI_Sliders/05_Composure_Controls.jsfx-inc

// UI_Graph: Graph rendering and interaction (depends on UI_General)
// threshold_lines is now in UI_General and independent
import UI_Graph/06_graph_cache.jsfx-inc
import UI_Graph/07_graph_curves.jsfx-inc
import UI_Graph/08_graph_meters.jsfx-inc
import UI_Graph/09_graph_display.jsfx-inc
import UI_Graph/12_dot_trail.jsfx-inc
import UI_Graph/03_graph.jsfx-inc

// UI_General: UI orchestration (depends on UI_General, UI_Sliders, UI_Graph)
// These must be imported last as they orchestrate all UI components
import UI_General/13_ui_interaction.jsfx-inc
import UI_General/14_ui_orchestration.jsfx-inc


//==============================================================================
// SERIALIZE
//==============================================================================

@serialize
// Prevent memory/variables from being cleared on @init
ext_noinit = 1.0;

// Serialize graph points data for persistence across plugin duplication and project saves
// This ensures graph points and curves are preserved when:
// - Duplicating the plugin instance
// - Copying/pasting the track
// - Saving and reopening the project
// - Restarting REAPER
file_var(0, graph_initialized);
file_var(0, num_points);

// Save all graph points
i = 0;
while (i < num_points) (
  file_var(0, graph_points[i*2]);     // input_db
  file_var(0, graph_points[i*2 + 1]); // output_db
  i += 1;
);

// Save curve data
i = 0;
while (i < num_points) (
  file_var(0, curve_amounts[i]);
  i += 1;
);

//==============================================================================
// INITIALIZATION SEQUENCE
//==============================================================================

@init

// 1. Read slider definitions from file FIRST (needed for memory allocation)
read_slider_definitions();

// 2. Initialize all constants, memory, and state variables
allocate_memory();
init_state_variables();

// 2.5. Initialize graph optimization constants (requires GRAPH_SIZE to be defined)
// Must be called after UI_General imports (specifically after 00_ui_constants.jsfx-inc)
init_graph_optimization_constants();

// 3. Initialize stage control variables
stage_input = 1;                    // Input stage (always needed)
stage_detection_source = 1;         // Detection source selection
stage_filtering = 1;                // Detection signal filtering (applies to active detection signal)
stage_detection_analysis = 1;       // RMS detection and gain reduction calculation
stage_character = 1;                // Character application
stage_envelope = 1;                 // Envelope following
stage_lookahead = 1;                // Lookahead processing
stage_gain_reduction = 1;           // Gain reduction application
stage_harmonics = 1;                // Harmonic processing
stage_final_mix = 1;                // Final mix
stage_limiter = 1;                  // Brickwall limiter
stage_output = 1;                   // Output stage (always needed)

// Initialize slider processing flag (ensures @slider calculations run on first load)
slider_initialized = 0;

// Initialize makeup gain to unity (will be recalculated in @slider)
makeup_gain_linear = 1.0;

// Strength multiplier removed - using strength slider directly

// Calculate limiter normalization constant (pre-calculated to avoid per-sample division)
LIMITER_TANH_NORM = 1.0 / tanh(0.95);  // â‰ˆ 1.343

// 4. Initialize curve data
init_curve_data();

// 5. Set up control layout
setup_control_layout();

// 6. Initialize graph points (only on first load)
!graph_initialized ? (
  // Initialize with defaults (ext_noinit preserves values across reloads)
  num_points = 6;
  init_graph_points();
  invalidate_compression_threshold(); // Mark threshold for recalculation
  graph_initialized = 1;
) : (
  // If graph was already initialized (loaded from preset), update corner points
  // to ensure they follow the tangent of the loaded user points
  update_corner_points();
);

// 7. Mark compression system as ready (prevents LUT race condition)
compression_init_complete = 1;

//==============================================================================
// ON SLIDER UPDATES
//==============================================================================

@slider

// Track which parameters actually changed
param_changed = 0;

// --- Filter Parameters (11-12) ---
// Sliders store actual frequency values directly in Hz
// hp_freq: 0 = Off, 1-6000 = filter frequency
// lp_freq: 20000 = Off, 80-19999 = filter frequency
(slider11 != hp_freq_prev || !slider_initialized) ? (
  hp_freq_prev = slider11;
  param_changed = 1;
);

(slider12 != lp_freq_prev || !slider_initialized) ? (
  lp_freq_prev = slider12;
  param_changed = 1;
);

// Filter coefficients are updated in @block for real-time response

// --- Timing Parameters (1-5) ---
(slider1 != attack_ms_prev || slider3 != release_ms_prev ||
 slider5 != lookahead_ms_prev ||
 slider7 != rms_size_ms_prev || slider2 != attack_curve_prev ||
 slider4 != release_curve_prev || !slider_initialized) ? (

  // Clear RMS state if window size changed
  slider7 != rms_size_ms_prev ? (
    clear_rms_state();
  );

  // Calculate sample counts (for reference, not used in exponential smoothing)
  rms_samples = floor(rms_size_ms * 0.001 * srate);
  rms_samples < 1 ? rms_samples = 1;
  lookahead_samples = clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples);

  param_changed = 1;

  // Store for next comparison
  attack_ms_prev = slider1;
  release_ms_prev = slider3;
  lookahead_ms_prev = slider5;
  rms_size_ms_prev = slider7;
  attack_curve_prev = slider2;
  release_curve_prev = slider4;
);

// --- Hold Parameter (35) ---
(slider35 != hold_ms_prev || !slider_initialized) ? (
  hold_ms_prev = slider35;
  param_changed = 1;
);

// --- Makeup Gain (21) ---
(slider21 != makeup_gain_db_prev || !slider_initialized) ? (
  makeup_gain_linear = db_to_linear(makeup_gain_db);
  makeup_gain_db_prev = slider21;
  param_changed = 1;
);


// --- Plugin Delay Compensation ---
// Cockos pattern: Calculate and set unconditionally every @slider execution
// This MUST run every time @slider executes (not just on change)
pdc_delay = min(lookahead_ms * 0.001 * srate, max_lookahead_samples) | 0;
pdc_delay > 0 ? (
  pdc_bot_ch = 0;
  pdc_top_ch = 2;  // Stereo channels (0=left, 1=right)
);

// --- Strength and Global Offset parameters ---
(global_offset_db != global_offset_db_prev || !slider_initialized) ? (
  global_offset_db_prev = global_offset_db;
  
  param_changed = 1;
  
  // Note: Strength is now used directly in gain reduction calculation
  // Global offset is applied at lookup time (shifts input level before curve lookup).
);

// --- Trail Parameters (31-32) ---
(slider31 != trail_interval_ms_prev || slider32 != trail_fade_duration_ms_prev || !slider_initialized) ? (
  trail_interval_ms_prev = slider31;
  trail_fade_duration_ms_prev = slider32;
  
  // Recalculate trail buffer size if parameters changed
  trail_interval_samples = trail_interval_ms * 0.001 * srate;
  trail_fade_samples = trail_fade_duration_ms * 0.001 * srate;
  new_trail_max_dots = ceil(trail_fade_samples / trail_interval_samples) + 10;
  
  // Clamp to allocated size to prevent buffer overflow
  new_trail_max_dots = min(new_trail_max_dots, trail_max_dots_allocated);
  
  // Only update if size changed significantly
  abs(new_trail_max_dots - trail_max_dots) > 5 ? (
    // Update buffer size limit (memory is already allocated)
    trail_max_dots = new_trail_max_dots;
    // Clear existing trail dots when parameters change
    trail_count = 0;
    trail_write_pos = 0;
    trail_last_creation_time = 0;
  );
  
  param_changed = 1;
);

// Mark slider section as initialized (ensures all calculations run on first load)
slider_initialized = 1;

//==============================================================================
// ON BLOCK
//==============================================================================

@block

// Store block-level max values for histograms (captured during previous block)
// Convert detector level from linear to dB (once per block instead of per sample)
input_db_for_histogram = linear_to_db(max(detector_level_block_max, MIN_DETECTOR_LEVEL));
gr_db_for_histogram = gr_db_block_max;

// Reset max trackers for next block
detector_level_block_max = MIN_DETECTOR_LEVEL;
gr_db_block_max = 0;

// Update filter coefficients every block for real-time response
update_filter_coefficients();

// Update attack and release coefficients every block for real-time response
// Cache coefficients to avoid redundant calculations
attack_coeff = attack_ms > 0 ? exp(-1000 / (convert_attack_time_to_ms(attack_ms, time_multiplier) * srate)) : 0;
release_coeff = release_ms > 0 ? exp(-1000 / (release_ms * srate)) : 0;

// Cache frequently used calculations
srate_inv = 1.0 / srate;
attack_ms_srate = convert_attack_time_to_ms(attack_ms, time_multiplier) * srate;
release_ms_srate = release_ms * srate;
hold_samples = clamp(floor(hold_ms * 0.001 * srate), 0, 44100);  // Max 1 second at 44.1kHz

// Apply curves with S-curve and exponential algorithms
attack_curve != 0 ? (
  attack_curve > 0 ? (
    // Positive curves (right): S-curve response - smooth, gradual onset
    curve_amount = attack_curve;
    s_curve_factor = 1.0 + curve_amount * 0.3; // Reduced from 0.6 to 0.3
    s_curve_factor *= (1.0 + curve_amount * 0.15); // Reduced from 0.3 to 0.15
    attack_coeff = pow(attack_coeff, s_curve_factor);
  ) : (
    // Negative curves (left): steep exponential response - fast, aggressive onset
    curve_amount = abs(attack_curve);
    attack_coeff = pow(attack_coeff, 1.0 - curve_amount * 0.3); // Reduced from 0.7 to 0.3
  );
);

release_curve != 0 ? (
  release_curve > 0 ? (
    // Positive curves (right): S-curve response - smooth, gradual recovery
    curve_amount = release_curve;
    s_curve_factor = 1.0 + curve_amount * 0.3; // Reduced from 0.6 to 0.3
    s_curve_factor *= (1.0 + curve_amount * 0.15); // Reduced from 0.3 to 0.15
    release_coeff = pow(release_coeff, s_curve_factor);
  ) : (
    // Negative curves (left): steep exponential response - fast, aggressive recovery
    curve_amount = abs(release_curve);
    release_coeff = pow(release_coeff, 1.0 - curve_amount * 0.3); // Reduced from 0.7 to 0.3
  );
);

// Update RMS parameters every block for real-time response
// Reset exponential smoothing state when window size changes
new_rms_samples = floor(rms_size_ms * 0.001 * srate);
new_rms_samples < 1 ? new_rms_samples = 1;
new_rms_samples != rms_samples ? (
  rms_samples = new_rms_samples;
  rms_smoothed_squared = 0;  // Reset exponential smoothing state
) : (
  rms_samples = new_rms_samples;  // Update even if same (for safety)
);

// OPTIMIZATION: Pre-calculate RMS exponential smoothing coefficients (moved from @sample)
// Only needed when RMS window > 0
rms_size_ms > 0 ? (
  rms_smoothing_coeff = exp(-1000.0 / (rms_size_ms * srate));
  rms_smoothing_one_minus = 1 - rms_smoothing_coeff;
);

// OPTIMIZATION: Cache harmonic drive compensation reciprocal to avoid per-sample division
drive_compensation_inv = 1.0 / max(harmonic_drive, 1);


//==============================================================================
// GFX RUNTIME
//==============================================================================

@gfx 2625 800 // Width: 2625 (75% of 3500), Height: 800 (increased to show debug panel at bottom)

// Update mouse state constants dynamically (evaluated every frame)
MOUSE_LEFT_BUTTON = mouse_cap & 1 ? 1 : 0;      // Left mouse button
MOUSE_RIGHT_BUTTON = mouse_cap & 2 ? 1 : 0;     // Right mouse button
MOUSE_MIDDLE_BUTTON = mouse_cap & 64 ? 1 : 0;   // Middle mouse button (wheel click)
MOUSE_CTRL_KEY = mouse_cap & 4 ? 1 : 0;         // Ctrl/Cmd key held
MOUSE_SHIFT_KEY = mouse_cap & 8 ? 1 : 0;        // Shift key held
MOUSE_ALT_KEY = mouse_cap & 16 ? 1 : 0;         // Alt key held

// Convert detector level to dB once per frame for UI display (instead of per-sample)
current_input_db = linear_to_db(max(detector_level, MIN_DETECTOR_LEVEL));

// Get latest input histogram value (if available)
input_histogram_db = current_input_db;  // Default to current input if histogram not available
INPUT_HISTOGRAM_ENABLED && input_histogram_initialized ? (
  // Get the most recent value from the input histogram buffer
  // buffer_pos points to the next write position, so most recent is (pos - 1) wrapped
  latest_idx = (input_histogram_pos - 1 + input_histogram_max_samples) % input_histogram_max_samples;
  input_histogram_db = input_histogram_buffer[latest_idx];
);

// Calculate blended input dB value based on slider
blend_amount = input_dot_blend / 100.0;  // Convert 0-100 to 0-1
blended_input_db = current_input_db * (1.0 - blend_amount) + input_histogram_db * blend_amount;

// OPTIMIZATION: Cache audio active state (play_state 1=playing, 5=recording)
// This avoids recalculating it 3+ times per frame across different render functions
is_audio_active = (play_state == 1) || (play_state == 5);

// Update histograms with block-max values (most efficient and smooth)
HISTOGRAM_ENABLED ? update_histogram_state(gr_db_for_histogram);
INPUT_HISTOGRAM_ENABLED ? update_input_histogram_state(input_db_for_histogram);

// Strength now used directly - no need for strength_actual

// Render main interface
render_complete_interface();

// Render debug information (controlled by menu_debug_enabled toggle in right-click menu)
debug_render();


//==============================================================================
// ON SAMPLE
//==============================================================================

@sample

// Process the complete audio chain using modular functions
process_complete_audio_chain();
