// DSP Utilities Module
// Digital Signal Processing utility functions
// Depends on: 00a_constants.jsfx-inc, 00b_math_utils.jsfx-inc, 00c_audio_utils.jsfx-inc

@init

//==============================================================================
// FILTER COEFFICIENT CALCULATIONS
//==============================================================================

function calc_biquad_hp(freq) (
  w = 2 * $pi * freq / srate;
  cosw = cos(w);
  sinw = sin(w);
  alpha = sinw / sqrt(2);

  b0 = (1 + cosw) / 2;
  b1 = -(1 + cosw);
  b2 = (1 + cosw) / 2;
  a0 = 1 + alpha;
  a1 = -2 * cosw;
  a2 = 1 - alpha;

  a1 /= a0; a2 /= a0; b0 /= a0; b1 /= a0; b2 /= a0;
);

function calc_biquad_lp(freq) (
  w = 2 * $pi * freq / srate;
  cosw = cos(w);
  sinw = sin(w);
  alpha = sinw / sqrt(2);

  b0 = (1 - cosw) / 2;
  b1 = 1 - cosw;
  b2 = (1 - cosw) / 2;
  a0 = 1 + alpha;
  a1 = -2 * cosw;
  a2 = 1 - alpha;

  a1 /= a0; a2 /= a0; b0 /= a0; b1 /= a0; b2 /= a0;
);

//==============================================================================
// LOOKAHEAD PROCESSING UTILITIES
//==============================================================================

// Calculate lookahead delay samples
function calculate_lookahead_samples(lookahead_ms) (
  clamp(floor(lookahead_ms * 0.001 * srate), 0, max_lookahead_samples)
);

// Calculate RMS window samples
function calculate_rms_samples(rms_ms) (
  clamp(floor(rms_ms * 0.001 * srate), 1, max_rms_samples)
);

//==============================================================================
// LOOKAHEAD PROCESSING
//==============================================================================

function process_lookahead(input_l_orig, input_r_orig) (
  lookahead_samples > 0 ? (
    lookahead_buffer_l[lookahead_pos] = input_l_orig;
    lookahead_buffer_r[lookahead_pos] = input_r_orig;

    delayed_pos = (lookahead_pos - lookahead_samples + max_lookahead_samples) % max_lookahead_samples;
    processed_l = lookahead_buffer_l[delayed_pos];
    processed_r = lookahead_buffer_r[delayed_pos];

    lookahead_pos = (lookahead_pos + 1) % max_lookahead_samples;
  ) : (
    processed_l = input_l_orig;
    processed_r = input_r_orig;
  );

  // Return processed signals via global variables
  lookahead_out_l = processed_l;
  lookahead_out_r = processed_r;
);

//==============================================================================
// SOFT CLIPPING AND LIMITING
//==============================================================================

function soft_clip_limiter(input, prev_sample) (
  // 2x oversampling for inter-sample peak detection
  oversample1 = (input + prev_sample) * 0.5;
  oversample2 = input;

  // Detect peaks above threshold
  peak_detected = max(abs(oversample1), abs(oversample2)) > 0.95;

  peak_detected ? (
    // Soft clipping using tanh
    limited = tanh(input * 0.95) * (1.0 / tanh(0.95));
  ) : (
    limited = input;
  );

  limited
);
